<!DOCTYPE html>
<html>
<head>
    <title>CircuiTry - Professional Circuit Design</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <style>
        * { 
            margin: 0; 
            padding: 0; 
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        
        body { 
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            color: white; 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            touch-action: none;
            position: fixed;
            width: 100%;
            height: 100%;
            -webkit-overflow-scrolling: touch;
        }

        body.embedded {
            overflow: hidden;
        }

        body.embedded #menu-bar,
        body.embedded #menu-toggle,
        body.embedded #wire-analysis,
        body.embedded #status,
        body.embedded #branding-overlay,
        body.embedded #landing-page,
        body.embedded #launch-btn,
        body.embedded #loading,
        body.embedded #loading-progress,
        body.embedded #loading-text {
            display: none !important;
        }

        body.embedded #canvas {
            display: block !important;
        }
        
        .menu-bar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 100;
            background: rgba(0,0,0,0.95);
            backdrop-filter: blur(15px);
            border-bottom: 2px solid rgba(0,255,136,0.3);
            padding: 12px 16px;
            transition: transform 0.3s ease;
            max-height: 90vh;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
        }
        
        .menu-bar.hidden {
            transform: translateY(-100%);
        }
        
        .menu-tabs {
            display: flex;
            flex-direction: column;
            gap: 8px;
            justify-content: center;
            max-width: 100%;
            margin: 0 auto;
        }
        
        .menu-tab {
            padding: 16px 20px;
            background: linear-gradient(135deg, #333, #444);
            border: 2px solid #555;
            color: white;
            border-radius: 12px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            white-space: nowrap;
            position: relative;
            text-align: center;
            min-height: 56px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .menu-tab:hover, .menu-tab:active {
            background: linear-gradient(135deg, #444, #555);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,255,136,0.2);
        }
        
        .menu-tab.active {
            background: linear-gradient(135deg, #00ff88, #00cc66);
            color: #000;
            border-color: #00ff88;
            box-shadow: 0 0 20px rgba(0,255,136,0.4);
        }
        
        .submenu {
            background: rgba(0,0,0,0.95);
            backdrop-filter: blur(15px);
            border: 2px solid rgba(0,255,136,0.3);
            border-radius: 12px;
            padding: 16px;
            margin-top: 8px;
            display: none;
            width: 100%;
            z-index: 200;
        }
        
        .submenu.active {
            display: block;
        }
        
        .submenu-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
        }
        
        .submenu-row {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin-bottom: 12px;
        }
        
        .submenu-row:last-child {
            margin-bottom: 0;
        }
        
        .btn { 
            padding: 16px 20px; 
            background: linear-gradient(135deg, #333, #444);
            border: 2px solid #555;
            color: white; 
            border-radius: 12px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            white-space: nowrap;
            min-height: 56px;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
        }
        
        .btn:hover, .btn:active { 
            background: linear-gradient(135deg, #444, #555);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }
        
        .wire-btn.active { 
            background: linear-gradient(135deg, #00ff88, #00cc66);
            color: #000;
            border-color: #00ff88;
            box-shadow: 0 0 20px rgba(0,255,136,0.4);
        }
        
        .rotate-btn.active { 
            background: linear-gradient(135deg, #8800ff, #6600cc);
            border-color: #8800ff;
            box-shadow: 0 0 20px rgba(136,0,255,0.4);
        }
        
        .wire-analysis-fixed {
            position: fixed;
            bottom: 20px;
            left: 20px;
            right: 20px;
            background: rgba(0,0,0,0.95);
            backdrop-filter: blur(15px);
            padding: 20px;
            border-radius: 16px;
            border: 2px solid rgba(0,255,136,0.4);
            z-index: 90;
            transition: transform 0.3s ease;
            max-height: 60vh;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
        }
        
        .wire-analysis-fixed.collapsed {
            transform: translateY(calc(100% - 60px));
        }

        .analysis-tabs {
            display: flex;
            margin-bottom: 16px;
            border-radius: 8px;
            overflow: hidden;
            background: rgba(255,255,255,0.1);
            flex-wrap: wrap;
        }

        .analysis-tab {
            flex: 1;
            padding: 10px 6px;
            background: rgba(255,255,255,0.1);
            border: none;
            color: #ccc;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 60px;
            text-align: center;
        }

        .analysis-tab.active {
            background: #00ff88;
            color: #000;
        }

        .analysis-tab:hover {
            background: rgba(255,255,255,0.2);
        }

        .analysis-tab.active:hover {
            background: #00cc66;
        }

        .vir-triangle {
            text-align: center;
            margin-bottom: 20px;
            background: rgba(255,255,255,0.1);
            padding: 16px;
            border-radius: 12px;
            border: 2px solid rgba(255,255,255,0.3);
        }

        .triangle-container {
            position: relative;
            width: 160px;
            height: 140px;
            margin: 0 auto 16px;
        }

        .triangle-shape {
            width: 0;
            height: 0;
            border-left: 80px solid transparent;
            border-right: 80px solid transparent;
            border-bottom: 140px solid rgba(0,255,136,0.3);
            position: relative;
            margin: 0 auto;
        }

        .triangle-sections {
            position: absolute;
            top: 0;
            left: 0;
            width: 160px;
            height: 140px;
        }

        .triangle-v {
            position: absolute;
            top: 15px;
            left: 50%;
            transform: translateX(-50%);
            color: #ff4444;
            font-size: 20px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .triangle-i {
            position: absolute;
            bottom: 15px;
            left: 25%;
            transform: translateX(-50%);
            color: #ff8844;
            font-size: 20px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .triangle-r {
            position: absolute;
            bottom: 15px;
            right: 25%;
            transform: translateX(50%);
            color: #44ff88;
            font-size: 20px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .triangle-v:hover, .triangle-i:hover, .triangle-r:hover {
            transform: translateX(-50%) scale(1.2);
            text-shadow: 0 0 10px currentColor;
        }

        .triangle-formula {
            color: #00ff88;
            font-size: 12px;
            margin-top: 10px;
            font-weight: 600;
        }

        .worksheet-panel {
            background: rgba(255,255,255,0.05);
            border: 2px solid rgba(255,255,255,0.2);
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 16px;
        }

        .worksheet-title {
            color: #00ff88;
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 16px;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .component-list {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            gap: 8px;
            margin-bottom: 16px;
        }

        .component-item {
            background: rgba(255,255,255,0.1);
            padding: 8px;
            border-radius: 8px;
            border: 1px solid rgba(255,255,255,0.3);
            text-align: center;
        }

        .component-label {
            color: #ccc;
            font-size: 10px;
            margin-bottom: 4px;
        }

        .component-value {
            color: white;
            font-weight: bold;
            font-size: 12px;
        }

        .calculations-section {
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
            padding: 12px;
            margin-top: 16px;
        }

        .calculation-step {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 8px;
            background: rgba(255,255,255,0.05);
            border-radius: 6px;
            margin-bottom: 6px;
            border-left: 3px solid;
        }

        .step-voltage { border-left-color: #ff4444; }
        .step-current { border-left-color: #ff8844; }
        .step-resistance { border-left-color: #44ff88; }
        .step-power { border-left-color: #4488ff; }

        .step-label {
            color: #ccc;
            font-size: 12px;
            font-weight: 600;
        }

        .step-formula {
            color: #888;
            font-size: 10px;
            font-family: monospace;
        }

        .step-value {
            color: white;
            font-weight: bold;
            font-size: 14px;
        }

        .problem-mode {
            background: rgba(255,165,0,0.1);
            border: 2px solid rgba(255,165,0,0.3);
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 16px;
        }

        .problem-title {
            color: #ffaa00;
            font-weight: bold;
            margin-bottom: 12px;
            text-align: center;
            font-size: 16px;
        }

        .unknown-input {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }

        .unknown-input label {
            font-size: 12px;
            width: 100px;
        }

        .unknown-input input {
            width: 70px;
            padding: 6px;
            border: 2px solid #555;
            border-radius: 6px;
            background: rgba(255,255,255,0.1);
            color: white;
            text-align: center;
            font-weight: bold;
            font-size: 12px;
        }

        .unknown-input input:focus {
            outline: none;
            border-color: #00ff88;
        }

        .check-answer-btn {
            background: linear-gradient(135deg, #00ff88, #00cc66);
            color: #000;
            border: none;
            padding: 8px 16px;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 12px;
            width: 100%;
        }

        .check-answer-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0,255,136,0.3);
        }

        .result-feedback {
            padding: 8px;
            border-radius: 8px;
            margin-top: 8px;
            font-weight: bold;
            text-align: center;
            font-size: 12px;
        }

        .feedback-correct {
            background: rgba(0,255,0,0.2);
            border: 2px solid #00ff00;
            color: #00ff88;
        }

        .feedback-incorrect {
            background: rgba(255,0,0,0.2);
            border: 2px solid #ff0000;
            color: #ff6666;
        }

        .circuit-diagram {
            background: rgba(255,255,255,0.05);
            border: 2px solid rgba(255,255,255,0.2);
            border-radius: 12px;
            padding: 12px;
            margin-bottom: 16px;
            min-height: 120px;
            position: relative;
        }

        .diagram-title {
            color: #00ff88;
            font-size: 14px;
            font-weight: bold;
            margin-bottom: 8px;
            text-align: center;
        }

        .circuit-schematic {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100px;
            font-family: monospace;
            color: #ccc;
            line-height: 1.2;
            font-size: 11px;
        }

        .schematic-line {
            margin: 1px 0;
            white-space: pre;
        }

        .practice-problem-card {
            background: rgba(0,150,255,0.1);
            border: 2px solid rgba(0,150,255,0.3);
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 16px;
        }

        .problem-question {
            color: #4da6ff;
            font-weight: bold;
            font-size: 16px;
            margin-bottom: 12px;
            text-align: center;
        }

        .problem-description {
            color: #ccc;
            margin-bottom: 12px;
            text-align: center;
            font-size: 14px;
        }

        .circuit-status {
            background: rgba(255,255,255,0.1);
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 12px;
            text-align: center;
        }

        .status-complete {
            border: 2px solid #00ff88;
            color: #00ff88;
        }

        .status-incomplete {
            border: 2px solid #ffaa00;
            color: #ffaa00;
        }

        .wire-instructions {
            background: rgba(255,200,0,0.1);
            border: 1px solid rgba(255,200,0,0.3);
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 12px;
            color: #ffcc66;
            font-size: 12px;
            text-align: center;
        }

        .practice-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-bottom: 16px;
        }

        .practice-btn {
            padding: 12px 8px;
            background: linear-gradient(135deg, #333, #444);
            border: 2px solid #555;
            color: white;
            border-radius: 8px;
            font-size: 11px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
        }

        .practice-btn:hover {
            background: linear-gradient(135deg, #444, #555);
            transform: translateY(-1px);
        }

        .practice-btn.active {
            background: linear-gradient(135deg, #00ff88, #00cc66);
            color: #000;
            border-color: #00ff88;
        }
        
        .analysis-toggle {
            position: absolute;
            left: 50%;
            top: -30px;
            transform: translateX(-50%);
            background: #00ff88;
            border: 3px solid #ffffff;
            color: #000000;
            border-radius: 50%;
            width: 60px;
            height: 60px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 18px;
            box-shadow: 0 4px 12px rgba(0,255,136,0.3);
        }
        
        .menu-toggle {
            position: fixed;
            top: 20px;
            left: 20px;
            background: #00ff88;
            border: 3px solid #ffffff;
            color: #000000;
            border-radius: 50%;
            width: 64px;
            height: 64px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 300;
            font-weight: bold;
            font-size: 20px;
            box-shadow: 0 4px 12px rgba(0,255,136,0.3);
        }
        
        .status {
            position: fixed;
            bottom: 300px;
            left: 20px;
            right: 20px;
            background: rgba(0,255,136,0.1);
            backdrop-filter: blur(10px);
            padding: 16px 20px;
            border-radius: 16px;
            border: 1px solid rgba(0,255,136,0.3);
            z-index: 100;
            color: #00ff88;
            font-weight: 600;
            text-align: center;
            font-size: 16px;
            line-height: 1.4;
        }
        
        .edit-popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.95);
            backdrop-filter: blur(15px);
            border: 2px solid #00ff88;
            border-radius: 16px;
            padding: 24px;
            z-index: 1000;
            display: none;
            width: 90%;
            max-width: 400px;
            max-height: 80vh;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            box-shadow: 0 10px 30px rgba(0,255,136,0.3);
        }
        
        .edit-popup h3 {
            color: #00ff88;
            margin: 0 0 20px 0;
            text-align: center;
            font-size: 20px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .edit-row {
            margin-bottom: 20px;
        }
        
        .edit-row label {
            display: block;
            color: #ccc;
            margin-bottom: 8px;
            font-size: 16px;
            font-weight: 600;
        }
        
        .edit-row input, .edit-row select {
            width: 100%;
            padding: 16px;
            border: 2px solid #555;
            border-radius: 12px;
            background: rgba(255,255,255,0.1);
            color: white;
            font-size: 16px;
            transition: border-color 0.3s ease;
            min-height: 56px;
        }
        
        .edit-row input:focus, .edit-row select:focus {
            outline: none;
            border-color: #00ff88;
            box-shadow: 0 0 10px rgba(0,255,136,0.2);
        }
        
        .edit-buttons {
            display: flex;
            gap: 16px;
            margin-top: 24px;
        }
        
        .edit-btn {
            flex: 1;
            padding: 16px;
            border: none;
            border-radius: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 16px;
            min-height: 56px;
        }
        
        .edit-btn.save {
            background: linear-gradient(135deg, #00ff88, #00cc66);
            color: #000;
        }
        
        .e<!DOCTYPE html>
<html>
<head>
    <title>CircuiTry - Professional Circuit Design</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <style>
        * { 
            margin: 0; 
            padding: 0; 
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        
        body { 
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            color: white; 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            touch-action: none;
            position: fixed;
            width: 100%;
            height: 100%;
            -webkit-overflow-scrolling: touch;
        }
        
        .menu-bar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 100;
            background: rgba(0,0,0,0.95);
            backdrop-filter: blur(15px);
            border-bottom: 2px solid rgba(0,255,136,0.3);
            padding: 12px 16px;
            transition: transform 0.3s ease;
            max-height: 90vh;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
        }
        
        .menu-bar.hidden {
            transform: translateY(-100%);
        }
        
        .menu-tabs {
            display: flex;
            flex-direction: column;
            gap: 8px;
            justify-content: center;
            max-width: 100%;
            margin: 0 auto;
        }
        
        .menu-tab {
            padding: 16px 20px;
            background: linear-gradient(135deg, #333, #444);
            border: 2px solid #555;
            color: white;
            border-radius: 12px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            white-space: nowrap;
            position: relative;
            text-align: center;
            min-height: 56px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .menu-tab:hover, .menu-tab:active {
            background: linear-gradient(135deg, #444, #555);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,255,136,0.2);
        }
        
        .menu-tab.active {
            background: linear-gradient(135deg, #00ff88, #00cc66);
            color: #000;
            border-color: #00ff88;
            box-shadow: 0 0 20px rgba(0,255,136,0.4);
        }
        
        .submenu {
            background: rgba(0,0,0,0.95);
            backdrop-filter: blur(15px);
            border: 2px solid rgba(0,255,136,0.3);
            border-radius: 12px;
            padding: 16px;
            margin-top: 8px;
            display: none;
            width: 100%;
            z-index: 200;
        }
        
        .submenu.active {
            display: block;
        }
        
        .submenu-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
        }
        
        .submenu-row {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin-bottom: 12px;
        }
        
        .submenu-row:last-child {
            margin-bottom: 0;
        }
        
        .btn { 
            padding: 16px 20px; 
            background: linear-gradient(135deg, #333, #444);
            border: 2px solid #555;
            color: white; 
            border-radius: 12px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            white-space: nowrap;
            min-height: 56px;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
        }
        
        .btn:hover, .btn:active { 
            background: linear-gradient(135deg, #444, #555);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }
        
        .wire-btn.active { 
            background: linear-gradient(135deg, #00ff88, #00cc66);
            color: #000;
            border-color: #00ff88;
            box-shadow: 0 0 20px rgba(0,255,136,0.4);
        }
        
        .rotate-btn.active { 
            background: linear-gradient(135deg, #8800ff, #6600cc);
            border-color: #8800ff;
            box-shadow: 0 0 20px rgba(136,0,255,0.4);
        }
        
        .wire-analysis-fixed {
            position: fixed;
            bottom: 20px;
            left: 20px;
            right: 20px;
            background: rgba(0,0,0,0.95);
            backdrop-filter: blur(15px);
            padding: 20px;
            border-radius: 16px;
            border: 2px solid rgba(0,255,136,0.4);
            z-index: 90;
            transition: transform 0.3s ease;
            max-height: 60vh;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
        }
        
        .wire-analysis-fixed.collapsed {
            transform: translateY(calc(100% - 60px));
        }

        .analysis-tabs {
            display: flex;
            margin-bottom: 16px;
            border-radius: 8px;
            overflow: hidden;
            background: rgba(255,255,255,0.1);
            flex-wrap: wrap;
        }

        .analysis-tab {
            flex: 1;
            padding: 10px 6px;
            background: rgba(255,255,255,0.1);
            border: none;
            color: #ccc;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 60px;
            text-align: center;
        }

        .analysis-tab.active {
            background: #00ff88;
            color: #000;
        }

        .analysis-tab:hover {
            background: rgba(255,255,255,0.2);
        }

        .analysis-tab.active:hover {
            background: #00cc66;
        }

        .vir-triangle {
            text-align: center;
            margin-bottom: 20px;
            background: rgba(255,255,255,0.1);
            padding: 16px;
            border-radius: 12px;
            border: 2px solid rgba(255,255,255,0.3);
        }

        .triangle-container {
            position: relative;
            width: 160px;
            height: 140px;
            margin: 0 auto 16px;
        }

        .triangle-shape {
            width: 0;
            height: 0;
            border-left: 80px solid transparent;
            border-right: 80px solid transparent;
            border-bottom: 140px solid rgba(0,255,136,0.3);
            position: relative;
            margin: 0 auto;
        }

        .triangle-sections {
            position: absolute;
            top: 0;
            left: 0;
            width: 160px;
            height: 140px;
        }

        .triangle-v {
            position: absolute;
            top: 15px;
            left: 50%;
            transform: translateX(-50%);
            color: #ff4444;
            font-size: 20px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .triangle-i {
            position: absolute;
            bottom: 15px;
            left: 25%;
            transform: translateX(-50%);
            color: #ff8844;
            font-size: 20px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .triangle-r {
            position: absolute;
            bottom: 15px;
            right: 25%;
            transform: translateX(50%);
            color: #44ff88;
            font-size: 20px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .triangle-v:hover, .triangle-i:hover, .triangle-r:hover {
            transform: translateX(-50%) scale(1.2);
            text-shadow: 0 0 10px currentColor;
        }

        .triangle-formula {
            color: #00ff88;
            font-size: 12px;
            margin-top: 10px;
            font-weight: 600;
        }

        .worksheet-panel {
            background: rgba(255,255,255,0.05);
            border: 2px solid rgba(255,255,255,0.2);
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 16px;
        }

        .worksheet-title {
            color: #00ff88;
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 16px;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .component-list {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            gap: 8px;
            margin-bottom: 16px;
        }

        .component-item {
            background: rgba(255,255,255,0.1);
            padding: 8px;
            border-radius: 8px;
            border: 1px solid rgba(255,255,255,0.3);
            text-align: center;
        }

        .component-label {
            color: #ccc;
            font-size: 10px;
            margin-bottom: 4px;
        }

        .component-value {
            color: white;
            font-weight: bold;
            font-size: 12px;
        }

        .calculations-section {
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
            padding: 12px;
            margin-top: 16px;
        }

        .calculation-step {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 8px;
            background: rgba(255,255,255,0.05);
            border-radius: 6px;
            margin-bottom: 6px;
            border-left: 3px solid;
        }

        .step-voltage { border-left-color: #ff4444; }
        .step-current { border-left-color: #ff8844; }
        .step-resistance { border-left-color: #44ff88; }
        .step-power { border-left-color: #4488ff; }

        .step-label {
            color: #ccc;
            font-size: 12px;
            font-weight: 600;
        }

        .step-formula {
            color: #888;
            font-size: 10px;
            font-family: monospace;
        }

        .step-value {
            color: white;
            font-weight: bold;
            font-size: 14px;
        }

        .problem-mode {
            background: rgba(255,165,0,0.1);
            border: 2px solid rgba(255,165,0,0.3);
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 16px;
        }

        .problem-title {
            color: #ffaa00;
            font-weight: bold;
            margin-bottom: 12px;
            text-align: center;
            font-size: 16px;
        }

        .unknown-input {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }

        .unknown-input label {
            font-size: 12px;
            width: 100px;
        }

        .unknown-input input {
            width: 70px;
            padding: 6px;
            border: 2px solid #555;
            border-radius: 6px;
            background: rgba(255,255,255,0.1);
            color: white;
            text-align: center;
            font-weight: bold;
            font-size: 12px;
        }

        .unknown-input input:focus {
            outline: none;
            border-color: #00ff88;
        }

        .check-answer-btn {
            background: linear-gradient(135deg, #00ff88, #00cc66);
            color: #000;
            border: none;
            padding: 8px 16px;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 12px;
            width: 100%;
        }

        .check-answer-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0,255,136,0.3);
        }

        .result-feedback {
            padding: 8px;
            border-radius: 8px;
            margin-top: 8px;
            font-weight: bold;
            text-align: center;
            font-size: 12px;
        }

        .feedback-correct {
            background: rgba(0,255,0,0.2);
            border: 2px solid #00ff00;
            color: #00ff88;
        }

        .feedback-incorrect {
            background: rgba(255,0,0,0.2);
            border: 2px solid #ff0000;
            color: #ff6666;
        }

        .circuit-diagram {
            background: rgba(255,255,255,0.05);
            border: 2px solid rgba(255,255,255,0.2);
            border-radius: 12px;
            padding: 12px;
            margin-bottom: 16px;
            min-height: 120px;
            position: relative;
        }

        .diagram-title {
            color: #00ff88;
            font-size: 14px;
            font-weight: bold;
            margin-bottom: 8px;
            text-align: center;
        }

        .circuit-schematic {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100px;
            font-family: monospace;
            color: #ccc;
            line-height: 1.2;
            font-size: 11px;
        }

        .schematic-line {
            margin: 1px 0;
            white-space: pre;
        }

        .practice-problem-card {
            background: rgba(0,150,255,0.1);
            border: 2px solid rgba(0,150,255,0.3);
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 16px;
        }

        .problem-question {
            color: #4da6ff;
            font-weight: bold;
            font-size: 16px;
            margin-bottom: 12px;
            text-align: center;
        }

        .problem-description {
            color: #ccc;
            margin-bottom: 12px;
            text-align: center;
            font-size: 14px;
        }

        .circuit-status {
            background: rgba(255,255,255,0.1);
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 12px;
            text-align: center;
        }

        .status-complete {
            border: 2px solid #00ff88;
            color: #00ff88;
        }

        .status-incomplete {
            border: 2px solid #ffaa00;
            color: #ffaa00;
        }

        .wire-instructions {
            background: rgba(255,200,0,0.1);
            border: 1px solid rgba(255,200,0,0.3);
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 12px;
            color: #ffcc66;
            font-size: 12px;
            text-align: center;
        }

        .practice-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-bottom: 16px;
        }

        .practice-btn {
            padding: 12px 8px;
            background: linear-gradient(135deg, #333, #444);
            border: 2px solid #555;
            color: white;
            border-radius: 8px;
            font-size: 11px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
        }

        .practice-btn:hover {
            background: linear-gradient(135deg, #444, #555);
            transform: translateY(-1px);
        }

        .practice-btn.active {
            background: linear-gradient(135deg, #00ff88, #00cc66);
            color: #000;
            border-color: #00ff88;
        }
        
        .analysis-toggle {
            position: absolute;
            left: 50%;
            top: -30px;
            transform: translateX(-50%);
            background: #00ff88;
            border: 3px solid #ffffff;
            color: #000000;
            border-radius: 50%;
            width: 60px;
            height: 60px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 18px;
            box-shadow: 0 4px 12px rgba(0,255,136,0.3);
        }
        
        .menu-toggle {
            position: fixed;
            top: 20px;
            left: 20px;
            background: #00ff88;
            border: 3px solid #ffffff;
            color: #000000;
            border-radius: 50%;
            width: 64px;
            height: 64px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 300;
            font-weight: bold;
            font-size: 20px;
            box-shadow: 0 4px 12px rgba(0,255,136,0.3);
        }
        
        .status {
            position: fixed;
            bottom: 300px;
            left: 20px;
            right: 20px;
            background: rgba(0,255,136,0.1);
            backdrop-filter: blur(10px);
            padding: 16px 20px;
            border-radius: 16px;
            border: 1px solid rgba(0,255,136,0.3);
            z-index: 100;
            color: #00ff88;
            font-weight: 600;
            text-align: center;
            font-size: 16px;
            line-height: 1.4;
        }
        
        .edit-popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.95);
            backdrop-filter: blur(15px);
            border: 2px solid #00ff88;
            border-radius: 16px;
            padding: 24px;
            z-index: 1000;
            display: none;
            width: 90%;
            max-width: 400px;
            max-height: 80vh;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            box-shadow: 0 10px 30px rgba(0,255,136,0.3);
        }
        
        .edit-popup h3 {
            color: #00ff88;
            margin: 0 0 20px 0;
            text-align: center;
            font-size: 20px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .edit-row {
            margin-bottom: 20px;
        }
        
        .edit-row label {
            display: block;
            color: #ccc;
            margin-bottom: 8px;
            font-size: 16px;
            font-weight: 600;
        }
        
        .edit-row input, .edit-row select {
            width: 100%;
            padding: 16px;
            border: 2px solid #555;
            border-radius: 12px;
            background: rgba(255,255,255,0.1);
            color: white;
            font-size: 16px;
            transition: border-color 0.3s ease;
            min-height: 56px;
        }
        
        .edit-row input:focus, .edit-row select:focus {
            outline: none;
            border-color: #00ff88;
            box-shadow: 0 0 10px rgba(0,255,136,0.2);
        }
        
        .edit-buttons {
            display: flex;
            gap: 16px;
            margin-top: 24px;
        }
        
        .edit-btn {
            flex: 1;
            padding: 16px;
            border: none;
            border-radius: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 16px;
            min-height: 56px;
        }
        
        .edit-btn.save {
            background: linear-gradient(135deg, #00ff88, #00cc66);
            color: #000;
        }
        
        .edit-btn.cancel {
            background: linear-gradient(135deg, #ff4444, #cc3333);
            color: white;
        }
        
        .edit-btn:hover, .edit-btn:active {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }
        
        .edit-popup-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        
        .edit-close {
            background: transparent;
            border: none;
            color: #ff4444;
            font-size: 28px;
            cursor: pointer;
            padding: 0;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .edit-actions {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        
        .edit-action-btn {
            width: 100%;
            padding: 16px;
            border: 2px solid #00ff88;
            border-radius: 12px;
            background: rgba(0,255,136,0.1);
            color: white;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            min-height: 56px;
        }
        
        .edit-action-btn:hover, .edit-action-btn:active {
            background: rgba(0,255,136,0.2);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,255,136,0.3);
        }
        
        .edit-action-btn.delete-btn {
            border-color: #ff4444;
            background: rgba(255,68,68,0.1);
        }
        
        .edit-action-btn.delete-btn:hover, .edit-action-btn.delete-btn:active {
            background: rgba(255,68,68,0.2);
            box-shadow: 0 4px 12px rgba(255,68,68,0.3);
        }
        
        .wire-analysis {
            text-align: center;
            margin-bottom: 16px;
            background: rgba(0,255,136,0.1);
            padding: 20px;
            border-radius: 16px;
            border: 2px solid rgba(0,255,136,0.3);
        }
        
        .wire-title {
            color: #00ff88;
            font-weight: bold;
            font-size: 20px;
            margin-bottom: 16px;
            text-transform: uppercase;
            letter-spacing: 2px;
            text-shadow: 0 0 10px rgba(0,255,136,0.5);
        }
        
        .wire-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            margin-bottom: 12px;
        }
        
        .wire-item {
            background: rgba(255,255,255,0.12);
            padding: 16px 12px;
            border-radius: 12px;
            border: 2px solid;
            text-align: center;
            transition: all 0.3s ease;
            min-height: 80px;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }
        
        .wire-item:hover, .wire-item:active {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }
        
        .wire-letter {
            font-weight: bold;
            font-size: 28px;
            margin-bottom: 6px;
            text-shadow: 0 0 8px currentColor;
        }
        
        .wire-label {
            color: #ccc;
            font-size: 11px;
            text-transform: uppercase;
            margin-bottom: 6px;
            letter-spacing: 0.5px;
        }
        
        .wire-value {
            font-weight: bold;
            font-size: 18px;
            text-shadow: 0 0 6px currentColor;
        }
        
        .wire-w { border-color: #4488ff; }
        .wire-w .wire-letter { color: #4488ff; }
        .wire-w .wire-value { color: #4488ff; }
        
        .wire-i { border-color: #ff8844; }
        .wire-i .wire-letter { color: #ff8844; }
        .wire-i .wire-value { color: #ff8844; }
        
        .wire-r { border-color: #44ff88; }
        .wire-r .wire-letter { color: #44ff88; }
        .wire-r .wire-value { color: #44ff88; }
        
        .wire-e { border-color: #ff4444; }
        .wire-e .wire-letter { color: #ff4444; }
        .wire-e .wire-value { color: #ff4444; }
        
        #canvas {
            width: 100vw;
            height: 100vh;
            display: block;
            touch-action: none;
            position: fixed;
            top: 0;
            left: 0;
        }
        
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 20px;
            z-index: 1000;
            text-align: center;
            padding: 20px;
        }
        
        .component-label {
            position: absolute;
            pointer-events: none;
            color: white;
            font-weight: bold;
            font-size: 14px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            white-space: nowrap;
            z-index: 10;
            background: rgba(0,0,0,0.7);
            padding: 4px 8px;
            border-radius: 8px;
            border: 1px solid rgba(255,255,255,0.3);
        }
        
        .branding-overlay {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 32px;
            font-weight: 900;
            pointer-events: none;
            z-index: 1;
            user-select: none;
            letter-spacing: -1px;
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
            text-align: center;
            line-height: 1;
            animation: brandingFloat 6s ease-in-out infinite;
        }
        
        .branding-overlay .logo-circui {
            color: rgba(0, 255, 136, 0.15);
            text-shadow: 0 0 12px rgba(0,255,136,0.3), 0 0 24px rgba(0,136,255,0.1);
        }
        
        .branding-overlay .logo-try {
            color: rgba(255, 136, 0, 0.15);
            text-shadow: 0 0 12px rgba(255,136,0,0.3), 0 0 24px rgba(255,255,255,0.08);
        }
        
        .branding-overlay .logo-3d {
            color: rgba(0, 255, 136, 0.15);
            text-shadow: 0 0 12px rgba(0,255,136,0.3), 0 0 24px rgba(0,136,255,0.1);
        }
        
        @keyframes brandingFloat {
            0%, 100% { 
                transform: translateX(-50%) translateY(0px);
                opacity: 0.8;
            }
            50% { 
                transform: translateX(-50%) translateY(-10px);
                opacity: 1;
            }
        }
        
        .branding-overlay.bounce {
            animation: brandingBounce 4s ease-in-out infinite;
        }
        
        @keyframes brandingBounce {
            0%, 100% { 
                transform: translateX(-50%) translateY(0px);
            }
            25% { 
                transform: translateX(-50%) translateY(-20px);
            }
            50% { 
                transform: translateX(-50%) translateY(0px);
            }
            75% { 
                transform: translateX(-50%) translateY(-10px);
            }
        }
        
        .polarity-indicator {
            position: absolute;
            pointer-events: none;
            font-size: 20px;
            font-weight: bold;
            z-index: 15;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.9);
            background: rgba(0,0,0,0.7);
            padding: 2px 6px;
            border-radius: 50%;
            border: 2px solid;
        }
        
        .polarity-positive {
            color: #ff4444;
            border-color: #ff4444;
        }
        
        .polarity-negative {
            color: #4444ff;
            border-color: #4444ff;
        }

        /* Desktop styles for larger screens */
        @media (min-width: 769px) {
            .menu-tabs {
                flex-direction: row;
                flex-wrap: wrap;
                gap: 8px;
            }
            
            .menu-tab {
                width: auto;
                padding: 12px 16px;
                font-size: 14px;
                min-height: auto;
            }
            
            .submenu {
                position: absolute;
                top: 100%;
                left: 50%;
                transform: translateX(-50%);
                margin-top: 8px;
                width: 250px;
            }
            
            .submenu-grid {
                grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            }
            
            .submenu-row {
                flex-direction: row;
                margin-bottom: 8px;
            }
            
            .btn {
                padding: 10px 14px;
                font-size: 14px;
                min-height: auto;
            }
            
            .wire-analysis-fixed {
                top: 80px;
                right: 20px;
                left: auto;
                bottom: auto;
                max-width: 320px;
                max-height: none;
            }
            
            .wire-analysis-fixed.collapsed {
                transform: translateX(calc(100% - 60px));
            }
            
            .analysis-toggle {
                left: -40px;
                top: 50%;
                transform: translateY(-50%);
                width: 40px;
                height: 40px;
                font-size: 14px;
            }
            
            .status {
                bottom: 20px;
                left: 50%;
                right: auto;
                transform: translateX(-50%);
                max-width: 600px;
                font-size: 14px;
            }
            
            .menu-toggle {
                width: 45px;
                height: 45px;
                font-size: 16px;
            }
            
            .edit-popup {
                position: fixed;
                width: 320px;
                max-width: none;
            }
        }

        /* Additional mobile optimizations */
        @media (max-width: 480px) {
            .menu-bar {
                padding: 8px 12px;
            }
            
            .menu-tab {
                padding: 14px 16px;
                font-size: 15px;
            }
            
            .btn {
                padding: 14px 16px;
                font-size: 15px;
            }
            
            .wire-analysis-fixed {
                padding: 16px;
                left: 10px;
                right: 10px;
                bottom: 10px;
            }
            
            .status {
                bottom: 280px;
                left: 10px;
                right: 10px;
                padding: 12px 16px;
                font-size: 15px;
            }
            
            .menu-toggle {
                top: 15px;
                left: 15px;
                width: 56px;
                height: 56px;
            }
            
            .analysis-toggle {
                width: 56px;
                height: 56px;
                top: -28px;
            }
        }

        /* High DPI screens */
        @media (-webkit-min-device-pixel-ratio: 2), (min-resolution: 192dpi) {
            .component-label {
                font-size: 16px;
            }
            
            .wire-letter {
                font-size: 32px;
            }
            
            .wire-value {
                font-size: 20px;
            }
        }

        /* Landscape orientation on mobile */
        @media (orientation: landscape) and (max-height: 500px) {
            .wire-analysis-fixed {
                max-height: 30vh;
            }
            
            .menu-bar {
                max-height: 70vh;
            }
            
            .status {
                bottom: 200px;
            }
        }

        /* Reduce animations on lower-end devices */
        @media (prefers-reduced-motion: reduce) {
            * {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }
        
        /* Landing Page Styles */
        .landing-page {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f1419 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            padding: 20px;
            box-sizing: border-box;
        }
        
        .landing-logo {
            font-size: clamp(48px, 12vw, 92px);
            font-weight: 900;
            text-align: center;
            margin-bottom: 20px;
            letter-spacing: -2px;
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
        }
        .logo-circui { color: #00ff88; text-shadow: 0 0 12px rgba(0,255,136,0.6), 0 0 24px rgba(0,136,255,0.2); }
        .logo-try { color: #ff8800; text-shadow: 0 0 12px rgba(255,136,0,0.6), 0 0 24px rgba(255,255,255,0.15); }
        .logo-pulse { animation: logoPulse 2.2s ease-in-out infinite; }
        @keyframes logoPulse {
            0% { filter: drop-shadow(0 0 8px rgba(100,160,255,0.4)) drop-shadow(0 0 18px rgba(255,255,255,0.25)); }
            50% { filter: drop-shadow(0 0 14px rgba(140,200,255,0.8)) drop-shadow(0 0 28px rgba(255,255,255,0.35)); }
            100% { filter: drop-shadow(0 0 10px rgba(100,160,255,0.6)) drop-shadow(0 0 24px rgba(255,255,255,0.3)); }
        }
        
        .landing-subtitle {
            font-size: clamp(14px, 3vw, 18px);
            color: #8899aa;
            text-align: center;
            margin-bottom: 40px;
            letter-spacing: 3px;
            text-transform: uppercase;
            font-weight: 500;
        }
        
        .circuit-preview {
            width: min(90vw, 400px);
            height: 180px;
            background: rgba(0, 20, 40, 0.6);
            border: 3px solid #00ff88;
            border-radius: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 30px;
            position: relative;
            overflow: hidden;
            backdrop-filter: blur(10px);
        }
        
        .circuit-preview::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(0, 255, 136, 0.1), transparent);
            animation: shimmer 3s infinite;
        }
        
        @keyframes shimmer {
            0% { left: -100%; }
            100% { left: 100%; }
        }
        
        .circuit-svg {
            width: 320px;
            height: 140px;
        }
        
        .circuit-element {
            stroke: #00ff88;
            stroke-width: 2.5;
            fill: none;
        }
        
        .circuit-wire {
            stroke: #66bbff;
            stroke-width: 2;
            fill: none;
        }
        
        .circuit-text {
            fill: #ffffff;
            font-family: 'Segoe UI', sans-serif;
            font-size: 12px;
            font-weight: bold;
        }
        
        .circuit-voltage {
            fill: #ff6666;
            font-size: 11px;
        }
        
        .launch-button {
            background: linear-gradient(135deg, #00ff88 0%, #00cc66 100%);
            color: #000;
            border: none;
            padding: 18px 40px;
            border-radius: 25px;
            font-size: clamp(16px, 4vw, 20px);
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
            box-shadow: 0 8px 25px rgba(0, 255, 136, 0.3);
            margin-bottom: 30px;
        }
        
        .launch-button:hover {
            transform: translateY(-3px);
            box-shadow: 0 12px 35px rgba(0, 255, 136, 0.4);
            background: linear-gradient(135deg, #00ff88 0%, #00dd77 100%);
        }
        
        .launch-button:active {
            transform: translateY(-1px);
        }
        
        .loading-progress {
            width: min(80vw, 300px);
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            overflow: hidden;
            margin-bottom: 20px;
        }
        
        .loading-bar {
            height: 100%;
            background: linear-gradient(90deg, #00ff88, #00cc66, #00ff88);
            background-size: 200% 100%;
            animation: loading 2s ease-in-out;
            border-radius: 2px;
        }
        
        @keyframes loading {
            0% { width: 0%; }
            50% { width: 70%; }
            100% { width: 100%; }
        }
        
        .loading-text {
            color: #00ff88;
            font-size: clamp(14px, 3.5vw, 16px);
            font-weight: 600;
            text-align: center;
            margin-bottom: 15px;
        }
        
        .version-text {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            color: #666;
            font-size: 12px;
        }
        
        .landing-hidden {
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s ease;
        }
        
        /* Improved circuit centering and alignment */
        .circuit-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            padding: 20px;
        }
        
        /* Professional schematic styling */
        .schematic-mode .component-label {
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.5);
            padding: 6px 10px;
            border-radius: 6px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 12px;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <!-- Landing Page -->
    <div id="landing-page" class="landing-page">
        <div class="landing-logo logo-pulse"><span class="logo-circui">Circui</span><span class="logo-try">Try</span><span style="color:#00ff88">3D</span></div>
        <div class="landing-subtitle">Professional Circuit Design</div>
        
        <div class="circuit-preview">
            <svg class="circuit-svg" viewBox="0 0 320 140">
                <!-- Main circuit outline -->
                <path class="circuit-wire" d="M 60 70 L 100 70 L 100 40 L 160 40 L 160 70 L 200 70 L 200 100 L 160 100 L 160 70" />
                <path class="circuit-wire" d="M 160 70 L 160 100 L 100 100 L 100 70" />
                
                <!-- Battery -->
                <rect class="circuit-element" x="50" y="60" width="20" height="20" />
                <text class="circuit-voltage" x="45" y="55">12V</text>
                
                <!-- Resistor R1 -->
                <rect class="circuit-element" x="150" y="30" width="20" height="20" />
                <path class="circuit-element" d="M 155 35 L 165 45 L 155 45 L 165 35" />
                <text class="circuit-text" x="158" y="28">R1</text>
                
                <!-- Resistor R2 -->
                <rect class="circuit-element" x="190" y="60" width="20" height="20" />
                <path class="circuit-element" d="M 195 65 L 205 75 L 195 75 L 205 65" />
                <text class="circuit-text" x="198" y="58">R2</text>
                
                <!-- Resistor R3 -->
                <rect class="circuit-element" x="150" y="90" width="20" height="20" />
                <path class="circuit-element" d="M 155 95 L 165 105 L 155 105 L 165 95" />
                <text class="circuit-text" x="158" y="118">R3</text>
                
                <!-- Connection dots -->
                <circle class="circuit-element" cx="160" cy="70" r="2" fill="#00ff88" />
                <circle class="circuit-element" cx="100" cy="70" r="2" fill="#00ff88" />
            </svg>
        </div>
        
        <button class="launch-button" id="launch-btn" style="display:none">
            Launch CircuiTry
        </button>
        
        <div class="loading-progress" id="loading-progress" style="display: none;">
            <div class="loading-bar"></div>
        </div>
        
        <div class="loading-text" id="loading-text" style="display: none;">
            circuit environment initializing
        </div>
        
        <div class="version-text">Professional Edition v2.0</div>
    </div>

    <div id="loading" class="loading" style="display: none;">Loading CircuiTry...</div>
    
    <button class="menu-toggle" id="menu-toggle" onclick="toggleMenuBar()">?</button>
    
    <div class="menu-bar" id="menu-bar" style="display: none;">
        <div class="menu-tabs">
            <div class="menu-tab" onclick="toggleSubmenu('components')">
                ?? Components
                <div class="submenu" id="submenu-components">
                    <div class="submenu-grid">
                        <button class="btn" onclick="addComponent('battery')">?? Battery</button>
                        <button class="btn" onclick="addComponent('resistor')">? Resistor</button>
                        <button class="btn" onclick="addComponent('led')">?? LED</button>
                        <button class="btn" onclick="addComponent('switch')">?? Switch</button>
                    </div>
                </div>
            </div>
            
            <div class="menu-tab" onclick="toggleSubmenu('tools')">
                ??? Tools
                <div class="submenu" id="submenu-tools">
                    <div class="submenu-row">
                        <button class="btn wire-btn" id="wire-btn" onclick="toggleWireMode()">?? Wire</button>
                        <button class="btn rotate-btn" id="rotate-btn" onclick="toggleRotateMode()">?? Rotate</button>
                    </div>
                    <div class="submenu-row">
                        <button class="btn" onclick="addJunction()">? Junction</button>
                        <button class="btn" onclick="arrangeByLayoutMode()">?? Auto-Arrange</button>
                    </div>
                    <div class="submenu-row">
                        <button class="btn" onclick="cycleRoutingMode()">?? Route: <span id="route-mode">Free-form</span></button>
                        <button class="btn" onclick="centerCircuit()">?? Center Circuit</button>
                    </div>
                    <div class="submenu-row">
                        <button class="btn" onclick="clearAll()">??? Clear All</button>
                    </div>
                </div>
            </div>
            
            <div class="menu-tab" onclick="toggleSubmenu('edit')">
                ?? Edit
                <div class="submenu" id="submenu-edit">
                    <div class="submenu-row">
                        <button class="btn" onclick="undo()" id="undo-btn">? Undo</button>
                        <button class="btn" onclick="redo()" id="redo-btn">? Redo</button>
                    </div>
                    <div class="submenu-row">
                        <button class="btn" onclick="copySelected()">?? Copy</button>
                        <button class="btn" onclick="pasteSelected()">?? Paste</button>
                    </div>
                    <div class="submenu-row">
                        <button class="btn" onclick="selectAll()">?? Select All</button>
                        <button class="btn" onclick="deleteSelected()">??? Delete</button>
                    </div>
                </div>
            </div>
            
            <div class="menu-tab" onclick="toggleSubmenu('file')">
                ?? File
                <div class="submenu" id="submenu-file">
                    <div class="submenu-row">
                        <button class="btn" onclick="saveCircuit()">?? Save</button>
                        <button class="btn" onclick="loadCircuit()">?? Load</button>
                    </div>
                    <div class="submenu-row">
                        <button class="btn" onclick="exportImage()">??? Export</button>
                        <button class="btn" onclick="newCircuit()">?? New</button>
                    </div>
                </div>
            </div>
            
            <div class="menu-tab" onclick="toggleSubmenu('view')">
                ??? View
                <div class="submenu" id="submenu-view">
                    <div class="submenu-row">
                        <button class="btn" onclick="resetCamera()">?? Reset View</button>
                        <button class="btn" onclick="fitToScreen()">?? Fit Screen</button>
                    </div>
                    <div class="submenu-row">
                        <button class="btn" onclick="toggleGrid()">? Toggle Grid</button>
                        <button class="btn" onclick="toggleLabels()">??? Labels</button>
                    </div>
                    <div class="submenu-row">
                        <button class="btn" onclick="toggleCurrentFlowStyle()">?? Flow: <span id="flow-style">Electron Flow</span></button>
                        <button class="btn" onclick="togglePolarityIndicators()">? Polarity</button>
                    </div>
                    <div class="submenu-row">
                        <button class="btn" onclick="toggleBranding()">??? Branding</button>
                        <button class="btn" onclick="cycleLayoutMode()">?? Layout: <span id="layout-mode">Free</span></button>
                    </div>
                </div>
            </div>
            
            <div class="menu-tab" onclick="toggleSubmenu('practice')">
                ?? Practice
                <div class="submenu" id="submenu-practice">
                    <div class="submenu-row">
                        <button class="btn" onclick="loadPresetCircuit('series_basic')">?? Series Circuit</button>
                        <button class="btn" onclick="loadPresetCircuit('parallel_basic')">?? Parallel Circuit</button>
                    </div>
                    <div class="submenu-row">
                        <button class="btn" onclick="loadPresetCircuit('mixed_circuit')">?? Mixed Circuit</button>
                        <button class="btn" onclick="loadPresetCircuit('switch_control')">?? Switch Control</button>
                    </div>
                    <div class="submenu-row">
                        <button class="btn" onclick="generateRandomProblem()">?? Random Problem</button>
                        <button class="btn" onclick="showPracticeModeHelp()">? How to Use</button>
                    </div>
                </div>
            </div>

            <div class="menu-tab" onclick="toggleSubmenu('arena')">
                ?? Arena
                <div class="submenu" id="submenu-arena">
                    <div class="submenu-row">
                        <button class="btn" onclick="openArena()">Open Component Arena</button>
                    </div>
                </div>
            </div>
            
            <div class="menu-tab" onclick="toggleSubmenu('help')">
                ? Help
                <div class="submenu" id="submenu-help">
                    <div class="submenu-row">
                        <button class="btn" onclick="showTutorial()">?? Tutorial</button>
                        <button class="btn" onclick="showWireGuide()">?? W.I.R.E. Guide</button>
                    </div>
                    <div class="submenu-row">
                        <button class="btn" onclick="showShortcuts()">?? Shortcuts</button>
                        <button class="btn" onclick="showAbout()">?? About</button>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <div class="wire-analysis-fixed" id="wire-analysis">
        <button class="analysis-toggle" onclick="toggleAnalysis()">??</button>
        
        <div class="analysis-tabs">
            <button class="analysis-tab active" onclick="switchAnalysisTab('wire')" id="tab-wire">W.I.R.E.</button>
            <button class="analysis-tab" onclick="switchAnalysisTab('eir')" id="tab-eir">EIR ?</button>
            <button class="analysis-tab" onclick="switchAnalysisTab('power')" id="tab-power">Power ?</button>
            <button class="analysis-tab" onclick="switchAnalysisTab('worksheet')" id="tab-worksheet">Sheet</button>
            <button class="analysis-tab" onclick="switchAnalysisTab('problem')" id="tab-problem">Solve</button>
            <button class="analysis-tab" onclick="switchAnalysisTab('practice')" id="tab-practice">Practice</button>
        </div>

        <!-- W.I.R.E. Method Panel -->
        <div class="analysis-content" id="content-wire">
            <div class="wire-analysis">
                <div class="wire-title">?? W.I.R.E. METHOD</div>
                <div class="wire-grid">
                    <div class="wire-item wire-w">
                        <div class="wire-letter">W</div>
                        <div class="wire-label">Watts (Power)</div>
                        <div class="wire-value" id="power">0W</div>
                    </div>
                    <div class="wire-item wire-i">
                        <div class="wire-letter">I</div>
                        <div class="wire-label">Current (Amps)</div>
                        <div class="wire-value" id="current">0A</div>
                    </div>
                    <div class="wire-item wire-r">
                        <div class="wire-letter">R</div>
                        <div class="wire-label">Resistance (Ohms)</div>
                        <div class="wire-value" id="resistance">??</div>
                    </div>
                    <div class="wire-item wire-e">
                        <div class="wire-letter">E</div>
                        <div class="wire-label">Voltage (EMF)</div>
                        <div class="wire-value" id="voltage">0V</div>
                    </div>
                </div>
                <div style="font-size: 12px; color: #888; margin-top: 12px; text-align: center;">
                    <strong>?? Circuit Status:</strong><br>
                    Components: <span id="count" style="color: #00ff88;">0</span> | 
                    Wires: <span id="wire-count" style="color: #ffaa88;">0</span> | 
                    Junctions: <span id="junction-count" style="color: #aa88ff;">0</span>
                    <br>
                    <strong>?? Topology:</strong> <span id="topology-type" style="color: #88ccff;">Unknown</span>
                </div>
            </div>
        </div>

        <!-- EIR Triangle Panel (EMF, Current, Resistance) -->
        <div class="analysis-content" id="content-eir" style="display: none;">
            <div class="vir-triangle">
                <div class="triangle-container">
                    <div class="triangle-shape"></div>
                    <div class="triangle-sections">
                        <div class="triangle-v" onclick="explainOhmsLaw('E')">E</div>
                        <div class="triangle-i" onclick="explainOhmsLaw('I')">I</div>
                        <div class="triangle-r" onclick="explainOhmsLaw('R')">R</div>
                    </div>
                </div>
                <div class="triangle-formula" id="eir-formula">
                    E = I ? R | I = E ? R | R = E ? I
                </div>
                <div style="color: #ccc; font-size: 12px; margin-top: 12px; text-align: center;">
                    Click E, I, or R to see the formula<br>
                    <strong>E</strong> = EMF/Voltage | <strong>I</strong> = Current | <strong>R</strong> = Resistance
                </div>
            </div>
            
            <div class="circuit-diagram">
                <div class="diagram-title">Circuit Schematic</div>
                <div class="circuit-schematic" id="circuit-schematic">
                    <div class="schematic-line">     +?????[R?]?????+</div>
                    <div class="schematic-line">     ?              ?</div>
                    <div class="schematic-line">   [BAT]          [R?]</div>
                    <div class="schematic-line">     ?              ?</div>
                    <div class="schematic-line">     +??????????????+</div>
                </div>
            </div>
        </div>

        <!-- Power Triangle Panel (Watts, Current, EMF) -->
        <div class="analysis-content" id="content-power" style="display: none;">
            <div class="vir-triangle">
                <div class="triangle-container">
                    <div class="triangle-shape" style="border-bottom-color: rgba(68,136,255,0.3);"></div>
                    <div class="triangle-sections">
                        <div class="triangle-v" onclick="explainPowerLaw('W')" style="color: #4488ff;">W</div>
                        <div class="triangle-i" onclick="explainPowerLaw('I')" style="color: #ff8844;">I</div>
                        <div class="triangle-r" onclick="explainPowerLaw('E')" style="color: #ff4444;">E</div>
                    </div>
                </div>
                <div class="triangle-formula" id="power-formula" style="color: #4488ff;">
                    W = I ? E | I = W ? E | E = W ? I
                </div>
                <div style="color: #ccc; font-size: 12px; margin-top: 12px; text-align: center;">
                    Click W, I, or E to see the power formula<br>
                    <strong>W</strong> = Watts/Power | <strong>I</strong> = Current | <strong>E</strong> = EMF/Voltage
                </div>
                
                <div style="background: rgba(68,136,255,0.1); padding: 12px; border-radius: 8px; margin-top: 12px; border: 1px solid rgba(68,136,255,0.3);">
                    <div style="color: #4488ff; font-weight: bold; text-align: center; margin-bottom: 8px;">
                        ?? Additional Power Formulas
                    </div>
                    <div style="color: #ccc; font-size: 11px; text-align: center; line-height: 1.4;">
                        W = I? ? R (Power = Current? ? Resistance)<br>
                        W = E? ? R (Power = Voltage? ? Resistance)
                    </div>
                </div>
            </div>
        </div>

        <!-- Worksheet Panel -->
        <div class="analysis-content" id="content-worksheet" style="display: none;">
            <div class="worksheet-panel">
                <div class="worksheet-title">Circuit Analysis Worksheet</div>
                
                <div class="component-list" id="component-list">
                    <!-- Components will be populated here -->
                </div>

                <div class="calculations-section">
                    <div class="calculation-step step-resistance">
                        <div>
                            <div class="step-label">Total Resistance</div>
                            <div class="step-formula" id="resistance-formula">R_total = R? + R? + R?...</div>
                        </div>
                        <div class="step-value" id="calc-resistance">??</div>
                    </div>
                    
                    <div class="calculation-step step-current">
                        <div>
                            <div class="step-label">Total Current</div>
                            <div class="step-formula" id="current-formula">I = V ? R_total</div>
                        </div>
                        <div class="step-value" id="calc-current">0A</div>
                    </div>
                    
                    <div class="calculation-step step-voltage">
                        <div>
                            <div class="step-label">Source Voltage</div>
                            <div class="step-formula" id="voltage-formula">V = V_bat1 + V_bat2...</div>
                        </div>
                        <div class="step-value" id="calc-voltage">0V</div>
                    </div>
                    
                    <div class="calculation-step step-power">
                        <div>
                            <div class="step-label">Total Power</div>
                            <div class="step-formula" id="power-formula">P = V ? I</div>
                        </div>
                        <div class="step-value" id="calc-power">0W</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Problem Solving Panel -->
        <div class="analysis-content" id="content-problem" style="display: none;">
            <div class="problem-mode">
                <div class="problem-title">?? Solve for the Unknown</div>
                <div style="color: #ccc; margin-bottom: 16px; text-align: center;">
                    Enter your calculated values below:
                </div>
                
                <div class="unknown-input">
                    <label style="color: #ff4444; width: 120px;">Total Voltage:</label>
                    <input type="number" id="student-voltage" step="0.1" placeholder="V">
                    <span style="color: #ff4444;">V</span>
                </div>
                
                <div class="unknown-input">
                    <label style="color: #ff8844; width: 120px;">Total Current:</label>
                    <input type="number" id="student-current" step="0.001" placeholder="A">
                    <span style="color: #ff8844;">A</span>
                </div>
                
                <div class="unknown-input">
                    <label style="color: #44ff88; width: 120px;">Total Resistance:</label>
                    <input type="number" id="student-resistance" step="0.1" placeholder="?">
                    <span style="color: #44ff88;">?</span>
                </div>
                
                <div class="unknown-input">
                    <label style="color: #4488ff; width: 120px;">Total Power:</label>
                    <input type="number" id="student-power" step="0.01" placeholder="W">
                    <span style="color: #4488ff;">W</span>
                </div>
                
                <div style="text-align: center; margin-top: 16px;">
                    <button class="check-answer-btn" onclick="checkStudentAnswers()">
                        ? Check My Answers
                    </button>
                </div>
                
                <div id="answer-feedback"></div>
            </div>
        </div>

        <!-- Practice Mode Panel -->
        <div class="analysis-content" id="content-practice" style="display: none;">
            <div class="practice-problem-card" id="practice-problem-card" style="display: none;">
                <div class="problem-question" id="practice-question">
                    ?? Problem: Find the total resistance
                </div>
                <div class="problem-description" id="practice-description">
                    Calculate the total resistance of this series circuit
                </div>
                
                <div style="display: flex; justify-content: space-between; align-items: center; margin: 12px 0;">
                    <div style="color: #4da6ff; font-size: 12px; font-weight: bold;">
                        Problem <span id="problem-counter">1</span> of <span id="total-problems">4</span>
                    </div>
                    <div style="display: flex; gap: 8px;">
                        <button class="practice-btn" onclick="previousProblem()" id="prev-btn" style="padding: 6px 12px; font-size: 11px;">? Prev</button>
                        <button class="practice-btn" onclick="nextProblem()" id="next-btn" style="padding: 6px 12px; font-size: 11px;">Next ?</button>
                    </div>
                </div>
                
                <div class="circuit-status" id="circuit-status">
                    <div id="circuit-status-text">?? Circuit incomplete - Add wires to connect components</div>
                </div>
                
                <div class="wire-instructions" id="wire-instructions">
                    ?? <strong>How to wire:</strong> 1) Click ??? Tools ? ?? Wire Mode  2) Touch red/white terminals to connect  3) Switch to Solve tab when complete
                </div>
                
                <div id="practice-objectives" style="margin-top: 12px;">
                    <div style="color: #4da6ff; font-weight: bold; margin-bottom: 8px; font-size: 14px;">?? Learning Objectives:</div>
                    <ul id="objectives-list" style="color: #ccc; margin-left: 20px; line-height: 1.5; font-size: 12px;">
                        <!-- Objectives will be populated here -->
                    </ul>
                </div>
            </div>
            
            <div class="worksheet-panel">
                <div class="worksheet-title">?? Practice Circuit Problems</div>
                
                <div style="text-align: center; margin-bottom: 16px;">
                    <button class="practice-btn" onclick="startPracticeSequence()" style="background: linear-gradient(135deg, #00ff88, #00cc66); color: #000; padding: 12px 24px; font-size: 14px; font-weight: bold;">
                        ?? Start Practice Sequence
                    </button>
                </div>
                
                <div class="practice-buttons">
                    <button class="practice-btn" onclick="loadPresetCircuit('series_basic')" id="btn-series">?? Basic Series</button>
                    <button class="practice-btn" onclick="loadPresetCircuit('parallel_basic')" id="btn-parallel">?? Basic Parallel</button>
                    <button class="practice-btn" onclick="loadPresetCircuit('mixed_circuit')" id="btn-mixed">?? Mixed Circuit</button>
                    <button class="practice-btn" onclick="loadPresetCircuit('combination_advanced')" id="btn-combination">?? Advanced Combo</button>
                    <button class="practice-btn" onclick="generateRandomProblem()" id="btn-random">?? Random</button>
                </div>
                
                <div id="practice-help-text" style="background: rgba(255,255,255,0.1); padding: 16px; border-radius: 8px; color: #ccc; text-align: center; font-size: 12px;">
                    <strong>?? Choose your practice method:</strong><br>
                    ? <strong>Practice Sequence</strong> - Work through problems in order<br>
                    ? <strong>Individual Problems</strong> - Jump to any specific circuit<br>
                    ? <strong>Random</strong> - Get randomized component values<br><br>
                    <small>All problems require manual wiring and calculations!</small>
                </div>
            </div>
        </div>
    </div>
    
    <div class="status" id="status" style="display: none;">W.I.R.E. Circuit Builder Ready!</div>
    
    <div class="edit-popup" id="edit-popup">
        <h3 id="edit-title">Edit Component</h3>
        <div id="edit-content">
            <!-- Dynamic content will be inserted here -->
        </div>
        <div class="edit-buttons">
            <button class="edit-btn save" onclick="saveEdit()">?? Save</button>
            <button class="edit-btn cancel" onclick="cancelEdit()">? Cancel</button>
        </div>
    </div>
    
    <canvas id="canvas" style="display: none;"></canvas>
    
    <!-- Branding Overlay -->
    <div class="branding-overlay" id="branding-overlay">
        <span class="logo-circui">Circui</span><span class="logo-try">Try</span><span class="logo-3d">3D</span>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        const urlParams = new URLSearchParams(window.location.search);
        let isEmbedded = false;
        try {
            isEmbedded = urlParams.has("embed") || window.self !== window.top;
        } catch (error) {
            isEmbedded = urlParams.has("embed");
        }

        if (isEmbedded) {
            document.documentElement.classList.add("embedded");
            window.addEventListener("DOMContentLoaded", () => {
                const body = document.body;
                if (body) {
                    body.classList.add("embedded");
                }
                const hiddenIds = [
                    "menu-bar",
                    "menu-toggle",
                    "wire-analysis",
                    "status",
                    "branding-overlay",
                    "landing-page",
                    "launch-btn",
                    "loading",
                    "loading-progress",
                    "loading-text"
                ];
                hiddenIds.forEach((id) => {
                    const element = document.getElementById(id);
                    if (element) {
                        element.style.display = "none";
                    }
                });
            });
        }

        // Global variables
        let scene, camera, renderer, raycaster, mouse;
        let components = [], wires = [], junctions = [];
        let isWireMode = false, isRotateMode = false, wireStart = null;
        let isDragging = false, selectedComponent = null;
        let currentFlowParticles = [];
        let menuVisible = true, analysisVisible = true;

        function notifyParentReady() {
            if (window.parent && window.parent !== window) {
                try {
                    window.parent.postMessage({ type: 'legacy:ready' }, '*');
                } catch (error) {
                    console.warn('Legacy builder: unable to notify parent window', error);
                }
            }
        }

        function notifyParentAnalysisState() {
            if (window.parent && window.parent !== window) {
                try {
                    window.parent.postMessage({ type: 'legacy:analysis-state', payload: { open: analysisVisible } }, '*');
                } catch (error) {
                    console.warn('Legacy builder: unable to share analysis state', error);
                }
            }
        }

        function handleBuilderBridgeMessage(event) {
            const expectedSource = window.parent && window.parent !== window ? window.parent : null;
            if (expectedSource && event.source !== expectedSource) {
                return;
            }

            const data = event.data;
            if (!data || typeof data !== 'object') {
                return;
            }

            const { type, payload } = data;

            switch (type) {
                case 'builder:add-component': {
                    const componentType = payload?.componentType;
                    if (typeof componentType === 'string' && typeof addComponent === 'function') {
                        addComponent(componentType);
                    }
                    break;
                }
                case 'builder:add-junction': {
                    if (typeof addJunction === 'function') {
                        addJunction();
                    }
                    break;
                }
                case 'builder:set-analysis-open': {
                    if (!payload || typeof payload !== 'object' || !('open' in payload)) {
                        break;
                    }

                    const desired = Boolean(payload.open);
                    const panel = document.getElementById('wire-analysis');
                    const isCollapsed = panel?.classList.contains('collapsed');

                    if (panel) {
                        if (desired && isCollapsed) {
                            panel.classList.remove('collapsed');
                            analysisVisible = true;
                        } else if (!desired && !isCollapsed) {
                            panel.classList.add('collapsed');
                            analysisVisible = false;
                        } else {
                            analysisVisible = !panel.classList.contains('collapsed');
                        }
                    } else {
                        analysisVisible = desired;
                    }

                    notifyParentAnalysisState();
                    break;
                }
                default:
                    break;
            }
        }

        if (window.parent && window.parent !== window) {
            window.addEventListener('message', handleBuilderBridgeMessage);
        }
        let undoStack = [], redoStack = [];
        let clipboard = null;
        let selectedComponents = new Set();
        let showGrid = true, showLabels = true;
        let currentAnalysisTab = 'wire';
        let lastKnownValues = { voltage: 0, current: 0, resistance: Infinity, power: 0 };
        let currentPracticeCircuit = null;
        let currentProblemIndex = 0;
        let practiceProblems = ['series_basic', 'parallel_basic', 'mixed_circuit', 'combination_advanced', 'switch_control'];
        
        // New features variables
        let currentFlowStyle = 'misty'; // 'misty' (electron cloud) or 'solid' (conventional)
        let layoutMode = 'free'; // 'free', 'square', 'linear'
        let showPolarityIndicators = true;
        
        let practiceQuestions = {
            series_basic: {
                question: "Find the total resistance and current",
                expectedAnswer: "resistance", // What we're testing for
                description: "Calculate R_total = R? + R?, then find I = E ? R_total"
            },
            parallel_basic: {
                question: "Find the total resistance (parallel)",
                expectedAnswer: "resistance",
                description: "Use 1/R_total = 1/R? + 1/R?, then find the equivalent resistance"
            },
            mixed_circuit: {
                question: "Analyze the complex circuit",
                expectedAnswer: "current",
                description: "Break down into series and parallel sections, find total resistance and current"
            },
            switch_control: {
                question: "Determine circuit behavior with switch",
                expectedAnswer: "power",
                description: "Compare power consumption when switch is ON vs OFF"
            }
        };
        
        // Long press and edit variables
        let longPressTimer = null;
        let longPressStartPos = { x: 0, y: 0 };
        let isLongPressing = false;
        let currentEditComponent = null;
        const LONG_PRESS_DURATION = 600; // Shorter for mobile
        
        // Grid and snapping variables
        const GRID_SIZE = 2; // Grid spacing
        let gridHelper = null;
        let snapIndicator = null;
        
        // W.I.R.E. Color coding
        const WIRE_COLORS = {
            W: '#4488ff', // Power (Watts) - Blue
            I: '#ff8844', // Current (Amps) - Orange  
            R: '#44ff88', // Resistance (Ohms) - Green
            E: '#ff4444'  // Voltage (Volts) - Red
        };
        
        // Component counters for labeling
        let componentCounters = {
            battery: 0,
            resistor: 0,
            led: 0,
            switch: 0
        };
        
        // Camera controls
        let cameraDistance = 15;
        let cameraAngleX = 0, cameraAngleY = 0.5;
        let cameraTarget = new THREE.Vector3(0, 0, 0);
        let isRotating = false, isPanning = false;
        let lastTouchPos = { x: 0, y: 0 };
        let lastTwoFingerCenter = { x: 0, y: 0 };
        let lastPinchDistance = 0;

        // Mobile detection
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        const isAndroid = /Android/i.test(navigator.userAgent);

        // Adjust settings for mobile
        if (isMobile) {
            // Reduce particle count for better performance
            const originalParticleCount = 8;
            // Increase touch sensitivity
            const TOUCH_SENSITIVITY = 0.8;
            // Reduce quality for better performance
            const MOBILE_QUALITY_FACTOR = 0.7;
        }

        // Junction class
        class Junction {
            constructor(position) {
                this.position = snapToGrid(position);
                this.connections = [];
                this.id = 'junction_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                this.createMesh();
            }

            createMesh() {
                const group = new THREE.Group();
                
                // Main purple sphere
                const bodyGeometry = new THREE.SphereGeometry(0.25, isMobile ? 12 : 16, isMobile ? 8 : 12);
                const bodyMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0x8844ff,
                    emissive: 0x221188,
                    shininess: 100
                });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                group.add(body);
                
                // Selection sphere
                const selectionGeometry = new THREE.SphereGeometry(isMobile ? 1.2 : 0.8, 8, 6);
                const selectionMaterial = new THREE.MeshBasicMaterial({ 
                    transparent: true,
                    opacity: 0.0
                });
                const selectionSphere = new THREE.Mesh(selectionGeometry, selectionMaterial);
                selectionSphere.userData = { junction: this, isSelectionBox: true };
                group.add(selectionSphere);
                
                group.position.copy(this.position);
                group.userData = { junction: this };
                
                this.mesh = group;
                this.selectionSphere = selectionSphere;
                scene.add(group);
                
                this.createConnectionPoint();
            }

            createConnectionPoint() {
                const pointGeometry = new THREE.SphereGeometry(0.28, isMobile ? 12 : 16, isMobile ? 8 : 12);
                const pointMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0xaa66ff,
                    emissive: 0x332288,
                    shininess: 200
                });
                
                const connectionPoint = new THREE.Mesh(pointGeometry, pointMaterial);
                connectionPoint.position.set(0, 0, 0);
                connectionPoint.userData = { 
                    junction: this, 
                    isConnectionPoint: true, 
                    side: 'center',
                    polarity: 'neutral'
                };
                
                this.mesh.add(connectionPoint);
                this.connectionPoint = connectionPoint;
            }

            getWorldConnectionPoint() {
                if (this.connectionPoint) {
                    const worldPosition = new THREE.Vector3();
                    this.connectionPoint.getWorldPosition(worldPosition);
                    return snapToGrid(worldPosition);
                }
                return snapToGrid(this.position.clone());
            }

            addConnection(wire) {
                this.connections.push(wire);
            }

            removeConnection(wire) {
                const index = this.connections.indexOf(wire);
                if (index > -1) {
                    this.connections.splice(index, 1);
                }
            }

            remove() {
                if (this.mesh) {
                    scene.remove(this.mesh);
                }
                const connectedWires = [...this.connections];
                connectedWires.forEach(wire => wire.remove());
                const index = junctions.indexOf(this);
                if (index > -1) {
                    junctions.splice(index, 1);
                }
            }
        }

        // Helper function to convert 3D world position to 2D screen coordinates
        function worldToScreen(worldPosition) {
            const vector = worldPosition.clone();
            vector.project(camera);
            
            const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
            const y = (-vector.y * 0.5 + 0.5) * window.innerHeight;
            
            return { x, y, z: vector.z };
        }

        // Component class
        class Component {
            constructor(type, position) {
                this.type = type;
                this.position = snapToGrid(position);
                this.rotation = 0;
                this.connections = [];
                this.properties = this.getDefaultProperties(type);
                
                // Assign component number
                componentCounters[type]++;
                this.componentNumber = componentCounters[type];
                this.id = type + '_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                
                this.createMesh();
                this.createConnectionPoints();
                this.createComponentLabels();
            }

            getDefaultProperties(type) {
                switch(type) {
                    case 'battery': return { voltage: 9 };
                    case 'resistor': return { resistance: 100 };
                    case 'led': return { resistance: 10 };
                    case 'switch': return { resistance: 0.1, isOn: true };
                    default: return {};
                }
            }

            createComponentLabels() {
                // Create DOM labels that will float above components
                this.labelDiv = document.createElement('div');
                this.labelDiv.className = 'component-label';
                this.labelDiv.style.fontSize = isMobile ? '16px' : '14px';
                this.labelDiv.style.fontWeight = 'bold';
                this.labelDiv.style.textAlign = 'center';
                this.labelDiv.style.lineHeight = '1.2';
                
                // Component identifier
                const identifier = this.getComponentIdentifier();
                
                // Component value with color coding
                const { text, color } = this.getValueTextAndColor();
                
                this.labelDiv.innerHTML = `
                    <div style="color: white; font-size: ${isMobile ? '14px' : '12px'};">${identifier}</div>
                    <div style="color: ${color}; font-size: ${isMobile ? '13px' : '11px'}; font-weight: bold;">${text}</div>
                `;
                
                document.body.appendChild(this.labelDiv);
                this.updateLabelPosition();
            }

            getComponentIdentifier() {
                switch(this.type) {
                    case 'battery': return `B${this.componentNumber}`;
                    case 'resistor': return `R${this.componentNumber}`;
                    case 'led': return `LED${this.componentNumber}`;
                    case 'switch': return `SW${this.componentNumber}`;
                    default: return `C${this.componentNumber}`;
                }
            }

            getValueTextAndColor() {
                switch(this.type) {
                    case 'battery':
                        return {
                            text: `${this.properties.voltage}V`,
                            color: WIRE_COLORS.E // Voltage - Red
                        };
                    case 'resistor':
                        return {
                            text: `${this.properties.resistance}?`,
                            color: WIRE_COLORS.R // Resistance - Green
                        };
                    case 'led':
                        return {
                            text: `${this.properties.resistance}?`,
                            color: WIRE_COLORS.R // Resistance - Green
                        };
                    case 'switch':
                        const state = this.properties.isOn ? 'ON' : 'OFF';
                        return {
                            text: state,
                            color: this.properties.isOn ? '#44ff44' : '#ff4444'
                        };
                    default:
                        return { text: '', color: '#ffffff' };
                }
            }

            updateLabelPosition() {
                if (!this.labelDiv || !this.mesh) return;
                
                const worldPos = new THREE.Vector3();
                worldPos.setFromMatrixPosition(this.mesh.matrixWorld);
                worldPos.y += 3; // Position above component
                
                const screenPos = worldToScreen(worldPos);
                
                this.labelDiv.style.left = (screenPos.x - (isMobile ? 40 : 30)) + 'px';
                this.labelDiv.style.top = (screenPos.y - (isMobile ? 40 : 30)) + 'px';
                
                // Hide label if component is behind camera
                this.labelDiv.style.display = screenPos.z > 1 ? 'none' : (showLabels ? 'block' : 'none');
            }

            updateLabels() {
                if (!this.labelDiv) return;
                
                const identifier = this.getComponentIdentifier();
                const { text, color } = this.getValueTextAndColor();
                
                this.labelDiv.innerHTML = `
                    <div style="color: white; font-size: ${isMobile ? '14px' : '12px'};">${identifier}</div>
                    <div style="color: ${color}; font-size: ${isMobile ? '13px' : '11px'}; font-weight: bold;">${text}</div>
                `;
                
                this.updateLabelPosition();
            }

            createMesh() {
                const group = new THREE.Group();
                
                switch(this.type) {
                    case 'battery':
                        this.createBatteryMesh(group);
                        break;
                    case 'resistor':
                        this.createResistorMesh(group);
                        break;
                    case 'led':
                        this.createLEDMesh(group);
                        break;
                    case 'switch':
                        this.createSwitchMesh(group);
                        break;
                }
                
                group.position.copy(this.position);
                group.userData = { component: this };
                
                this.createSelectionBox(group);
                this.mesh = group;
                scene.add(group);
            }

            createSelectionBox(group) {
                const selectionGeometry = new THREE.BoxGeometry(
                    isMobile ? 3.5 : 2.5, 
                    isMobile ? 2.0 : 1.5, 
                    isMobile ? 2.0 : 1.5
                );
                const selectionMaterial = new THREE.MeshBasicMaterial({ 
                    transparent: true,
                    opacity: 0.0
                });
                
                const selectionBox = new THREE.Mesh(selectionGeometry, selectionMaterial);
                selectionBox.userData = { component: this, isSelectionBox: true };
                
                group.add(selectionBox);
                this.selectionBox = selectionBox;
            }

            createBatteryMesh(group) {
                // Battery body
                const segments = isMobile ? 6 : 8;
                const bodyGeometry = new THREE.CylinderGeometry(0.3, 0.3, 1.2, segments);
                const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0x1a1a1a });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.rotation.z = Math.PI / 2;
                group.add(body);

                // Positive terminal
                const posGeometry = new THREE.CylinderGeometry(0.2, 0.2, 0.3, segments);
                const posMaterial = new THREE.MeshPhongMaterial({ color: 0xb87333 });
                const pos = new THREE.Mesh(posGeometry, posMaterial);
                pos.rotation.z = Math.PI / 2;
                pos.position.x = 0.75;
                group.add(pos);

                // Negative terminal
                const negGeometry = new THREE.CylinderGeometry(0.3, 0.3, 0.15, segments);
                const negMaterial = new THREE.MeshLambertMaterial({ color: 0x2a2a2a });
                const neg = new THREE.Mesh(negGeometry, negMaterial);
                neg.rotation.z = Math.PI / 2;
                neg.position.x = -0.7;
                group.add(neg);

                // Labels
                this.addText(group, '+', new THREE.Vector3(1.0, 0.4, 0), 0xff0000);
                this.addText(group, '-', new THREE.Vector3(-1.0, 0.4, 0), 0x000000);
            }

            createResistorMesh(group) {
                const segments = isMobile ? 6 : 8;
                // Resistor body
                const bodyGeometry = new THREE.CylinderGeometry(0.15, 0.15, 1, segments);
                const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0xccaa66 });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.rotation.z = Math.PI / 2;
                group.add(body);

                // Color bands
                for(let i = 0; i < 4; i++) {
                    const bandGeometry = new THREE.CylinderGeometry(0.16, 0.16, 0.1, segments);
                    const colors = [0xff0000, 0x00ff00, 0x0000ff, 0xffd700];
                    const bandMaterial = new THREE.MeshLambertMaterial({ color: colors[i] });
                    const band = new THREE.Mesh(bandGeometry, bandMaterial);
                    band.rotation.z = Math.PI / 2;
                    band.position.x = -0.3 + i * 0.2;
                    group.add(band);
                }

                this.addLeads(group);
            }

            createLEDMesh(group) {
                const segments = isMobile ? 6 : 8;
                // LED dome
                const domeGeometry = new THREE.SphereGeometry(0.25, segments, segments/2, 0, Math.PI * 2, 0, Math.PI / 2);
                const domeMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0xff4444, 
                    transparent: true, 
                    opacity: 0.8 
                });
                const dome = new THREE.Mesh(domeGeometry, domeMaterial);
                dome.position.y = 0.1;
                group.add(dome);

                // LED base
                const baseGeometry = new THREE.CylinderGeometry(0.25, 0.25, 0.2, segments);
                const baseMaterial = new THREE.MeshLambertMaterial({ color: 0x333333 });
                const base = new THREE.Mesh(baseGeometry, baseMaterial);
                base.position.y = -0.1;
                group.add(base);

                this.addLeads(group);
            }

            createSwitchMesh(group) {
                // Switch base
                const baseGeometry = new THREE.BoxGeometry(0.8, 0.2, 0.4);
                const baseMaterial = new THREE.MeshLambertMaterial({ color: 0x666666 });
                const base = new THREE.Mesh(baseGeometry, baseMaterial);
                group.add(base);

                // Switch lever
                const leverGeometry = new THREE.BoxGeometry(0.1, 0.4, 0.1);
                const leverMaterial = new THREE.MeshLambertMaterial({ 
                    color: this.properties.isOn ? 0x00ff00 : 0xff0000 
                });
                const lever = new THREE.Mesh(leverGeometry, leverMaterial);
                lever.position.y = 0.3;
                lever.rotation.z = this.properties.isOn ? 0 : Math.PI / 6;
                group.add(lever);
                this.leverMesh = lever;

                this.addLeads(group);
            }

            addLeads(group) {
                const segments = isMobile ? 4 : 6;
                const leadGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.8, segments);
                const leadMaterial = new THREE.MeshLambertMaterial({ color: 0x888888 });
                
                const leftLead = new THREE.Mesh(leadGeometry, leadMaterial);
                leftLead.rotation.z = Math.PI / 2;
                leftLead.position.x = -0.6;
                group.add(leftLead);

                const rightLead = new THREE.Mesh(leadGeometry, leadMaterial);
                rightLead.rotation.z = Math.PI / 2;
                rightLead.position.x = 0.6;
                group.add(rightLead);
            }

            addText(group, text, position, color) {
                if (text === '+') {
                    const hBarGeometry = new THREE.BoxGeometry(0.2, 0.04, 0.04);
                    const hBarMaterial = new THREE.MeshLambertMaterial({ color: color });
                    const hBar = new THREE.Mesh(hBarGeometry, hBarMaterial);
                    hBar.position.copy(position);
                    group.add(hBar);
                    
                    const vBarGeometry = new THREE.BoxGeometry(0.04, 0.2, 0.04);
                    const vBar = new THREE.Mesh(vBarGeometry, hBarMaterial);
                    vBar.position.copy(position);
                    group.add(vBar);
                } else if (text === '-') {
                    const barGeometry = new THREE.BoxGeometry(0.2, 0.04, 0.04);
                    const barMaterial = new THREE.MeshLambertMaterial({ color: color });
                    const bar = new THREE.Mesh(barGeometry, barMaterial);
                    bar.position.copy(position);
                    group.add(bar);
                }
            }

            createConnectionPoints() {
                this.connectionPoints = [];
                
                const pointGeometry = new THREE.SphereGeometry(0.3, isMobile ? 16 : 20, isMobile ? 12 : 16);
                const leftPos = new THREE.Vector3(-1.2, 0, 0);
                const rightPos = new THREE.Vector3(1.2, 0, 0);
                
                if (this.type === 'battery') {
                    // Red positive terminal
                    const positiveMaterial = new THREE.MeshPhongMaterial({ 
                        color: 0xff0000,
                        emissive: 0x330000,
                        shininess: 200
                    });
                    const positivePoint = new THREE.Mesh(pointGeometry, positiveMaterial);
                    positivePoint.position.copy(rightPos);
                    positivePoint.userData = { 
                        component: this, 
                        isConnectionPoint: true, 
                        side: 'positive', 
                        polarity: 'positive'
                    };
                    this.mesh.add(positivePoint);
                    this.connectionPoints.push(positivePoint);

                    // Gray negative terminal
                    const negativeMaterial = new THREE.MeshPhongMaterial({ 
                        color: 0x333333,
                        emissive: 0x111111,
                        shininess: 200
                    });
                    const negativePoint = new THREE.Mesh(pointGeometry, negativeMaterial);
                    negativePoint.position.copy(leftPos);
                    negativePoint.userData = { 
                        component: this, 
                        isConnectionPoint: true, 
                        side: 'negative', 
                        polarity: 'negative'
                    };
                    this.mesh.add(negativePoint);
                    this.connectionPoints.push(negativePoint);
                    
                } else {
                    // White neutral terminals
                    const neutralMaterial = new THREE.MeshPhongMaterial({ 
                        color: 0xffffff,
                        emissive: 0x222222,
                        shininess: 200
                    });

                    const leftPoint = new THREE.Mesh(pointGeometry, neutralMaterial.clone());
                    leftPoint.position.copy(leftPos);
                    leftPoint.userData = { 
                        component: this, 
                        isConnectionPoint: true, 
                        side: 'left', 
                        polarity: 'neutral'
                    };
                    this.mesh.add(leftPoint);
                    this.connectionPoints.push(leftPoint);

                    const rightPoint = new THREE.Mesh(pointGeometry, neutralMaterial.clone());
                    rightPoint.position.copy(rightPos);
                    rightPoint.userData = { 
                        component: this, 
                        isConnectionPoint: true, 
                        side: 'right', 
                        polarity: 'neutral'
                    };
                    this.mesh.add(rightPoint);
                    this.connectionPoints.push(rightPoint);
                }
                
                // Create polarity indicator labels
                this.createPolarityIndicators();
            }
            
            createPolarityIndicators() {
                this.polarityDivs = [];
                
                if (this.type === 'battery') {
                    // Create + indicator for positive terminal
                    const positiveDiv = document.createElement('div');
                    positiveDiv.className = 'polarity-indicator polarity-positive';
                    positiveDiv.textContent = '+';
                    positiveDiv.style.display = showPolarityIndicators ? 'block' : 'none';
                    document.body.appendChild(positiveDiv);
                    this.polarityDivs.push({ div: positiveDiv, side: 'positive' });
                    
                    // Create - indicator for negative terminal
                    const negativeDiv = document.createElement('div');
                    negativeDiv.className = 'polarity-indicator polarity-negative';
                    negativeDiv.textContent = '?';
                    negativeDiv.style.display = showPolarityIndicators ? 'block' : 'none';
                    document.body.appendChild(negativeDiv);
                    this.polarityDivs.push({ div: negativeDiv, side: 'negative' });
                }
            }
            
            updatePolarityDisplay(show) {
                if (this.polarityDivs) {
                    this.polarityDivs.forEach(item => {
                        item.div.style.display = show ? 'block' : 'none';
                    });
                }
            }
            
            updatePolarityPositions() {
                // Skip expensive calculations if indicators are hidden
                if (!showPolarityIndicators || !this.polarityDivs || !this.mesh) return;
                
                this.polarityDivs.forEach(item => {
                    const worldPos = new THREE.Vector3();
                    worldPos.setFromMatrixPosition(this.mesh.matrixWorld);
                    
                    // Offset based on side
                    if (item.side === 'positive') {
                        worldPos.x += 1.2;
                    } else if (item.side === 'negative') {
                        worldPos.x -= 1.2;
                    }
                    worldPos.y += 0.8; // Above the terminal
                    
                    const screenPos = worldToScreen(worldPos);
                    
                    item.div.style.left = screenPos.x + 'px';
                    item.div.style.top = screenPos.y + 'px';
                });
            }

            getWorldConnectionPoint(side) {
                const targetPoint = this.connectionPoints?.find(point => 
                    point.userData?.side === side
                );
                
                if (targetPoint) {
                    const worldPosition = new THREE.Vector3();
                    targetPoint.getWorldPosition(worldPosition);
                    return snapToGrid(worldPosition);
                }
                
                const offset = (side === 'positive' || side === 'right') ? 1.2 : -1.2;
                return snapToGrid(new THREE.Vector3(
                    this.position.x + offset,
                    this.position.y,
                    this.position.z
                ));
            }

            updateProperties(newProperties) {
                Object.assign(this.properties, newProperties);
                if (this.type === 'switch' && this.leverMesh) {
                    this.leverMesh.material.color.setHex(this.properties.isOn ? 0x00ff00 : 0xff0000);
                    this.leverMesh.rotation.z = this.properties.isOn ? 0 : Math.PI / 6;
                }
                
                // Update the labels with new values
                this.updateLabels();
            }

            remove() {
                if (this.mesh) {
                    scene.remove(this.mesh);
                }
                
                if (this.labelDiv) {
                    document.body.removeChild(this.labelDiv);
                }
                
                // Remove polarity indicators
                if (this.polarityDivs) {
                    this.polarityDivs.forEach(item => {
                        if (item.div && item.div.parentNode) {
                            document.body.removeChild(item.div);
                        }
                    });
                    this.polarityDivs = null; // Clear to prevent memory leaks
                }
                
                const connectedWires = [...this.connections];
                connectedWires.forEach(connection => {
                    if (connection.wire) {
                        connection.wire.remove();
                    }
                });
                
                const index = components.indexOf(this);
                if (index > -1) {
                    components.splice(index, 1);
                }
                
                // Reset component counter if this was the last one
                this.updateComponentCounters();
            }

            updateComponentCounters() {
                // Recalculate component numbers to avoid gaps
                const typeComponents = components.filter(comp => comp.type === this.type);
                typeComponents.forEach((comp, index) => {
                    comp.componentNumber = index + 1;
                    comp.updateLabels();
                });
                componentCounters[this.type] = typeComponents.length;
            }
        }

        // Wire class
        class Wire {
            constructor(startObj, startSide, endObj, endSide) {
                this.startObj = startObj;
                this.startSide = startSide;
                this.endObj = endObj;
                this.endSide = endSide;
                this.id = 'wire_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                this.segments = [];
                
                this.createMesh();
                this.createCurve();
                this.addToConnections();
            }

            createMesh() {
                const startPos = this.getStartPosition();
                const endPos = this.getEndPosition();
                
                const distance = startPos.distanceTo(endPos);
                if (distance < 0.1) {
                    throw new Error('Wire too short');
                }
                
                // Create right-angled wire path
                const path = createRightAngledWirePath(startPos, endPos, this.startSide, this.endSide);
                this.createWireSegments(path);
            }

            createWireSegments(path) {
                this.wireGroup = new THREE.Group();
                this.segments = [];
                
                for (let i = 0; i < path.length - 1; i++) {
                    const segmentStart = path[i];
                    const segmentEnd = path[i + 1];
                    const distance = segmentStart.distanceTo(segmentEnd);
                    
                    if (distance > 0.1) {
                        const wireGeometry = new THREE.CylinderGeometry(0.08, 0.08, distance, isMobile ? 8 : 12);
                        
                        const material = new THREE.MeshPhongMaterial({ 
                            color: 0xd2691e,
                            shininess: 150,
                            transparent: true,
                            opacity: 0.9
                        });
                        
                        const segment = new THREE.Mesh(wireGeometry, material);
                        
                        // Position segment at midpoint
                        const midPoint = new THREE.Vector3().addVectors(segmentStart, segmentEnd).multiplyScalar(0.5);
                        segment.position.copy(midPoint);
                        
                        // Rotate segment to connect the points
                        const direction = new THREE.Vector3().subVectors(segmentEnd, segmentStart).normalize();
                        const up = new THREE.Vector3(0, 1, 0);
                        const quaternion = new THREE.Quaternion().setFromUnitVectors(up, direction);
                        segment.setRotationFromQuaternion(quaternion);
                        
                        this.wireGroup.add(segment);
                        this.segments.push({
                            mesh: segment,
                            start: segmentStart.clone(),
                            end: segmentEnd.clone()
                        });
                    }
                }
                
                this.wireGroup.userData = { wire: this };
                this.mesh = this.wireGroup;
                scene.add(this.wireGroup);
            }

            getStartPosition() {
                if (this.startObj.getWorldConnectionPoint) {
                    const connectionPoint = this.startObj.getWorldConnectionPoint(this.startSide);
                    // In freeform routing mode, don't snap wire endpoints to grid
                    // This ensures wires connect exactly to component terminals
                    const routerMode = getRouterMode();
                    if (routerMode === 'freeform' || routerMode === 'simple') {
                        return connectionPoint;
                    }
                    return snapToGrid(connectionPoint);
                }
                return snapToGrid(this.startObj.position.clone());
            }

            getEndPosition() {
                if (this.endObj.getWorldConnectionPoint) {
                    const connectionPoint = this.endObj.getWorldConnectionPoint(this.endSide);
                    // In freeform routing mode, don't snap wire endpoints to grid
                    // This ensures wires connect exactly to component terminals
                    const routerMode = getRouterMode();
                    if (routerMode === 'freeform' || routerMode === 'simple') {
                        return connectionPoint;
                    }
                    return snapToGrid(connectionPoint);
                }
                return snapToGrid(this.endObj.position.clone());
            }

            createCurve() {
                try {
                    const startPos = this.getStartPosition();
                    const endPos = this.getEndPosition();
                    const path = createRightAngledWirePath(startPos, endPos, this.startSide, this.endSide);
                    
                    this.curve = {
                        getPoint: (t) => {
                            t = Math.max(0, Math.min(1, t));
                            
                            let totalDistance = 0;
                            const distances = [];
                            
                            // Calculate segment distances
                            for (let i = 0; i < path.length - 1; i++) {
                                const segmentDistance = path[i].distanceTo(path[i + 1]);
                                distances.push(segmentDistance);
                                totalDistance += segmentDistance;
                            }
                            
                            // Find which segment we're on
                            const targetDistance = t * totalDistance;
                            let currentDistance = 0;
                            
                            for (let i = 0; i < distances.length; i++) {
                                if (currentDistance + distances[i] >= targetDistance) {
                                    const segmentT = (targetDistance - currentDistance) / distances[i];
                                    return new THREE.Vector3().lerpVectors(path[i], path[i + 1], segmentT);
                                }
                                currentDistance += distances[i];
                            }
                            
                            return path[path.length - 1].clone();
                        }
                    };
                } catch (error) {
                    console.error('Error creating wire curve:', error);
                    this.curve = null;
                }
            }

            updatePath() {
                if (this.wireGroup) {
                    scene.remove(this.wireGroup);
                }
                
                const startPos = this.getStartPosition();
                const endPos = this.getEndPosition();
                const path = createRightAngledWirePath(startPos, endPos, this.startSide, this.endSide);
                
                this.createWireSegments(path);
                this.createCurve();
            }

            addToConnections() {
                if (this.startObj.connections) {
                    this.startObj.connections.push({
                        wire: this,
                        connectedTo: this.endObj,
                        side: this.startSide
                    });
                }
                if (this.startObj.addConnection) {
                    this.startObj.addConnection(this);
                }
                
                if (this.endObj.connections) {
                    this.endObj.connections.push({
                        wire: this,
                        connectedTo: this.startObj,
                        side: this.endSide
                    });
                }
                if (this.endObj.addConnection) {
                    this.endObj.addConnection(this);
                }
            }

            remove() {
                if (this.wireGroup) {
                    scene.remove(this.wireGroup);
                }
                
                if (this.startObj?.connections) {
                    this.startObj.connections = this.startObj.connections.filter(
                        conn => conn.wire !== this
                    );
                }
                if (this.startObj?.removeConnection) {
                    this.startObj.removeConnection(this);
                }
                
                if (this.endObj?.connections) {
                    this.endObj.connections = this.endObj.connections.filter(
                        conn => conn.wire !== this
                    );
                }
                if (this.endObj?.removeConnection) {
                    this.endObj.removeConnection(this);
                }
                
                const index = wires.indexOf(this);
                if (index > -1) {
                    wires.splice(index, 1);
                }
            }
        }

        // Center circuit for optimal viewing
        function centerCircuit() {
            if (components.length === 0 && junctions.length === 0) {
                setStatus('?? No components to center');
                return;
            }
            
            saveState(); // Save for undo
            
            // Calculate center of all components
            const allObjects = [...components, ...junctions];
            let centerX = 0, centerZ = 0;
            
            allObjects.forEach(obj => {
                centerX += obj.position.x;
                centerZ += obj.position.z;
            });
            
            centerX /= allObjects.length;
            centerZ /= allObjects.length;
            
            // Move all objects to center the circuit at origin
            const offsetX = -centerX;
            const offsetZ = -centerZ;
            
            allObjects.forEach(obj => {
                obj.position.x += offsetX;
                obj.position.z += offsetZ;
                
                // Snap to grid
                obj.position.copy(snapToGrid(obj.position));
                
                if (obj.mesh) {
                    obj.mesh.position.copy(obj.position);
                }
            });
            
            // Update all wire paths
            wires.forEach(wire => {
                if (wire.updatePath) {
                    wire.updatePath();
                }
            });
            
            // Center camera view
            cameraTarget.set(0, 0, 0);
            updateCameraPosition();
            
            setStatus('?? Circuit centered and aligned to grid for professional schematic appearance');
        }

        // Initialize the scene
        function init() {
            try {
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x0a0a1a);
                
                camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                updateCameraPosition();
                
                const canvas = document.getElementById('canvas');
                renderer = new THREE.WebGLRenderer({ 
                    canvas: canvas,
                    antialias: !isMobile, // Disable antialiasing on mobile for performance
                    powerPreference: isMobile ? "low-power" : "high-performance"
                });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, isMobile ? 1.5 : 2));
                
                raycaster = new THREE.Raycaster();
                mouse = new THREE.Vector2();
                
                // Lighting - reduced for mobile performance
                const directionalLight = new THREE.DirectionalLight(0xffffff, isMobile ? 1.0 : 1.2);
                directionalLight.position.set(10, 10, 5);
                scene.add(directionalLight);
                
                if (!isMobile) {
                    const pointLight = new THREE.PointLight(0xffa500, 0.8, 50);
                    pointLight.position.set(5, 8, 5);
                    scene.add(pointLight);
                }
                
                const ambientLight = new THREE.AmbientLight(0x404040, isMobile ? 0.6 : 0.4);
                scene.add(ambientLight);
                
                // Enhanced grid system
                createEnhancedGrid();
                createSnapIndicator();
                
                setupEvents();
                
                // Hide main app initially - landing page shows first
                document.getElementById('loading').style.display = 'none';
                document.getElementById('menu-bar').style.display = 'none';
                document.getElementById('status').style.display = 'none';
                document.getElementById('canvas').style.display = 'none';
                
                animate();
                
                updateCircuitInfo();

                // Prevent context menu on long press
                document.addEventListener('contextmenu', function(e) {
                    e.preventDefault();
                    return false;
                });

                // Prevent zoom on double tap
                let lastTouchEnd = 0;
                document.addEventListener('touchend', function (event) {
                    const now = (new Date()).getTime();
                    if (now - lastTouchEnd <= 300) {
                        event.preventDefault();
                    }
                    lastTouchEnd = now;
                }, false);

                notifyParentReady();
                notifyParentAnalysisState();

            } catch (error) {
                console.error('Initialization error:', error);
                document.getElementById('loading').textContent = 'Error loading. Please refresh.';
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            updateFlowParticles();
            updateComponentLabels();
            if (renderer) {
                renderer.render(scene, camera);
            }
        }

        function updateComponentLabels() {
            // Update all component label positions
            components.forEach(component => {
                if (component.updateLabelPosition) {
                    component.updateLabelPosition();
                }
                // Update polarity indicator positions
                if (component.updatePolarityPositions) {
                    component.updatePolarityPositions();
                }
            });
        }

        function updateFlowParticles() {
            currentFlowParticles.forEach((particle, index) => {
                try {
                    if (!particle?.userData?.wire || !particle.userData.isFlowing) {
                        scene.remove(particle);
                        currentFlowParticles.splice(index, 1);
                        return;
                    }
                    
                    const wireData = particle.userData;
                    const wire = wireData.wire;
                    
                    if (!wire || !wire.curve) {
                        scene.remove(particle);
                        currentFlowParticles.splice(index, 1);
                        return;
                    }
                    
                    wireData.progress += wireData.baseSpeed;
                    
                    if (wireData.progress > 1) {
                        wireData.progress = 0;
                    }
                    
                    const position = wire.curve.getPoint(wireData.progress);
                    if (position && position.isVector3) {
                        particle.position.copy(position);
                    }
                    
                } catch (error) {
                    console.error(`Error updating particle ${index}:`, error);
                    scene.remove(particle);
                    currentFlowParticles.splice(index, 1);
                }
            });
        }

        function updateCameraPosition() {
            const x = cameraDistance * Math.cos(cameraAngleY) * Math.cos(cameraAngleX);
            const y = cameraDistance * Math.sin(cameraAngleY);
            const z = cameraDistance * Math.cos(cameraAngleY) * Math.sin(cameraAngleX);
            
            camera.position.set(
                cameraTarget.x + x, 
                cameraTarget.y + y, 
                cameraTarget.z + z
            );
            camera.lookAt(cameraTarget);
        }

        function setupEvents() {
            const canvas = renderer.domElement;
            
            // Touch events with improved handling for Android
            canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
            canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
            canvas.addEventListener('touchend', handleTouchEnd, { passive: false });
            canvas.addEventListener('touchcancel', handleTouchEnd, { passive: false });
            
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseup', handleMouseUp);
            canvas.addEventListener('wheel', handleWheel, { passive: false });
            canvas.addEventListener('contextmenu', e => e.preventDefault());
            
            // Keyboard shortcuts (mainly for desktop)
            if (!isMobile) {
                document.addEventListener('keydown', handleKeyDown);
            }
            
            // Close submenus when clicking outside
            document.addEventListener('click', (e) => {
                if (!e.target.closest('.menu-bar')) {
                    closeAllSubmenus();
                }
                
                // Close edit popup when clicking outside
                if (!e.target.closest('.edit-popup') && !e.target.closest('#canvas')) {
                    if (currentEditComponent) {
                        hideEditPopup();
                    }
                }
            });
            
            window.addEventListener('resize', onResize);
            window.addEventListener('orientationchange', () => {
                setTimeout(onResize, 100); // Delay to ensure orientation change is complete
            });
        }

        function handleKeyDown(e) {
            // Check if user is typing in an input field
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.tagName === 'SELECT') {
                // Handle special keys in edit popup
                if (e.key === 'Enter' && currentEditComponent) {
                    e.preventDefault();
                    saveEdit();
                    return;
                } else if (e.key === 'Escape' && currentEditComponent) {
                    e.preventDefault();
                    cancelEdit();
                    return;
                }
                return;
            }
            
            const key = e.key.toLowerCase();
            const ctrl = e.ctrlKey || e.metaKey;
            
            // Prevent default for our shortcuts
            if (ctrl || ['b', 'r', 'l', 's', 'j', 'w', 't', 'c', ' ', 'h', 'f', 'g'].includes(key)) {
                e.preventDefault();
            }
            
            if (ctrl) {
                switch (key) {
                    case 'z':
                        if (e.shiftKey) {
                            redo();
                        } else {
                            undo();
                        }
                        break;
                    case 'y':
                        redo();
                        break;
                    case 'c':
                        copySelected();
                        break;
                    case 'v':
                        pasteSelected();
                        break;
                    case 's':
                        saveCircuit();
                        break;
                    case 'o':
                        loadCircuit();
                        break;
                    case 'n':
                        newCircuit();
                        break;
                }
            } else {
                switch (key) {
                    case 'b':
                        addComponent('battery');
                        break;
                    case 'r':
                        addComponent('resistor');
                        break;
                    case 'l':
                        addComponent('led');
                        break;
                    case 's':
                        addComponent('switch');
                        break;
                    case 'j':
                        addJunction();
                        break;
                    case 'w':
                        toggleWireMode();
                        break;
                    case 't':
                        toggleRotateMode();
                        break;
                    case 'c':
                        clearAll();
                        break;
                    case ' ':
                        toggleMenuBar();
                        break;
                    case 'h':
                        resetCamera();
                        break;
                    case 'f':
                        fitToScreen();
                        break;
                    case 'g':
                        toggleGrid();
                        break;
                    case 'delete':
                    case 'backspace':
                        deleteSelected();
                        break;
                    case 'escape':
                        if (currentEditComponent) {
                            cancelEdit();
                        }
                        break;
                }
            }
        }

        function handleTouchStart(e) {
            e.preventDefault();
            
            if (e.touches.length === 1) {
                const touch = e.touches[0];
                lastTouchPos = { x: touch.clientX, y: touch.clientY };
                longPressStartPos = { x: touch.clientX, y: touch.clientY };
                
                // Start long press timer
                startLongPressTimer(touch.clientX, touch.clientY);
                
                if (checkComponentHit(touch.clientX, touch.clientY)) {
                    return;
                }
                
                isRotating = true;
                isPanning = false;
                
            } else if (e.touches.length === 2) {
                // Two-finger gesture setup
                cancelLongPress();
                
                const touch1 = e.touches[0];
                const touch2 = e.touches[1];
                
                // Calculate center point for panning
                lastTwoFingerCenter = {
                    x: (touch1.clientX + touch2.clientX) / 2,
                    y: (touch1.clientY + touch2.clientY) / 2
                };
                
                // Calculate distance for pinch-to-zoom
                lastPinchDistance = Math.sqrt(
                    Math.pow(touch2.clientX - touch1.clientX, 2) + 
                    Math.pow(touch2.clientY - touch1.clientY, 2)
                );
                
                isRotating = false;
                isPanning = true;
            }
        }

        function handleTouchMove(e) {
            e.preventDefault();
            
            if (e.touches.length === 1) {
                const touch = e.touches[0];
                
                // Check if moved too far for long press
                const deltaX = Math.abs(touch.clientX - longPressStartPos.x);
                const deltaY = Math.abs(touch.clientY - longPressStartPos.y);
                if ((deltaX > 15 || deltaY > 15) && longPressTimer) {
                    cancelLongPress();
                }
                
                if (isDragging && selectedComponent) {
                    handleComponentDrag(touch.clientX, touch.clientY);
                } else if (isRotating) {
                    const deltaX = touch.clientX - lastTouchPos.x;
                    const deltaY = touch.clientY - lastTouchPos.y;
                    
                    const sensitivity = isMobile ? 0.008 : 0.01;
                    cameraAngleX += deltaX * sensitivity;
                    cameraAngleY = Math.max(-1.5, Math.min(1.5, cameraAngleY - deltaY * sensitivity));
                    updateCameraPosition();
                }
                
                lastTouchPos = { x: touch.clientX, y: touch.clientY };
                
            } else if (e.touches.length === 2 && isPanning) {
                const touch1 = e.touches[0];
                const touch2 = e.touches[1];
                
                // Calculate new center point
                const newCenter = {
                    x: (touch1.clientX + touch2.clientX) / 2,
                    y: (touch1.clientY + touch2.clientY) / 2
                };
                
                // Calculate new distance
                const newDistance = Math.sqrt(
                    Math.pow(touch2.clientX - touch1.clientX, 2) + 
                    Math.pow(touch2.clientY - touch1.clientY, 2)
                );
                
                // Handle pinch-to-zoom
                if (lastPinchDistance > 0) {
                    const pinchDelta = newDistance - lastPinchDistance;
                    const zoomSensitivity = isMobile ? 0.015 : 0.02;
                    cameraDistance = Math.max(5, Math.min(50, cameraDistance - pinchDelta * zoomSensitivity));
                    updateCameraPosition();
                }
                
                // Handle two-finger pan (camera target movement)
                const panDeltaX = newCenter.x - lastTwoFingerCenter.x;
                const panDeltaY = newCenter.y - lastTwoFingerCenter.y;
                
                // Convert screen movement to world movement
                const panSensitivity = cameraDistance * 0.005;
                
                // Calculate camera right and up vectors for proper panning
                const cameraDirection = new THREE.Vector3();
                camera.getWorldDirection(cameraDirection);
                
                const cameraRight = new THREE.Vector3();
                cameraRight.crossVectors(cameraDirection, new THREE.Vector3(0, 1, 0)).normalize();
                
                const cameraUp = new THREE.Vector3();
                cameraUp.crossVectors(cameraRight, cameraDirection).normalize();
                
                // Apply pan movement to camera target
                cameraTarget.add(cameraRight.multiplyScalar(-panDeltaX * panSensitivity));
                cameraTarget.add(cameraUp.multiplyScalar(panDeltaY * panSensitivity));
                
                updateCameraPosition();
                
                // Update stored values
                lastTwoFingerCenter = newCenter;
                lastPinchDistance = newDistance;
            }
        }

        function handleTouchEnd(e) {
            e.preventDefault();
            isRotating = false;
            isPanning = false;
            cancelLongPress();
            
            if (isDragging) {
                handleRelease();
            }
            
            // Reset touch tracking
            lastPinchDistance = 0;
            lastTwoFingerCenter = { x: 0, y: 0 };
        }

        function handleMouseDown(e) {
            if (e.button === 0) {
                longPressStartPos = { x: e.clientX, y: e.clientY };
                startLongPressTimer(e.clientX, e.clientY);
                checkComponentHit(e.clientX, e.clientY);
            } else if (e.button === 2) {
                isRotating = true;
                lastTouchPos = { x: e.clientX, y: e.clientY };
            }
        }

        function handleMouseMove(e) {
            // Check if moved too far for long press
            const deltaX = Math.abs(e.clientX - longPressStartPos.x);
            const deltaY = Math.abs(e.clientY - longPressStartPos.y);
            if ((deltaX > 10 || deltaY > 10) && longPressTimer) {
                cancelLongPress();
            }
            
            if (isRotating) {
                const deltaX = e.clientX - lastTouchPos.x;
                const deltaY = e.clientY - lastTouchPos.y;
                
                cameraAngleX += deltaX * 0.01;
                cameraAngleY = Math.max(-1.5, Math.min(1.5, cameraAngleY - deltaY * 0.01));
                updateCameraPosition();
                
                lastTouchPos = { x: e.clientX, y: e.clientY };
            } else if (isDragging && selectedComponent) {
                handleComponentDrag(e.clientX, e.clientY);
            }
        }

        function handleMouseUp(e) {
            isRotating = false;
            cancelLongPress();
            if (isDragging) {
                handleRelease();
            }
        }

        function handleWheel(e) {
            e.preventDefault();
            const sensitivity = isMobile ? 0.005 : 0.01;
            cameraDistance = Math.max(5, Math.min(50, cameraDistance + e.deltaY * sensitivity));
            updateCameraPosition();
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Grid and snapping functions
        function createEnhancedGrid() {
            // Main grid - reduced complexity for mobile
            const gridSize = isMobile ? 20 : 40;
            const gridDivisions = isMobile ? 20 : 40;
            
            gridHelper = new THREE.GridHelper(gridSize, gridDivisions, 0x333366, 0x111122);
            scene.add(gridHelper);
            
            // Fine grid overlay - only on desktop
            if (!isMobile) {
                const fineGrid = new THREE.GridHelper(gridSize, gridDivisions * 2, 0x222244, 0x0a0a1a);
                fineGrid.position.y = 0.01; // Slightly above main grid
                scene.add(fineGrid);
            }
        }

        function createSnapIndicator() {
            const geometry = new THREE.RingGeometry(0.8, 1.0, 8);
            const material = new THREE.MeshBasicMaterial({ 
                color: 0x00ff88, 
                transparent: true, 
                opacity: 0.8 
            });
            snapIndicator = new THREE.Mesh(geometry, material);
            snapIndicator.rotation.x = -Math.PI / 2;
            snapIndicator.visible = false;
            scene.add(snapIndicator);
        }

        function snapToGrid(position) {
            return new THREE.Vector3(
                Math.round(position.x / GRID_SIZE) * GRID_SIZE,
                0,
                Math.round(position.z / GRID_SIZE) * GRID_SIZE
            );
        }

        function showSnapIndicator(position) {
            if (snapIndicator) {
                const snappedPos = snapToGrid(position);
                snapIndicator.position.copy(snappedPos);
                snapIndicator.visible = true;
            }
        }

        function hideSnapIndicator() {
            if (snapIndicator) {
                snapIndicator.visible = false;
            }
        }

        // Helper: get world-space axis-aligned obstacles from components and labels
        function getObstacleRects(clearance = GRID_SIZE * 1.0) {
            const rects = [];
            // Components
            components.forEach(comp => {
                const box = new THREE.Box3().setFromObject(comp.selectionBox || comp.mesh);
                if (box && box.min && box.max) {
                    rects.push({
                        minX: box.min.x - clearance,
                        maxX: box.max.x + clearance,
                        minZ: box.min.z - clearance,
                        maxZ: box.max.z + clearance,
                    });
                }
            });
            // Labels (approximate small rect around projected point)
            components.forEach(comp => {
                if (comp.mesh) {
                    const p = comp.position;
                    rects.push({
                        minX: p.x - GRID_SIZE * 0.8,
                        maxX: p.x + GRID_SIZE * 0.8,
                        minZ: p.z - GRID_SIZE * 0.8,
                        maxZ: p.z + GRID_SIZE * 0.8,
                    });
                }
            });
            return rects;
        }

        // Helper: check if a grid cell center is blocked by any rect
        function cellBlocked(x, z, rects) {
            for (let i = 0; i < rects.length; i++) {
                const r = rects[i];
                if (x >= r.minX && x <= r.maxX && z >= r.minZ && z <= r.maxZ) return true;
            }
            return false;
        }

        // Helper: collect existing wire segments for crossing penalty
        function getExistingWireSegments() {
            const segs = [];
            wires.forEach(w => {
                if (w.segments) {
                    w.segments.forEach(s => {
                        segs.push({ a: s.start.clone(), b: s.end.clone() });
                    });
                }
            });
            return segs;
        }

        function segIntersect(a1, a2, b1, b2) {
            // Axis-aligned only
            const aMinX = Math.min(a1.x, a2.x), aMaxX = Math.max(a1.x, a2.x);
            const aMinZ = Math.min(a1.z, a2.z), aMaxZ = Math.max(a1.z, a2.z);
            const bMinX = Math.min(b1.x, b2.x), bMaxX = Math.max(b1.x, b2.x);
            const bMinZ = Math.min(b1.z, b2.z), bMaxZ = Math.max(b1.z, b2.z);
            if (aMinX === aMaxX && bMinX === bMaxX) {
                // both vertical
                if (aMinX !== bMinX) return false;
                return !(aMaxZ < bMinZ || bMaxZ < aMinZ);
            } else if (aMinZ === aMaxZ && bMinZ === bMaxZ) {
                // both horizontal
                if (aMinZ !== bMinZ) return false;
                return !(aMaxX < bMinX || bMaxX < aMinX);
            } else {
                // one vertical, one horizontal
                if (aMinX === aMaxX) {
                    // a vertical, b horizontal
                    return (bMinX <= aMinX && aMinX <= bMaxX) && (aMinZ <= bMinZ && bMinZ <= aMaxZ);
                } else {
                    // a horizontal, b vertical
                    return (aMinX <= bMinX && bMinX <= aMaxX) && (bMinZ <= aMinZ && aMinZ <= bMaxZ);
                }
            }
        }

        function countCrossings(pathPoints, segs) {
            let crosses = 0;
            for (let i = 0; i < pathPoints.length - 1; i++) {
                const a = pathPoints[i], b = pathPoints[i + 1];
                for (let s of segs) {
                    if (segIntersect(a, b, s.a, s.b)) crosses++;
                }
            }
            return crosses;
        }

        // Router mode selection
        function getRouterMode() {
            // Allow override by query (?router=...), localStorage, or global
            try {
                const qs = new URLSearchParams(location.search);
                const q = qs.get('router');
                if (q) return q;
            } catch {}
            try {
                const ls = localStorage.getItem('routerMode');
                if (ls) return ls;
            } catch {}
            return (window.ROUTER_MODE || 'freeform');
        }
        
        function cycleRoutingMode() {
            const modes = ['freeform', 'manhattan', 'simple', 'perimeter', 'astar'];
            const current = getRouterMode();
            const currentIndex = modes.indexOf(current);
            const nextIndex = (currentIndex + 1) % modes.length;
            const nextMode = modes[nextIndex];
            
            // Save to localStorage
            try {
                localStorage.setItem('routerMode', nextMode);
                window.ROUTER_MODE = nextMode;
            } catch (e) {
                window.ROUTER_MODE = nextMode;
            }
            
            // Update UI
            const modeLabel = document.getElementById('route-mode');
            if (modeLabel) {
                const modeNames = {
                    'freeform': 'Free-form',
                    'manhattan': 'Manhattan',
                    'simple': 'Simple',
                    'perimeter': 'Perimeter',
                    'astar': 'A*'
                };
                modeLabel.textContent = modeNames[nextMode] || nextMode;
            }
            
            // Update existing wires with new routing
            wires.forEach(wire => {
                if (wire.updatePath) {
                    wire.updatePath();
                }
            });
            
            setStatus(`?? Routing mode: ${nextMode.toUpperCase()} - Wires updated with new routing style`);
        }

        function compressPath(points) {
            if (!points || points.length === 0) return points;
            const clean = [points[0]];
            for (let i = 1; i < points.length - 1; i++) {
                const a = clean[clean.length - 1];
                const p = points[i];
                const n = points[i + 1];
                if ((a.x === p.x && p.x === n.x) || (a.z === p.z && p.z === n.z)) continue;
                clean.push(p);
            }
            clean.push(points[points.length - 1]);
            return clean;
        }
        
        // Free-form routing - direct line with minimal bends
        function routeFreeform(A, B, startSide, endSide) {
            // Check if we need any bends at all
            const dx = Math.abs(B.x - A.x);
            const dz = Math.abs(B.z - A.z);
            
            // If points are very close or aligned, just connect directly
            if (dx < 0.1 || dz < 0.1) {
                return [A, B];
            }
            
            // For freeform, choose the most natural bend direction based on terminal sides
            // This reduces visual clutter and makes connections more intuitive
            
            // If components are facing each other (e.g., left-to-right), prefer straight-ish path
            if ((startSide === 'right' || startSide === 'positive') && 
                (endSide === 'left' || endSide === 'negative') && B.x > A.x) {
                // Natural left-to-right connection
                const midX = (A.x + B.x) / 2;
                if (dz < GRID_SIZE * 2) {
                    // Almost aligned - use single midpoint
                    return [A, new THREE.Vector3(midX, 0, A.z), new THREE.Vector3(midX, 0, B.z), B];
                }
            }
            
            if ((startSide === 'left' || startSide === 'negative') && 
                (endSide === 'right' || endSide === 'positive') && B.x < A.x) {
                // Natural right-to-left connection
                const midX = (A.x + B.x) / 2;
                if (dz < GRID_SIZE * 2) {
                    return [A, new THREE.Vector3(midX, 0, A.z), new THREE.Vector3(midX, 0, B.z), B];
                }
            }
            
            // Otherwise use a simple L-shaped corner
            // Choose corner based on which direction has more distance for cleaner look
            if (dx > dz) {
                // More horizontal distance - go horizontal first
                return [A, new THREE.Vector3(B.x, 0, A.z), B];
            } else {
                // More vertical distance - go vertical first
                return [A, new THREE.Vector3(A.x, 0, B.z), B];
            }
        }

        function routeSimple(A, B, startSide, endSide) {
            const GRID = GRID_SIZE;
            const STUB = GRID * 2;
            function stub(point, side, toward) {
                const dx = toward.x - point.x, dz = toward.z - point.z;
                if (side === 'left' || side === 'negative') return snapToGrid(new THREE.Vector3(point.x - STUB, 0, point.z));
                if (side === 'right' || side === 'positive') return snapToGrid(new THREE.Vector3(point.x + STUB, 0, point.z));
                return Math.abs(dx) >= Math.abs(dz)
                    ? snapToGrid(new THREE.Vector3(point.x + Math.sign(dx||1)*STUB, 0, point.z))
                    : snapToGrid(new THREE.Vector3(point.x, 0, point.z + Math.sign(dz||1)*STUB));
            }
            const Astub = stub(A, startSide, B);
            const Bstub = stub(B, endSide, A);
            if (Math.abs(Astub.x - Bstub.x) < 0.001 || Math.abs(Astub.z - Bstub.z) < 0.001) {
                return compressPath([A, Astub, Bstub, B]);
            }
            // Choose corner that increases distance from A along the first segment (outward)
            const c1 = new THREE.Vector3(Bstub.x, 0, Astub.z);
            const c2 = new THREE.Vector3(Astub.x, 0, Bstub.z);
            const moveXOut = Math.abs(c1.x - A.x) >= Math.abs(Astub.x - A.x);
            const moveZOut = Math.abs(c2.z - A.z) >= Math.abs(Astub.z - A.z);
            const C = moveXOut ? c1 : (moveZOut ? c2 : c1);
            return compressPath([A, Astub, snapToGrid(C), Bstub, B]);
        }

        function routePerimeter(A, B, startSide, endSide) {
            const GRID = GRID_SIZE;
            const STUB = GRID * 2, OUTER = GRID * 4;
            function stub(point, side, toward) {
                const dx = toward.x - point.x, dz = toward.z - point.z;
                if (side === 'left' || side === 'negative') return snapToGrid(new THREE.Vector3(point.x - STUB, 0, point.z));
                if (side === 'right' || side === 'positive') return snapToGrid(new THREE.Vector3(point.x + STUB, 0, point.z));
                return Math.abs(dx) >= Math.abs(dz)
                    ? snapToGrid(new THREE.Vector3(point.x + Math.sign(dx||1)*STUB, 0, point.z))
                    : snapToGrid(new THREE.Vector3(point.x, 0, point.z + Math.sign(dz||1)*STUB));
            }
            const Astub = stub(A, startSide, B);
            const Bstub = stub(B, endSide, A);
            if (Math.abs(Astub.x - Bstub.x) < 0.001 || Math.abs(Astub.z - Bstub.z) < 0.001) {
                return compressPath([A, Astub, Bstub, B]);
            }
            const minX = Math.min(Astub.x, Bstub.x), maxX = Math.max(Astub.x, Bstub.x);
            const minZ = Math.min(Astub.z, Bstub.z), maxZ = Math.max(Astub.z, Bstub.z);
            const dx = Bstub.x - Astub.x, dz = Bstub.z - Astub.z;
            if (Math.abs(dx) >= Math.abs(dz)) {
                const outwardX = dx > 0 ? (maxX + OUTER) : (minX - OUTER);
                return compressPath([A, Astub, snapToGrid(new THREE.Vector3(outwardX,0,Astub.z)), snapToGrid(new THREE.Vector3(outwardX,0,Bstub.z)), Bstub, B]);
            } else {
                const outwardZ = dz > 0 ? (maxZ + OUTER) : (minZ - OUTER);
                return compressPath([A, Astub, snapToGrid(new THREE.Vector3(Astub.x,0,outwardZ)), snapToGrid(new THREE.Vector3(Bstub.x,0,outwardZ)), Bstub, B]);
            }
        }

        function routeAStar(A, B, startSide, endSide) {
            const GRID = GRID_SIZE;
            const obstacles = getObstacleRects(GRID * 0.6);
            function outwardDirForSide(side, axisDelta) {
                if (side === 'left' || side === 'negative') return -1;
                if (side === 'right' || side === 'positive') return 1;
                return Math.sign(axisDelta) || 1;
            }
            function computeStub(point, side, toward) {
                const dx = toward.x - point.x; const dz = toward.z - point.z;
                const useX = Math.abs(dx) >= Math.abs(dz);
                const dir = useX ? outwardDirForSide(side, dx) : outwardDirForSide(side, dz);
                for (let len = 1; len <= 3; len++) {
                    const nx = point.x + (useX ? dir * len * GRID : 0);
                    const nz = point.z + (!useX ? dir * len * GRID : 0);
                    const p = snapToGrid(new THREE.Vector3(nx, 0, nz));
                    if (!cellBlocked(p.x, p.z, obstacles)) return p;
                }
                return snapToGrid(new THREE.Vector3(point.x + (useX ? dir * GRID : 0), 0, point.z + (!useX ? dir * GRID : 0)));
            }
            const Astub = computeStub(A, startSide, B);
            const Bstub = computeStub(B, endSide, A);
            if (Math.abs(Astub.x - Bstub.x) < 0.001 || Math.abs(Astub.z - Bstub.z) < 0.001) {
                return compressPath([A, Astub, Bstub, B]);
            }
            const minX = Math.min(Astub.x, Bstub.x) - GRID * 8, maxX = Math.max(Astub.x, Bstub.x) + GRID * 8;
            const minZ = Math.min(Astub.z, Bstub.z) - GRID * 8, maxZ = Math.max(Astub.z, Bstub.z) + GRID * 8;
            function key(x,z){return x+","+z}
            const start = Astub, goal = Bstub;
            const pq=[]; const came=new Map(); const g=new Map(); const f=new Map(); const dir=new Map();
            function push(n,ff){pq.push({n,ff});pq.sort((a,b)=>a.ff-b.ff)} function pop(){return pq.shift().n}
            const existingSegs = getExistingWireSegments();
            const ELBOW = GRID*5, CROSS = GRID*3;
            function h(p){return Math.abs(p.x-goal.x)+Math.abs(p.z-goal.z)}
            const sK=key(start.x,start.z); g.set(sK,0); f.set(sK,h(start)); push(start,f.get(sK)); dir.set(sK,null);
            const dirs=[[GRID,0,'R'],[0,GRID,'D'],[-GRID,0,'L'],[0,-GRID,'U']];
            while(pq.length){
                const cur=pop(); const cK=key(cur.x,cur.z);
                if(cur.x===goal.x && cur.z===goal.z){
                    const path=[cur]; let ck=cK; while(came.has(ck)){const prev=came.get(ck); path.unshift(prev); ck=key(prev.x,prev.z);} 
                    return compressPath([A].concat(path).concat([B]));
                }
                for(const[dX,dZ,code] of dirs){
                    const nx=cur.x+dX, nz=cur.z+dZ; if(nx<minX||nx>maxX||nz<minZ||nz>maxZ) continue; if(cellBlocked(nx,nz,obstacles)) continue; const nK=key(nx,nz);
                    const step=GRID; const prev=dir.get(cK); const elbow=(prev&&prev!==code)?ELBOW:0; 
                    const a=cur, b=new THREE.Vector3(nx,0,nz); let cross=0; for(let s of existingSegs){ if(segIntersect(a,b,s.a,s.b)) cross+=CROSS; }
                    const tent=(g.get(cK)||Infinity)+step+elbow+cross; if(tent < (g.get(nK)||Infinity)){ came.set(nK,cur); g.set(nK,tent); const ff=tent+h({x:nx,z:nz}); f.set(nK,ff); dir.set(nK,code); push(new THREE.Vector3(nx,0,nz),ff);} 
                }
            }
            return compressPath([A, new THREE.Vector3(Bstub.x,0,Astub.z), B]);
        }

        // Enhanced Manhattan routing with intelligent wire splitting
        function routeManhattan(A, B, startSide, endSide) {
            const GRID = GRID_SIZE;
            const STUB = GRID * 2;
            
            // Create stub segments extending from connection points
            function createStub(point, side, toward) {
                const dx = toward.x - point.x;
                const dz = toward.z - point.z;
                
                // Handle component sides with proper direction
                if (side === 'left' || side === 'negative') {
                    return snapToGrid(new THREE.Vector3(point.x - STUB, 0, point.z));
                }
                if (side === 'right' || side === 'positive') {
                    return snapToGrid(new THREE.Vector3(point.x + STUB, 0, point.z));
                }
                
                // For center/junction connections, choose direction based on target
                return Math.abs(dx) >= Math.abs(dz)
                    ? snapToGrid(new THREE.Vector3(point.x + Math.sign(dx || 1) * STUB, 0, point.z))
                    : snapToGrid(new THREE.Vector3(point.x, 0, point.z + Math.sign(dz || 1) * STUB));
            }
            
            const Astub = createStub(A, startSide, B);
            const Bstub = createStub(B, endSide, A);
            
            // Direct horizontal or vertical connection
            if (Math.abs(Astub.x - Bstub.x) < 0.001) {
                return compressPath([A, Astub, Bstub, B]);
            }
            if (Math.abs(Astub.z - Bstub.z) < 0.001) {
                return compressPath([A, Astub, Bstub, B]);
            }
            
            // Create L-shaped path with intelligent corner selection
            // Prefer corners that create cleaner textbook-style layouts
            const corner1 = snapToGrid(new THREE.Vector3(Bstub.x, 0, Astub.z));
            const corner2 = snapToGrid(new THREE.Vector3(Astub.x, 0, Bstub.z));
            
            // Choose corner based on circuit topology for cleaner routing
            // Prefer horizontal-then-vertical for typical series circuits
            const useCorner1 = shouldUseHorizontalFirst(A, B, startSide, endSide);
            const corner = useCorner1 ? corner1 : corner2;
            
            return compressPath([A, Astub, corner, Bstub, B]);
        }
        
        // Determine if horizontal routing should come first for cleaner layouts
        function shouldUseHorizontalFirst(startPos, endPos, startSide, endSide) {
            // For battery connections, prefer routing away from battery first
            if (startSide === 'positive' || startSide === 'negative') {
                return true;
            }
            
            // For components in series (left-to-right), prefer horizontal
            if ((startSide === 'right' && endSide === 'left') || 
                (startSide === 'left' && endSide === 'right')) {
                return true;
            }
            
            // Default to horizontal-first for cleaner appearance
            return Math.abs(endPos.x - startPos.x) >= Math.abs(endPos.z - startPos.z);
        }
        
        // Detect and create intelligent wire splits for parallel circuits
        function createIntelligentSplit(sourceObj, targetObjs, splitType = 'parallel') {
            if (!sourceObj || !targetObjs || targetObjs.length === 0) return [];
            
            const GRID = GRID_SIZE;
            const SPREAD = GRID * 3; // Spacing between parallel branches
            const createdWires = [];
            const createdJunctions = [];
            
            if (splitType === 'parallel' && targetObjs.length > 1) {
                // Get source connection point
                const sourcePos = sourceObj.getWorldConnectionPoint 
                    ? sourceObj.getWorldConnectionPoint('right') 
                    : sourceObj.position;
                const snappedSource = snapToGrid(sourcePos.clone());
                
                // Create vertical bus for parallel distribution
                const busX = snappedSource.x + GRID * 4;
                const targetCount = targetObjs.length;
                const totalHeight = (targetCount - 1) * SPREAD;
                const busStartZ = snappedSource.z - totalHeight / 2;
                
                // Create junction spine for parallel distribution
                const spineJunctions = [];
                for (let i = 0; i < targetCount; i++) {
                    const jPos = snapToGrid(new THREE.Vector3(busX, 0, busStartZ + i * SPREAD));
                    const junction = new Junction(jPos);
                    junctions.push(junction);
                    spineJunctions.push(junction);
                    createdJunctions.push(junction);
                }
                
                // Connect source to middle junction of spine
                const midIndex = Math.floor(targetCount / 2);
                const midJunction = spineJunctions[midIndex];
                const feedWire = new Wire(sourceObj, 'right', midJunction, 'center');
                wires.push(feedWire);
                createdWires.push(feedWire);
                
                // Connect spine junctions vertically
                for (let i = 0; i < spineJunctions.length - 1; i++) {
                    const spineWire = new Wire(spineJunctions[i], 'center', spineJunctions[i + 1], 'center');
                    wires.push(spineWire);
                    createdWires.push(spineWire);
                }
                
                // Branch out to each target component
                targetObjs.forEach((target, i) => {
                    const branchWire = new Wire(spineJunctions[i], 'center', target, 'left');
                    wires.push(branchWire);
                    createdWires.push(branchWire);
                });
                
                return { wires: createdWires, junctions: createdJunctions };
            }
            
            // Series connection (default)
            for (let i = 0; i < targetObjs.length; i++) {
                const target = targetObjs[i];
                const startSide = i === 0 ? 'right' : 'right';
                const endSide = 'left';
                
                const wire = new Wire(
                    i === 0 ? sourceObj : targetObjs[i - 1],
                    startSide,
                    target,
                    endSide
                );
                wires.push(wire);
                createdWires.push(wire);
            }
            
            return { wires: createdWires, junctions: createdJunctions };
        }
        
        // Analyze circuit topology to detect series/parallel configurations
        function analyzeCircuitTopology() {
            const topology = {
                series: [],
                parallel: [],
                combination: []
            };
            
            // Group components by their connection patterns
            const batteries = components.filter(c => c.type === 'battery');
            const otherComponents = components.filter(c => c.type !== 'battery');
            
            if (batteries.length === 0 || otherComponents.length === 0) {
                return topology;
            }
            
            // Detect series chains (components connected in sequence)
            const visited = new Set();
            otherComponents.forEach(comp => {
                if (!visited.has(comp)) {
                    const chain = findSeriesChain(comp, otherComponents, visited);
                    if (chain.length > 1) {
                        topology.series.push(chain);
                    }
                }
            });
            
            // Detect parallel groups (multiple paths between same two nodes)
            const parallelGroups = findParallelGroups(otherComponents, wires);
            topology.parallel = parallelGroups;
            
            return topology;
        }
        
        // Find components connected in series
        function findSeriesChain(startComp, allComponents, visited) {
            const chain = [startComp];
            visited.add(startComp);
            
            // Look for connected components in sequence
            let current = startComp;
            while (true) {
                const nextComp = findNextInSeries(current, allComponents, visited);
                if (!nextComp) break;
                chain.push(nextComp);
                visited.add(nextComp);
                current = nextComp;
            }
            
            return chain;
        }
        
        // Find next component in a series chain
        function findNextInSeries(component, allComponents, visited) {
            const connectedWires = wires.filter(w => w.startObj === component || w.endObj === component);
            
            for (const wire of connectedWires) {
                const otherEnd = wire.startObj === component ? wire.endObj : wire.startObj;
                if (!visited.has(otherEnd) && allComponents.includes(otherEnd)) {
                    return otherEnd;
                }
            }
            
            return null;
        }
        
        // Find groups of components connected in parallel
        function findParallelGroups(components, wires) {
            const groups = [];
            
            // Implementation for detecting parallel configurations
            // This would analyze wire connections to find multiple paths
            // between the same two junction points
            
            return groups;
        }

        function createRightAngledWirePath(startPos, endPos, startSide, endSide) {
            const mode = getRouterMode();
            
            // In freeform and simple modes, don't snap endpoints to preserve exact connections
            let A, B;
            if (mode === 'freeform' || mode === 'simple') {
                A = startPos.clone();
                B = endPos.clone();
            } else {
                A = snapToGrid(startPos.clone());
                B = snapToGrid(endPos.clone());
            }
            
            // Support free-form routing
            if (mode === 'freeform') {
                return routeFreeform(A, B, startSide, endSide);
            }
            
            // Use enhanced Manhattan routing by default for textbook-style circuits
            if (mode === 'manhattan' || mode === 'simple') {
                return routeManhattan(A, B, startSide, endSide);
            }
            if (mode === 'perimeter') return routePerimeter(A, B, startSide, endSide);
            if (mode === 'astar') return routeAStar(A, B, startSide, endSide);
            
            // Default to Manhattan routing
            return routeManhattan(A, B, startSide, endSide);
        }

            // Auto-arrange circuit for professional schematic layout
        function arrangeCircuitSchematic() {
            if (components.length === 0) return;
            
            saveState(); // Save for undo
            
            // Find batteries (power sources)
            const batteries = components.filter(c => c.type === 'battery');
            const otherComponents = components.filter(c => c.type !== 'battery');
            
            if (batteries.length === 0) {
                setStatus('?? Add a battery first for schematic arrangement');
                return;
            }
            
            // Clear existing wires for clean re-routing
            wires.forEach(wire => wire.remove());
            wires = [];
            
            // Clear existing junctions
            junctions.forEach(junction => {
                if (junction.mesh) scene.remove(junction.mesh);
            });
            junctions.length = 0;
            
            // Arrange components in schematic style
            const SPACING = GRID_SIZE * 4;
            const battery = batteries[0];
            
            // Position battery on the left aligned to grid
            battery.position.set(-SPACING * 2, 0, 0);
            battery.mesh.position.copy(battery.position);
            
            // Detect if we should create series or parallel layout
            if (otherComponents.length <= 1) {
                // Single component - simple series
                if (otherComponents.length === 1) {
                    const comp = otherComponents[0];
                    const x = SPACING;
                    const p = snapToGrid(new THREE.Vector3(x, 0, 0));
                    comp.position.copy(p);
                    comp.mesh.position.copy(comp.position);
                    
                    // Wire in series
                    const wire1 = new Wire(battery, 'positive', comp, 'left');
                    const wire2 = new Wire(comp, 'right', battery, 'negative');
                    wires.push(wire1, wire2);
                }
            } else if (otherComponents.length <= 3) {
                // Few components - arrange in series horizontal line
                otherComponents.forEach((comp, index) => {
                    const x = index * SPACING;
                    const p = snapToGrid(new THREE.Vector3(x, 0, 0));
                    comp.position.copy(p);
                    comp.mesh.position.copy(comp.position);
                });
                
                // Connect in series using Manhattan routing
                const wire1 = new Wire(battery, 'positive', otherComponents[0], 'left');
                wires.push(wire1);
                
                for (let i = 0; i < otherComponents.length - 1; i++) {
                    const wire = new Wire(otherComponents[i], 'right', otherComponents[i + 1], 'left');
                    wires.push(wire);
                }
                
                const lastWire = new Wire(otherComponents[otherComponents.length - 1], 'right', battery, 'negative');
                wires.push(lastWire);
            } else {
                // Many components - create intelligent parallel layout
                // Position components in vertical arrangement for parallel configuration
                const halfCount = Math.ceil(otherComponents.length / 2);
                
                otherComponents.forEach((comp, index) => {
                    const row = index % halfCount;
                    const col = Math.floor(index / halfCount);
                    const x = SPACING * (2 + col * 2);
                    const z = (row - halfCount / 2) * SPACING;
                    const p = snapToGrid(new THREE.Vector3(x, 0, z));
                    comp.position.copy(p);
                    comp.mesh.position.copy(comp.position);
                });
                
                // Create parallel circuit with intelligent splitting
                createParallelBus(battery, otherComponents);
                
                // Return path - create return junctions and connect back to battery
                const returnX = SPACING * 6;
                const returnJunctions = [];
                
                otherComponents.forEach((comp, index) => {
                    const z = comp.position.z;
                    const jPos = snapToGrid(new THREE.Vector3(returnX, 0, z));
                    const junction = new Junction(jPos);
                    junctions.push(junction);
                    returnJunctions.push(junction);
                    
                    // Connect component to return junction
                    const wire = new Wire(comp, 'right', junction, 'center');
                    wires.push(wire);
                });
                
                // Connect return junctions vertically
                for (let i = 0; i < returnJunctions.length - 1; i++) {
                    const wire = new Wire(returnJunctions[i], 'center', returnJunctions[i + 1], 'center');
                    wires.push(wire);
                }
                
                // Connect middle return junction back to battery
                const midReturn = returnJunctions[Math.floor(returnJunctions.length / 2)];
                const finalWire = new Wire(midReturn, 'center', battery, 'negative');
                wires.push(finalWire);
            }
            
            // Center the view on the circuit
            fitToScreen();
            analyzeCircuit();
            setStatus('?? Circuit arranged in textbook-style layout with intelligent Manhattan routing!');
        }
        
        // Linear/Tree layout with battery at top
        function arrangeLinearLayout() {
            if (components.length === 0) return;
            
            saveState(); // Save for undo
            
            // Find batteries (power sources)
            const batteries = components.filter(c => c.type === 'battery');
            const otherComponents = components.filter(c => c.type !== 'battery');
            
            if (batteries.length === 0) {
                setStatus('?? Add a battery first for linear arrangement');
                return;
            }
            
            // Clear existing wires for clean re-routing
            wires.forEach(wire => wire.remove());
            wires = [];
            
            // Clear existing junctions
            junctions.forEach(junction => {
                if (junction.mesh) scene.remove(junction.mesh);
            });
            junctions.length = 0;
            
            const SPACING = GRID_SIZE * 3;
            const battery = batteries[0];
            
            // Position battery at the top center
            battery.position.set(0, 0, -SPACING * 3);
            battery.mesh.position.copy(battery.position);
            
            if (otherComponents.length === 0) {
                setStatus('?? Add components to arrange');
                return;
            }
            
            // Arrange components in tree structure below battery
            const levels = Math.ceil(Math.log2(otherComponents.length + 1));
            let componentIndex = 0;
            
            for (let level = 1; level <= levels && componentIndex < otherComponents.length; level++) {
                const componentsInLevel = Math.min(Math.pow(2, level - 1), otherComponents.length - componentIndex);
                const levelZ = -SPACING * 3 + level * SPACING * 2;
                const totalWidth = (componentsInLevel - 1) * SPACING * 2;
                const startX = -totalWidth / 2;
                
                for (let i = 0; i < componentsInLevel; i++) {
                    if (componentIndex >= otherComponents.length) break;
                    
                    const comp = otherComponents[componentIndex];
                    const x = startX + i * SPACING * 2;
                    const p = snapToGrid(new THREE.Vector3(x, 0, levelZ));
                    comp.position.copy(p);
                    comp.mesh.position.copy(comp.position);
                    componentIndex++;
                }
            }
            
            // Wire in series from top to bottom
            let prevComp = battery;
            let prevSide = 'positive';
            
            for (let i = 0; i < otherComponents.length; i++) {
                const comp = otherComponents[i];
                const wire = new Wire(prevComp, prevSide, comp, 'left');
                wires.push(wire);
                prevComp = comp;
                prevSide = 'right';
            }
            
            // Close the circuit back to battery
            if (otherComponents.length > 0) {
                const lastWire = new Wire(prevComp, prevSide, battery, 'negative');
                wires.push(lastWire);
            }
            
            // Center the view on the circuit
            fitToScreen();
            analyzeCircuit();
            setStatus('?? Circuit arranged in linear tree layout with battery at top!');
        }
        
        // Arrange circuit based on current layout mode
        function arrangeByLayoutMode() {
            if (layoutMode === 'linear') {
                arrangeLinearLayout();
            } else if (layoutMode === 'square') {
                arrangeCircuitSchematic();
            } else {
                // Free mode - just organize components in a grid
                if (components.length === 0) return;
                
                saveState();
                
                const SPACING = GRID_SIZE * 3;
                const cols = Math.ceil(Math.sqrt(components.length));
                
                components.forEach((comp, index) => {
                    const row = Math.floor(index / cols);
                    const col = index % cols;
                    const x = (col - cols / 2) * SPACING;
                    const z = (row - Math.ceil(components.length / cols) / 2) * SPACING;
                    const p = snapToGrid(new THREE.Vector3(x, 0, z));
                    comp.position.copy(p);
                    comp.mesh.position.copy(comp.position);
                });
                
                fitToScreen();
                setStatus('?? Components arranged in free-form grid - wire as you like!');
            }
        }

        // Launch application function
        function launchApplication() {
            const landingPage = document.getElementById('landing-page');
            const launchBtn = document.getElementById('launch-btn');
            const loadingProgress = document.getElementById('loading-progress');
            const loadingText = document.getElementById('loading-text');
            
            // Hide launch button and show loading (button hidden in auto mode)
            loadingProgress.style.display = 'block';
            loadingText.style.display = 'block';
            
            // Launch main app immediately (skip splash delays)
            setTimeout(() => {
                landingPage.classList.add('landing-hidden');
                
                setTimeout(() => {
                    landingPage.style.display = 'none';
                    
                    // Initialize the main application
                    document.getElementById('menu-bar').style.display = 'block';
                    document.getElementById('status').style.display = 'block';
                    document.getElementById('canvas').style.display = 'block';
                    
                    // Set initial status for CircuiTry
                    setStatus('?? CircuiTry Professional Circuit Design Environment Ready!');
                }, 0);
            }, 0);
        }

        // Auto-launch immediately to avoid getting stuck on splash
        window.addEventListener('load', () => {
            setTimeout(() => {
                launchApplication();
            }, 0);
        });

        // Long press detection functions
        function startLongPressTimer(clientX, clientY) {
            cancelLongPress(); // Clear any existing timer
            
            longPressTimer = setTimeout(() => {
                isLongPressing = true;
                handleLongPress(clientX, clientY);
            }, LONG_PRESS_DURATION);
        }

        function cancelLongPress() {
            if (longPressTimer) {
                clearTimeout(longPressTimer);
                longPressTimer = null;
            }
            isLongPressing = false;
        }

        function handleLongPress(clientX, clientY) {
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((clientY - rect.top) / rect.height) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            
            // Check for component selection boxes
            const selectionBoxes = [];
            components.forEach(comp => {
                if (comp?.selectionBox) {
                    selectionBoxes.push(comp.selectionBox);
                }
            });
            
            const componentHits = raycaster.intersectObjects(selectionBoxes, false);
            if (componentHits.length > 0) {
                const hitBox = componentHits[0].object;
                if (hitBox.userData?.component) {
                    showEditPopup(hitBox.userData.component, clientX, clientY);
                    
                    // Add haptic feedback for mobile devices
                    if (navigator.vibrate && isMobile) {
                        navigator.vibrate(50);
                    }
                    return;
                }
            }
            
            // Check for junctions
            const selectionSpheres = [];
            junctions.forEach(junction => {
                if (junction?.selectionSphere) {
                    selectionSpheres.push(junction.selectionSphere);
                }
            });
            
            const junctionHits = raycaster.intersectObjects(selectionSpheres, false);
            if (junctionHits.length > 0) {
                const hitSphere = junctionHits[0].object;
                if (hitSphere.userData?.junction) {
                    // Junctions don't have editable properties currently
                    setStatus('? Junctions have no editable properties');
                    return;
                }
            }
            
            // Check for wires
            const wireSegments = [];
            wires.forEach(wire => {
                if (wire?.segments) {
                    wire.segments.forEach(segment => {
                        if (segment.mesh) {
                            wireSegments.push(segment.mesh);
                        }
                    });
                }
            });
            
            const wireHits = raycaster.intersectObjects(wireSegments, false);
            if (wireHits.length > 0) {
                const hitSegment = wireHits[0].object;
                // Find the wire this segment belongs to
                const wire = wires.find(w => w.segments.some(s => s.mesh === hitSegment));
                if (wire) {
                    showWireEditPopup(wire, clientX, clientY);
                    
                    // Add haptic feedback for mobile devices
                    if (navigator.vibrate && isMobile) {
                        navigator.vibrate(50);
                    }
                    return;
                }
            }
        }
        
        // Wire edit popup
        function showWireEditPopup(wire, clientX, clientY) {
            const popup = document.getElementById('wire-edit-popup');
            if (!popup) {
                // Create popup if it doesn't exist
                createWireEditPopup();
                return showWireEditPopup(wire, clientX, clientY);
            }
            
            currentEditWire = wire;
            popup.style.display = 'block';
            
            setStatus('?? Wire selected - Choose action');
        }
        
        function createWireEditPopup() {
            const popup = document.createElement('div');
            popup.id = 'wire-edit-popup';
            popup.className = 'edit-popup';
            popup.style.display = 'none';
            popup.innerHTML = `
                <div class="edit-popup-content">
                    <div class="edit-popup-header">
                        <h3>Edit Wire</h3>
                        <button onclick="closeWireEditPopup()" class="edit-close">?</button>
                    </div>
                    <div class="edit-actions">
                        <button onclick="deleteWireFromPopup()" class="edit-action-btn delete-btn">??? Delete Wire</button>
                        <button onclick="changeWireRoutingFromPopup()" class="edit-action-btn">?? Change Routing</button>
                    </div>
                </div>
            `;
            document.body.appendChild(popup);
        }
        
        function closeWireEditPopup() {
            const popup = document.getElementById('wire-edit-popup');
            if (popup) {
                popup.style.display = 'none';
            }
            currentEditWire = null;
        }
        
        function deleteWireFromPopup() {
            if (currentEditWire) {
                saveState(); // Save for undo
                currentEditWire.remove();
                const index = wires.indexOf(currentEditWire);
                if (index > -1) {
                    wires.splice(index, 1);
                }
                analyzeCircuit();
                setStatus('??? Wire deleted');
            }
            closeWireEditPopup();
        }
        
        function changeWireRoutingFromPopup() {
            if (currentEditWire) {
                saveState(); // Save for undo
                // Cycle to next routing mode and update wire
                cycleRoutingMode();
                currentEditWire.updatePath();
                setStatus('?? Wire routing updated');
            }
            closeWireEditPopup();
        }
        
        // Variable to track current wire being edited
        let currentEditWire = null;

        // Edit popup functions
        function showEditPopup(component, clientX, clientY) {
            currentEditComponent = component;
            const popup = document.getElementById('edit-popup');
            const title = document.getElementById('edit-title');
            const content = document.getElementById('edit-content');
            
            if (!popup || !title || !content) return;
            
            // Set title
            title.textContent = `Edit ${component.type.charAt(0).toUpperCase() + component.type.slice(1)}`;
            
            // Create edit form based on component type
            content.innerHTML = createEditForm(component);
            
            // Show popup centered on screen for mobile
            popup.style.display = 'block';
            
            // Focus first input with delay for mobile keyboards
            const firstInput = popup.querySelector('input');
            if (firstInput && !isMobile) {
                setTimeout(() => firstInput.focus(), 100);
            }
            
            setStatus(`?? Editing ${component.type} - Long press to edit components!`);
        }

        function createEditForm(component) {
            let formHTML = '';
            
            switch (component.type) {
                case 'battery':
                    formHTML = `
                        <div class="edit-row">
                            <label>? Voltage (V)</label>
                            <input type="number" id="edit-voltage" value="${component.properties.voltage}" min="0" max="24" step="0.1">
                        </div>
                    `;
                    break;
                    
                case 'resistor':
                    formHTML = `
                        <div class="edit-row">
                            <label>? Resistance (?)</label>
                            <input type="number" id="edit-resistance" value="${component.properties.resistance}" min="1" max="10000" step="1">
                        </div>
                    `;
                    break;
                    
                case 'led':
                    formHTML = `
                        <div class="edit-row">
                            <label>? Forward Resistance (?)</label>
                            <input type="number" id="edit-resistance" value="${component.properties.resistance}" min="1" max="1000" step="1">
                        </div>
                    `;
                    break;
                    
                case 'switch':
                    formHTML = `
                        <div class="edit-row">
                            <label>?? Switch State</label>
                            <select id="edit-switch-state">
                                <option value="true" ${component.properties.isOn ? 'selected' : ''}>ON (Closed)</option>
                                <option value="false" ${!component.properties.isOn ? 'selected' : ''}>OFF (Open)</option>
                            </select>
                        </div>
                        <div class="edit-row">
                            <label>? Contact Resistance (?)</label>
                            <input type="number" id="edit-resistance" value="${component.properties.resistance}" min="0.01" max="10" step="0.01">
                        </div>
                    `;
                    break;
                    
                default:
                    formHTML = '<div class="edit-row">No editable properties</div>';
            }
            
            return formHTML;
        }

        function saveEdit() {
            if (!currentEditComponent) return;
            
            const popup = document.getElementById('edit-popup');
            if (!popup) return;
            
            saveState(); // Save for undo
            
            const newProperties = {};
            
            switch (currentEditComponent.type) {
                case 'battery':
                    const voltageInput = document.getElementById('edit-voltage');
                    if (voltageInput) {
                        newProperties.voltage = parseFloat(voltageInput.value) || 0;
                    }
                    break;
                    
                case 'resistor':
                case 'led':
                    const resistanceInput = document.getElementById('edit-resistance');
                    if (resistanceInput) {
                        newProperties.resistance = parseFloat(resistanceInput.value) || 1;
                    }
                    break;
                    
                case 'switch':
                    const switchStateSelect = document.getElementById('edit-switch-state');
                    const switchResistanceInput = document.getElementById('edit-resistance');
                    if (switchStateSelect) {
                        newProperties.isOn = switchStateSelect.value === 'true';
                    }
                    if (switchResistanceInput) {
                        newProperties.resistance = parseFloat(switchResistanceInput.value) || 0.1;
                    }
                    break;
            }
            
            // Update component properties
            currentEditComponent.updateProperties(newProperties);
            
            // Hide popup
            hideEditPopup();
            
            // Recalculate circuit
            analyzeCircuit();
            
            const componentType = currentEditComponent.type;
            setStatus(`? ${componentType.charAt(0).toUpperCase() + componentType.slice(1)} updated successfully!`);
        }

        function cancelEdit() {
            hideEditPopup();
            setStatus('? Edit cancelled');
        }

        function hideEditPopup() {
            const popup = document.getElementById('edit-popup');
            if (popup) {
                popup.style.display = 'none';
            }
            currentEditComponent = null;
        }

        function checkComponentHit(clientX, clientY) {
            // If we're in the middle of a long press, don't handle regular clicks
            if (isLongPressing) {
                return false;
            }
            
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((clientY - rect.top) / rect.height) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            
            // Check connection points
            const connectionPoints = [];
            components.forEach(comp => {
                if (comp?.connectionPoints) {
                    connectionPoints.push(...comp.connectionPoints);
                }
            });
            junctions.forEach(junction => {
                if (junction?.connectionPoint) {
                    connectionPoints.push(junction.connectionPoint);
                }
            });
            
            const connectionHits = raycaster.intersectObjects(connectionPoints, false);
            if (connectionHits.length > 0) {
                const hitPoint = connectionHits[0].object;
                if (hitPoint.userData?.isConnectionPoint) {
                    handleConnectionPointClick(hitPoint.userData);
                    return true;
                }
            }
            
            // Check component selection boxes
            if (!isWireMode) {
                const selectionBoxes = [];
                components.forEach(comp => {
                    if (comp?.selectionBox) {
                        selectionBoxes.push(comp.selectionBox);
                    }
                });
                junctions.forEach(junction => {
                    if (junction?.selectionSphere) {
                        selectionBoxes.push(junction.selectionSphere);
                    }
                });
                
                const componentHits = raycaster.intersectObjects(selectionBoxes, false);
                if (componentHits.length > 0) {
                    const hitBox = componentHits[0].object;
                    if (hitBox.userData?.component) {
                        handleComponentClick(hitBox.userData.component);
                        return true;
                    }
                    if (hitBox.userData?.junction) {
                        handleJunctionClick(hitBox.userData.junction);
                        return true;
                    }
                }
            }
            
            handleGroundClick(clientX, clientY);
            return false;
        }

        function handleConnectionPointClick(pointData) {
            if (!isWireMode) {
                const terminalInfo = getTerminalInfo(pointData);
                const objectType = pointData.component ? pointData.component.type : 'junction';
                setStatus(`?? ${objectType} ${terminalInfo} - Enable ?? Wire mode to connect!`);
                return;
            }
            
            if (!wireStart) {
                wireStart = pointData;
                highlightConnectionPoint(pointData, true);
                
                const terminalInfo = getTerminalInfo(pointData);
                const objectType = pointData.component ? pointData.component.type : 'junction';
                setStatus(`?? FIRST: ${objectType} ${terminalInfo} - Click another terminal!`);
                
            } else {
                const sameObject = (wireStart.component && pointData.component && wireStart.component === pointData.component) ||
                                  (wireStart.junction && pointData.junction && wireStart.junction === pointData.junction);
                
                if (sameObject) {
                    setStatus('? Cannot connect terminal to itself!');
                    return;
                }
                
                createWire(wireStart, pointData);
                highlightConnectionPoint(wireStart, false);
                wireStart = null;
            }
        }

        function createWire(startPoint, endPoint) {
            if (!startPoint || !endPoint) return;
            
            const startObj = startPoint.component || startPoint.junction;
            const endObj = endPoint.component || endPoint.junction;
            
            if (!startObj || !endObj) return;
            
            const existingWire = wires.find(wire => 
                (wire.startObj === startObj && wire.startSide === startPoint.side &&
                 wire.endObj === endObj && wire.endSide === endPoint.side) ||
                (wire.startObj === endObj && wire.startSide === endPoint.side &&
                 wire.endObj === startObj && wire.endSide === startPoint.side)
            );
            
            if (existingWire) {
                setStatus('? Wire already exists between these terminals');
                return;
            }
            
            try {
                saveState(); // Save for undo
                const wire = new Wire(startObj, startPoint.side, endObj, endPoint.side);
                wires.push(wire);
                
                const startType = startObj.type || 'junction';
                const endType = endObj.type || 'junction';
                setStatus(`? Wire connected ${startType} ? ${endType}!`);
                
                analyzeCircuit();
                
            } catch (error) {
                console.error('Wire creation error:', error);
                setStatus('? Wire creation failed');
            }
        }

        function getTerminalInfo(pointData) {
            if (pointData.junction) return 'JUNCTION (PURPLE)';
            
            switch (pointData.polarity) {
                case 'positive': return 'POSITIVE (RED)';
                case 'negative': return 'NEGATIVE (GRAY)';
                default: return 'NEUTRAL (WHITE)';
            }
        }

        function highlightConnectionPoint(pointData, highlight) {
            let connectionPoint;
            
            if (pointData.component) {
                connectionPoint = pointData.component.connectionPoints?.find(point => 
                    point.userData?.side === pointData.side
                );
            } else if (pointData.junction) {
                connectionPoint = pointData.junction.connectionPoint;
            }
            
            if (!connectionPoint?.material) return;
            
            if (highlight) {
                connectionPoint.material.color.setRGB(1.0, 1.0, 0.0);
                connectionPoint.material.emissive.setRGB(0.8, 0.8, 0.0);
                connectionPoint.scale.setScalar(2.0);
            } else {
                if (pointData.junction) {
                    connectionPoint.material.color.setRGB(0.67, 0.4, 1.0);
                    connectionPoint.material.emissive.setRGB(0.2, 0.1, 0.4);
                } else {
                    const originalColor = getOriginalColor(pointData.polarity);
                    connectionPoint.material.color.copy(originalColor);
                    setOriginalEmissive(connectionPoint, pointData.polarity);
                }
                connectionPoint.scale.setScalar(1.0);
            }
        }

        function getOriginalColor(polarity) {
            switch (polarity) {
                case 'positive': return new THREE.Color(1, 0, 0);
                case 'negative': return new THREE.Color(0.3, 0.3, 0.3);
                default: return new THREE.Color(1, 1, 1);
            }
        }

        function setOriginalEmissive(point, polarity) {
            switch (polarity) {
                case 'positive':
                    point.material.emissive.setRGB(0.3, 0.0, 0.0);
                    break;
                case 'negative':
                    point.material.emissive.setRGB(0.1, 0.1, 0.1);
                    break;
                default:
                    point.material.emissive.setRGB(0.2, 0.2, 0.2);
            }
        }

        function handleComponentClick(component) {
            if (isRotateMode) {
                saveState(); // Save for undo
                const rotationAmount = Math.PI / 2;
                component.rotation += rotationAmount;
                component.mesh.rotation.y = component.rotation;
                
                component.mesh.scale.setScalar(1.5);
                setTimeout(() => {
                    component.mesh.scale.setScalar(1.0);
                }, 500);
                
                const rotationDegrees = Math.round((component.rotation * 180 / Math.PI) % 360);
                setStatus(`?? ${component.type.toUpperCase()} ROTATED 90?! Now at ${rotationDegrees}?`);
                
                if (component.connections) {
                    component.connections.forEach(conn => {
                        if (conn.wire && conn.wire.updatePath) {
                            conn.wire.updatePath();
                        }
                    });
                }
                
                analyzeCircuit();
                
            } else if (component.type === 'switch' && !isWireMode) {
                saveState(); // Save for undo
                component.properties.isOn = !component.properties.isOn;
                component.updateProperties({ isOn: component.properties.isOn });
                const state = component.properties.isOn ? 'ON' : 'OFF';
                setStatus(`?? Switch ${state} - circuit updated`);
                analyzeCircuit();
            } else if (!isWireMode && !isDragging) {
                selectComponent(component);
            }
        }

        function handleJunctionClick(junction) {
            if (!isWireMode && !isDragging) {
                selectJunction(junction);
            }
        }

        function selectComponent(component) {
            selectedComponent = component;
            isDragging = true;
            setStatus(`?? Dragging ${component.type} - tap to place`);
        }

        function selectJunction(junction) {
            selectedComponent = junction;
            isDragging = true;
            setStatus(`?? Dragging junction - tap to place`);
        }

        function handleGroundClick(clientX, clientY) {
            if (!isWireMode) {
                const worldPos = screenToWorld(clientX, clientY);
                if (worldPos && selectedComponent && isDragging) {
                    const snappedPos = snapToGrid(worldPos);
                    
                    if (selectedComponent.mesh) {
                        selectedComponent.mesh.position.copy(snappedPos);
                        selectedComponent.position.copy(snappedPos);
                    }
                    
                    const placedComponent = selectedComponent;
                    handleRelease();
                    
                    const objType = placedComponent.type || 'junction';
                    setStatus(`?? ${objType} placed at grid position!`);
                    
                    if (placedComponent.connections) {
                        placedComponent.connections.forEach(conn => {
                            if (conn.wire && conn.wire.updatePath) {
                                conn.wire.updatePath();
                            }
                        });
                    }
                }
            }
        }

        function screenToWorld(clientX, clientY) {
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((clientY - rect.top) / rect.height) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            
            const groundPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
            const intersection = new THREE.Vector3();
            
            if (raycaster.ray.intersectPlane(groundPlane, intersection)) {
                return intersection;
            }
            return null;
        }

        function handleComponentDrag(clientX, clientY) {
            const worldPos = screenToWorld(clientX, clientY);
            if (worldPos && selectedComponent) {
                const snappedPos = snapToGrid(worldPos);
                showSnapIndicator(snappedPos);
                
                if (selectedComponent.mesh) {
                    selectedComponent.mesh.position.copy(snappedPos);
                    selectedComponent.position.copy(snappedPos);
                }
            }
        }

        function handleRelease() {
            isDragging = false;
            hideSnapIndicator();
            
            if (selectedComponent) {
                // Final snap to grid
                const snappedPos = snapToGrid(selectedComponent.position);
                selectedComponent.position.copy(snappedPos);
                if (selectedComponent.mesh) {
                    selectedComponent.mesh.position.copy(snappedPos);
                }
                
                // Update any connected wires
                if (selectedComponent.connections) {
                    selectedComponent.connections.forEach(conn => {
                        if (conn.wire && conn.wire.updatePath) {
                            conn.wire.updatePath();
                        }
                    });
                }
            }
            
            selectedComponent = null;
        }

        // Menu system functions
        function toggleMenuBar() {
            const menuBar = document.getElementById('menu-bar');
            const toggle = document.getElementById('menu-toggle');
            
            if (!menuBar || !toggle) return;
            
            menuBar.classList.toggle('hidden');
            menuVisible = !menuVisible;
            
            if (menuVisible) {
                toggle.textContent = '?';
                setStatus('?? Menu shown - all tools available');
            } else {
                toggle.textContent = '?';
                setStatus('?? Menu hidden - click ? to show');
                closeAllSubmenus();
            }
        }

        function toggleSubmenu(menuName) {
            const allSubmenus = document.querySelectorAll('.submenu');
            const targetSubmenu = document.getElementById(`submenu-${menuName}`);
            const allTabs = document.querySelectorAll('.menu-tab');
            
            // Close all other submenus
            allSubmenus.forEach(submenu => {
                if (submenu !== targetSubmenu) {
                    submenu.classList.remove('active');
                }
            });
            
            // Remove active class from all tabs
            allTabs.forEach(tab => {
                if (!tab.querySelector(`#submenu-${menuName}`)) {
                    tab.classList.remove('active');
                }
            });
            
            // Toggle target submenu
            if (targetSubmenu) {
                const isActive = targetSubmenu.classList.contains('active');
                targetSubmenu.classList.toggle('active');
                
                // Toggle tab active state
                const parentTab = targetSubmenu.closest('.menu-tab');
                if (parentTab) {
                    parentTab.classList.toggle('active', !isActive);
                }
            }
        }

        function openArena() {
            try {
                window.open('/arena', '_blank');
                setStatus('?? Component Arena opened');
            } catch (e) {
                setStatus('?? Unable to open Arena');
            }
        }

        function closeAllSubmenus() {
            document.querySelectorAll('.submenu').forEach(submenu => {
                submenu.classList.remove('active');
            });
            document.querySelectorAll('.menu-tab').forEach(tab => {
                tab.classList.remove('active');
            });
        }

        function toggleAnalysis() {
            const panel = document.getElementById('wire-analysis');
            if (!panel) {
                notifyParentAnalysisState();
                return;
            }
            
            panel.classList.toggle('collapsed');
            analysisVisible = !panel.classList.contains('collapsed');
            
            if (analysisVisible) {
                setStatus('?? W.I.R.E. Analysis panel expanded');
            } else {
                setStatus('?? W.I.R.E. Analysis panel collapsed');
            }

            notifyParentAnalysisState();
        }

        // State management functions
        function saveState() {
            const state = {
                components: components.map(comp => ({
                    type: comp.type,
                    position: comp.position.toArray(),
                    rotation: comp.rotation,
                    properties: comp.properties,
                    componentNumber: comp.componentNumber,
                    id: comp.id
                })),
                junctions: junctions.map(junction => ({
                    position: junction.position.toArray(),
                    id: junction.id
                })),
                wires: wires.map(wire => ({
                    startId: wire.startObj.id,
                    startSide: wire.startSide,
                    endId: wire.endObj.id,
                    endSide: wire.endSide,
                    id: wire.id
                })),
                componentCounters: { ...componentCounters }
            };
            
            undoStack.push(JSON.stringify(state));
            if (undoStack.length > 50) {
                undoStack.shift(); // Keep only last 50 states
            }
            redoStack = []; // Clear redo stack when new action is performed
            updateUndoRedoButtons();
        }

        function undo() {
            if (undoStack.length === 0) {
                setStatus('? Nothing to undo');
                return;
            }
            
            // Save current state to redo stack
            redoStack.push(getCurrentStateString());
            
            // Restore previous state
            const previousState = undoStack.pop();
            restoreState(JSON.parse(previousState));
            
            updateUndoRedoButtons();
            setStatus('? Undo completed');
        }

        function redo() {
            if (redoStack.length === 0) {
                setStatus('? Nothing to redo');
                return;
            }
            
            // Save current state to undo stack
            undoStack.push(getCurrentStateString());
            
            // Restore redo state
            const redoState = redoStack.pop();
            restoreState(JSON.parse(redoState));
            
            updateUndoRedoButtons();
            setStatus('? Redo completed');
        }

        function getCurrentStateString() {
            const state = {
                components: components.map(comp => ({
                    type: comp.type,
                    position: comp.position.toArray(),
                    rotation: comp.rotation,
                    properties: comp.properties,
                    componentNumber: comp.componentNumber,
                    id: comp.id
                })),
                junctions: junctions.map(junction => ({
                    position: junction.position.toArray(),
                    id: junction.id
                })),
                wires: wires.map(wire => ({
                    startId: wire.startObj.id,
                    startSide: wire.startSide,
                    endId: wire.endObj.id,
                    endSide: wire.endSide,
                    id: wire.id
                })),
                componentCounters: { ...componentCounters }
            };
            return JSON.stringify(state);
        }

        function restoreState(state) {
            // Clear current circuit
            clearAll(false); // Don't save state during clear
            
            // Restore component counters
            if (state.componentCounters) {
                componentCounters = { ...state.componentCounters };
            }
            
            // Restore components
            state.components.forEach(compData => {
                const position = new THREE.Vector3().fromArray(compData.position);
                const component = new Component(compData.type, position);
                component.rotation = compData.rotation;
                component.properties = compData.properties;
                component.id = compData.id;
                
                // Restore component numbering if available
                if (compData.componentNumber) {
                    component.componentNumber = compData.componentNumber;
                }
                
                component.mesh.rotation.y = component.rotation;
                component.updateProperties(component.properties);
                components.push(component);
            });
            
            // Restore junctions
            state.junctions.forEach(junctionData => {
                const position = new THREE.Vector3().fromArray(junctionData.position);
                const junction = new Junction(position);
                junction.id = junctionData.id;
                junctions.push(junction);
            });
            
            // Restore wires
            state.wires.forEach(wireData => {
                const startObj = [...components, ...junctions].find(obj => obj.id === wireData.startId);
                const endObj = [...components, ...junctions].find(obj => obj.id === wireData.endId);
                
                if (startObj && endObj) {
                    const wire = new Wire(startObj, wireData.startSide, endObj, wireData.endSide);
                    wire.id = wireData.id;
                    wires.push(wire);
                }
            });
            
            analyzeCircuit();
            updateCircuitInfo();
        }

        function updateUndoRedoButtons() {
            const undoBtn = document.getElementById('undo-btn');
            const redoBtn = document.getElementById('redo-btn');
            
            if (undoBtn) {
                undoBtn.style.opacity = undoStack.length > 0 ? '1.0' : '0.5';
                undoBtn.disabled = undoStack.length === 0;
            }
            
            if (redoBtn) {
                redoBtn.style.opacity = redoStack.length > 0 ? '1.0' : '0.5';
                redoBtn.disabled = redoStack.length === 0;
            }
        }

        // File operations
        function saveCircuit() {
            const state = {
                components: components.map(comp => ({
                    type: comp.type,
                    position: comp.position.toArray(),
                    rotation: comp.rotation,
                    properties: comp.properties,
                    componentNumber: comp.componentNumber,
                    id: comp.id
                })),
                junctions: junctions.map(junction => ({
                    position: junction.position.toArray(),
                    id: junction.id
                })),
                wires: wires.map(wire => ({
                    startId: wire.startObj.id,
                    startSide: wire.startSide,
                    endId: wire.endObj.id,
                    endSide: wire.endSide,
                    id: wire.id
                })),
                componentCounters: { ...componentCounters },
                metadata: {
                    created: new Date().toISOString(),
                    app: 'W.I.R.E. Circuit Builder',
                    version: '2.0'
                }
            };
            
            const dataStr = JSON.stringify(state, null, 2);
            const dataBlob = new Blob([dataStr], {type: 'application/json'});
            
            const link = document.createElement('a');
            link.href = URL.createObjectURL(dataBlob);
            link.download = `circuit_${new Date().toISOString().slice(0,19).replace(/:/g, '-')}.json`;
            link.click();
            
            setStatus('?? Circuit saved with W.I.R.E. labels and component numbering!');
        }

        function loadCircuit() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            
            input.onchange = function(event) {
                const file = event.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const state = JSON.parse(e.target.result);
                        restoreState(state);
                        setStatus('?? Circuit loaded successfully with W.I.R.E. labels!');
                    } catch (error) {
                        console.error('Load error:', error);
                        setStatus('? Failed to load circuit file');
                    }
                };
                reader.readAsText(file);
            };
            
            input.click();
        }

        function newCircuit() {
            if (components.length > 0 || wires.length > 0 || junctions.length > 0) {
                if (confirm('Create new circuit? This will clear your current work.')) {
                    clearAll();
                    setStatus('?? New circuit created');
                }
            } else {
                setStatus('?? Circuit is already empty');
            }
        }

        function exportImage() {
            // Temporarily hide UI elements
            const menuBar = document.getElementById('menu-bar');
            const wireAnalysis = document.getElementById('wire-analysis');
            const status = document.getElementById('status');
            const menuToggle = document.getElementById('menu-toggle');
            
            menuBar.style.display = 'none';
            wireAnalysis.style.display = 'none';
            status.style.display = 'none';
            menuToggle.style.display = 'none';
            
            // Render and export
            renderer.render(scene, camera);
            
            const link = document.createElement('a');
            link.download = `circuit_export_${new Date().toISOString().slice(0,19).replace(/:/g, '-')}.png`;
            link.href = renderer.domElement.toDataURL();
            link.click();
            
            // Restore UI elements
            menuBar.style.display = 'block';
            wireAnalysis.style.display = 'block';
            menuToggle.style.display = 'flex';
            
            setStatus('??? Circuit image exported!');
        }

        // Selection and clipboard functions
        function selectAll() {
            selectedComponents.clear();
            components.forEach(comp => selectedComponents.add(comp));
            junctions.forEach(junction => selectedComponents.add(junction));
            
            setStatus(`?? Selected ${selectedComponents.size} objects`);
        }

        function copySelected() {
            if (selectedComponents.size === 0) {
                setStatus('? No objects selected to copy');
                return;
            }
            
            clipboard = {
                components: [],
                junctions: [],
                wires: []
            };
            
            selectedComponents.forEach(obj => {
                if (obj.type) { // Component
                    clipboard.components.push({
                        type: obj.type,
                        position: obj.position.toArray(),
                        rotation: obj.rotation,
                        properties: obj.properties,
                        originalId: obj.id
                    });
                } else if (obj.id && obj.id.startsWith('junction')) { // Junction
                    clipboard.junctions.push({
                        position: obj.position.toArray(),
                        originalId: obj.id
                    });
                }
            });
            
            setStatus(`?? Copied ${selectedComponents.size} objects`);
        }

        function pasteSelected() {
            if (!clipboard || (clipboard.components.length === 0 && clipboard.junctions.length === 0)) {
                setStatus('? Nothing to paste');
                return;
            }
            
            selectedComponents.clear();
            const offset = new THREE.Vector3(2, 0, 2); // Offset for pasted objects
            
            // Paste components
            clipboard.components.forEach(compData => {
                const position = new THREE.Vector3().fromArray(compData.position).add(offset);
                const component = new Component(compData.type, position);
                component.rotation = compData.rotation;
                component.properties = { ...compData.properties };
                component.mesh.rotation.y = component.rotation;
                component.updateProperties(component.properties);
                components.push(component);
                selectedComponents.add(component);
            });
            
            // Paste junctions
            clipboard.junctions.forEach(junctionData => {
                const position = new THREE.Vector3().fromArray(junctionData.position).add(offset);
                const junction = new Junction(position);
                junctions.push(junction);
                selectedComponents.add(junction);
            });
            
            updateCircuitInfo();
            setStatus(`?? Pasted ${selectedComponents.size} objects`);
        }

        function deleteSelected() {
            if (selectedComponents.size === 0) {
                setStatus('? No objects selected to delete');
                return;
            }
            
            saveState(); // Save for undo
            
            selectedComponents.forEach(obj => {
                if (obj.remove) {
                    obj.remove();
                }
            });
            
            selectedComponents.clear();
            updateCircuitInfo();
            setStatus('??? Selected objects deleted');
        }

        // View functions
        function resetCamera() {
            cameraDistance = 15;
            cameraAngleX = 0;
            cameraAngleY = 0.5;
            cameraTarget.set(0, 0, 0);
            updateCameraPosition();
            setStatus('?? Camera view reset');
        }

        function fitToScreen() {
            if (components.length === 0 && junctions.length === 0) {
                resetCamera();
                return;
            }
            
            // Calculate bounding box of all objects
            const box = new THREE.Box3();
            components.forEach(comp => {
                if (comp.mesh) box.expandByObject(comp.mesh);
            });
            junctions.forEach(junction => {
                if (junction.mesh) box.expandByObject(junction.mesh);
            });
            
            const center = box.getCenter(new THREE.Vector3());
            const size = box.getSize(new THREE.Vector3());
            const maxDim = Math.max(size.x, size.y, size.z);
            
            cameraTarget.copy(center);
            cameraDistance = Math.max(10, maxDim * 2);
            updateCameraPosition();
            
            setStatus('?? View fitted to circuit');
        }

        function toggleGrid() {
            if (gridHelper) {
                gridHelper.visible = !gridHelper.visible;
                showGrid = gridHelper.visible;
                
                // Also toggle the fine grid
                const fineGrid = scene.children.find(child => 
                    child.type === 'GridHelper' && child !== gridHelper
                );
                if (fineGrid) {
                    fineGrid.visible = gridHelper.visible;
                }
                
                setStatus(`? Grid ${showGrid ? 'shown' : 'hidden'} - Components snap to grid points`);
            }
        }

        function toggleLabels() {
            showLabels = !showLabels;
            components.forEach(component => {
                if (component.labelDiv) {
                    component.labelDiv.style.display = showLabels ? 'block' : 'none';
                }
            });
            setStatus(`??? Component labels ${showLabels ? 'enabled' : 'disabled'}`);
        }
        
        // Toggle current flow visualization style
        function toggleCurrentFlowStyle() {
            currentFlowStyle = currentFlowStyle === 'misty' ? 'solid' : 'misty';
            const styleLabel = document.getElementById('flow-style');
            if (styleLabel) {
                styleLabel.textContent = currentFlowStyle === 'misty' ? 'Electron Flow' : 'Current Flow';
            }
            
            // Re-animate current flow with new style
            const result = performCircuitAnalysis();
            if (result.isComplete && result.current > 0) {
                animateCurrentFlow(true, result.current);
            }
            
            setStatus(`?? Flow: ${currentFlowStyle === 'misty' ? 'ELECTRON FLOW - Probabilistic quantum cloud showing electron movement (- to +)' : 'CURRENT FLOW - Conventional current direction (+ to -)'}`);
        }
        
        // Toggle polarity indicators
        function togglePolarityIndicators() {
            showPolarityIndicators = !showPolarityIndicators;
            
            // Update all component polarity displays
            components.forEach(component => {
                if (component.updatePolarityDisplay) {
                    component.updatePolarityDisplay(showPolarityIndicators);
                }
            });
            
            setStatus(`? Polarity indicators ${showPolarityIndicators ? 'shown' : 'hidden'}`);
        }
        
        // Toggle branding overlay
        function toggleBranding() {
            const brandingEl = document.getElementById('branding-overlay');
            if (brandingEl) {
                if (brandingEl.style.display === 'none') {
                    brandingEl.style.display = 'block';
                    setStatus('??? CircuiTry3D branding shown');
                } else {
                    brandingEl.style.display = 'none';
                    setStatus('??? CircuiTry3D branding hidden');
                }
            }
        }
        
        // Cycle through layout modes
        function cycleLayoutMode() {
            const modes = ['free', 'square', 'linear'];
            const currentIndex = modes.indexOf(layoutMode);
            const nextIndex = (currentIndex + 1) % modes.length;
            layoutMode = modes[nextIndex];
            
            const layoutLabel = document.getElementById('layout-mode');
            if (layoutLabel) {
                const modeNames = {
                    'free': 'Free',
                    'square': 'Square',
                    'linear': 'Linear'
                };
                layoutLabel.textContent = modeNames[layoutMode];
            }
            
            setStatus(`?? Layout mode: ${layoutMode.toUpperCase()} - ${getLayoutModeDescription(layoutMode)}`);
        }
        
        function getLayoutModeDescription(mode) {
            const descriptions = {
                'free': 'Place components anywhere',
                'square': 'Textbook-style square circuits',
                'linear': 'Tree layout with battery at top'
            };
            return descriptions[mode] || '';
        }

        // Help functions
        function showTutorial() {
            const tutorial = `
?? CIRCUITRY3D QUICK START GUIDE

???????????????????????????????????????

?? GETTING STARTED:

1?? ADD COMPONENTS (?? Components menu):
   ? Battery (B key) - Power source
   ? Resistor (R key) - Limit current
   ? LED (L key) - Light indicator
   ? Switch (S key) - Control flow
   ? All components show real-time values

2?? CONNECT WITH WIRES (??? Tools menu):
   ? Click "?? Wire" button (or W key)
   ? Touch component terminals to connect
   ? Complete the circuit loop for current flow

3?? VIEW CALCULATIONS (panels on right):
   ? ?? W.I.R.E. - Main electrical values
   ? ?? EIR ? - Ohm's Law triangle
   ? ? Power ? - Power calculations
   ? ?? Worksheet - Step-by-step formulas
   ? ? Solve - Check your answers

???????????????????????????????????????

?? VISUAL LEARNING:

??? COLOR-CODED VALUES:
   ?? Blue = Power (Watts)
   ?? Orange = Current (Amps)
   ?? Green = Resistance (Ohms)
   ?? Red = Voltage (Volts)

?? FLOW VISUALIZATION (View menu):
   ? Electron Flow: Shows actual electron movement
     (negative ? positive, semi-transparent particles)
   ? Current Flow: Shows conventional direction
     (positive ? negative, solid particles)
   ? Toggle: View ? ?? Flow

? POLARITY INDICATORS:
   ? Red (+) and Blue (-) terminals
   ? Prevents incorrect connections
   ? Toggle: View ? ? Polarity

???????????????????????????????????????

?? ADVANCED FEATURES:

?? ROUTING MODES (??? Tools menu):
   ? Free-form: Natural connections
   ? Manhattan: Textbook right-angles
   ? Toggle: Tools ? ?? Route

? JUNCTIONS (for parallel circuits):
   ? Add via Tools ? ? Junction (or J key)
   ? Click to place on workspace
   ? Connect multiple wires at one point

?? AUTO-ARRANGE:
   ? Tools ? ?? Auto-Arrange
   ? Automatically creates textbook layouts
   ? Perfect for practice problems

?? LAYOUT MODES (View menu):
   ? Free: Place anywhere
   ? Square: Textbook style
   ? Linear: Vertical tree
   ? Toggle: View ? ?? Layout

???????????????????????????????????????

?? CONTROLS:

MOUSE/TOUCH:
   ? Drag: Move components
   ? Long-press: Edit values/properties
   ? Two-finger pinch: Zoom
   ? Two-finger drag: Pan workspace

KEYBOARD SHORTCUTS:
   ? B = Battery, R = Resistor
   ? L = LED, S = Switch, J = Junction
   ? W = Wire Mode, T = Rotate Mode
   ? Space = Toggle Menu

VIEW CONTROLS (??? View menu):
   ? Reset View: Center camera
   ? Fit Screen: Auto-zoom to circuit
   ? Toggle Grid: Show/hide snap grid
   ? Labels: Show/hide component names

???????????????????????????????????????

?? TIPS:
? Complete the circuit loop for current to flow
? Open switches stop current flow
? Use junctions for parallel circuits
? Long-press wires to delete or reroute
? Try different routing modes for cleaner layouts

Need more help? Check:
? ?? W.I.R.E. Guide - Electrical concepts
? ?? Shortcuts - Full keyboard reference
? ?? About - Version info & features
            `;
            alert(tutorial);
        }

        function showWireGuide() {
            const guide = `
?? W.I.R.E. METHOD EXPLAINED

???????????????????????????????????????

The W.I.R.E. method helps you remember the four key electrical values:

W = WATTS (Power) ?? BLUE
????????????????????????
? Formula: P = V ? I
? What it means: Energy used per second
? In circuits: How much work electricity does
? Example: 60W light bulb uses 60 joules/second
? Higher power = brighter light, more heat

I = CURRENT (Amperes) ?? ORANGE
????????????????????????
? Formula: I = V / R (Ohm's Law)
? What it means: Flow rate of electrons
? In circuits: Like water flow in a pipe
? Visualized: Animated particles in wires
? Measured in Amperes (Amps)

R = RESISTANCE (Ohms) ?? GREEN
????????????????????????
? Formula: R = V / I
? What it means: Opposition to current flow
? In circuits: Like pipe narrowness
? Components: Resistors, LEDs (have resistance)
? Higher resistance = less current

E = EMF/VOLTAGE (Volts) ?? RED
????????????????????????
? Formula: V = I ? R
? What it means: Electrical pressure
? In circuits: Like water pressure in pipes
? Source: Battery provides voltage
? Higher voltage = more current (if R same)

???????????????????????????????????????

?? KEY FORMULAS:

OHM'S LAW TRIANGLE (EIR ?):
   E (Voltage)
      /\
     /  \
    /____\
   I    R
   
? V = I ? R  (Voltage = Current ? Resistance)
? I = V / R  (Current = Voltage / Resistance)
? R = V / I  (Resistance = Voltage / Current)

POWER TRIANGLE (Power ?):
   P (Watts)
      /\
     /  \
    /____\
   V    I
   
? P = V ? I  (Power = Voltage ? Current)
? P = I?R    (Power = Current? ? Resistance)
? P = V?/R   (Power = Voltage? / Resistance)

???????????????????????????????????????

?? PRACTICE TIPS:

1. Build simple circuits to see W.I.R.E. in action
2. Watch how values change when you:
   - Add resistors (R increases)
   - Change battery voltage (E changes)
   - Add parallel paths (total R decreases)
3. Use the panels on right to see calculations
4. Try Practice Mode for guided problems

?? REMEMBER: All values are connected!
   Change one, and others adjust automatically.
            `;
            alert(guide);
        }

        function showShortcuts() {
            const shortcuts = `
?? KEYBOARD & MOUSE CONTROLS

???????????????????????????????????????

?? COMPONENT SHORTCUTS:
   B = Add Battery
   R = Add Resistor
   L = Add LED
   S = Add Switch
   J = Add Junction

??? TOOL SHORTCUTS:
   W = Toggle Wire Mode
   T = Toggle Rotate Mode
   Space = Toggle Menu
   Esc = Close menu/Cancel mode

?? EDIT SHORTCUTS:
   Ctrl+Z = Undo
   Ctrl+Y = Redo
   Ctrl+C = Copy selected
   Ctrl+V = Paste
   Delete = Delete selected
   Backspace = Delete selected

?? FILE SHORTCUTS:
   Ctrl+S = Save Circuit
   Ctrl+O = Load Circuit
   Ctrl+N = New Circuit

??? VIEW SHORTCUTS:
   H = Reset Camera
   F = Fit to Screen
   G = Toggle Grid

???????????????????????????????????????

??? MOUSE CONTROLS:

BASIC ACTIONS:
   Click = Select component
   Drag = Move component
   Scroll = Zoom in/out
   Right-click = Context menu

WIRE MODE:
   Click terminal ? Click terminal = Create wire
   Click junction ? Click junction = Wire between junctions
   Esc = Exit wire mode

ROTATE MODE:
   Click component = Rotate 90?
   Esc = Exit rotate mode

EDITING:
   Long-press component = Edit properties
   Long-press wire = Delete or reroute
   Double-click = Quick edit

???????????????????????????????????????

?? TOUCH CONTROLS (Mobile/Tablet):

ONE FINGER:
   Tap = Select component
   Drag = Move component
   Long-press = Edit properties/values

TWO FINGERS:
   Pinch = Zoom in/out
   Drag = Pan workspace
   Rotate = Rotate view

WIRE CONNECTIONS:
   Tap terminal in wire mode = Connect
   Long-press wire = Edit/delete menu

???????????????????????????????????????

?? PRO TIPS:

? Hold Shift while dragging = Disable grid snap
? Use arrow keys = Fine-tune component position
? Middle-click drag = Pan workspace (desktop)
? Ctrl+Scroll = Zoom faster
? Double-tap = Quick component edit (mobile)

???????????????????????????????????????

?? QUICK WORKFLOW:

1. Press B = Add battery
2. Press R = Add resistor
3. Press W = Enter wire mode
4. Click terminals = Connect
5. Space = Toggle menu to see results

Fast circuit building with keyboard shortcuts!
            `;
            alert(shortcuts);
        }

        function showAbout() {
            const about = `
?? CIRCUITRY3D - W.I.R.E. CIRCUIT BUILDER

???????????????????????????????????????

?? VERSION 2.5 - ENHANCED EDITION

?? Educational 3D Circuit Simulator
   Built with Three.js & W.I.R.E. methodology
   Perfect for visual learners!

???????????????????????????????????????

? CORE FEATURES:

?? CIRCUIT BUILDING:
   ? Interactive 3D environment
   ? Real-time electrical calculations
   ? Color-coded values (W.I.R.E.)
   ? Auto-labeling (B1, R1, LED1, SW1)
   ? Grid snapping (toggle on/off)

?? VISUALIZATION:
   ? Electron Flow mode (semi-transparent)
   ? Current Flow mode (solid particles)
   ? Animated current through wires
   ? Polarity indicators (+/?)
   ? Transparent branding overlay

?? FLEXIBLE WIRING:
   ? Free-form: Natural connections
   ? Manhattan: Textbook right-angles
   ? Simple, Perimeter, A*: Advanced routing
   ? Smart junction placement
   ? Long-press wire editing

?? LAYOUT OPTIONS:
   ? Free: Place components anywhere
   ? Square: Textbook-style circuits
   ? Linear: Vertical tree layout
   ? Auto-arrange for instant layouts

???????????????????????????????????????

?? EDUCATIONAL TOOLS:

W.I.R.E. PANELS:
   ?? W.I.R.E. - Main electrical values
   ?? EIR ? - Ohm's Law triangle
   ? Power ? - Power calculations
   ?? Worksheet - Step-by-step formulas
   ? Solve - Answer verification

PRACTICE MODE:
   ? Guided circuit problems
   ? Series, Parallel, Combination circuits
   ? Switch circuits
   ? Random problem generator
   ? Step-by-step solutions

???????????????????????????????????????

?? PURPOSE & PEDAGOGY:

CircuiTry3D teaches electrical engineering
fundamentals through hands-on experimentation
with virtual circuits. 

The W.I.R.E. method provides a memorable
framework for understanding:
   ?? Watts (Power) - Blue
   ?? Current (Amperes) - Orange
   ?? Resistance (Ohms) - Green
   ?? EMF/Voltage (Volts) - Red

Visual, interactive learning makes abstract
concepts concrete and accessible!

???????????????????????????????????????

?? PLATFORM SUPPORT:

DESKTOP:
   ? Full keyboard & mouse support
   ? High-performance 3D rendering
   ? All features available

MOBILE/TABLET:
   ? Touch-optimized controls
   ? Two-finger zoom & pan
   ? Long-press editing
   ? Responsive interface

???????????????????????????????????????

?? TECHNICAL DETAILS:

Built with:
   ? Three.js - 3D graphics
   ? JavaScript - Core logic
   ? HTML5 Canvas - Rendering
   ? CSS3 - Interface styling

Features:
   ? Real-time circuit simulation
   ? Graph-based topology detection
   ? Multiple routing algorithms
   ? Persistent local storage
   ? Import/export circuits

???????????????????????????????????????

?? FOR STUDENTS & EDUCATORS:

STUDENTS:
   ? Learn by doing
   ? Instant visual feedback
   ? Practice problems included
   ? Export circuits for homework
   ? Mobile-friendly for anywhere learning

EDUCATORS:
   ? Create example circuits easily
   ? Professional layouts automatically
   ? W.I.R.E. methodology built-in
   ? Free to use in classroom
   ? No installation required

???????????????????????????????????????

?? SUPPORT & FEEDBACK:

Found a bug? Have a suggestion?
Visit: github.com/Mitchelllorin/CircuiTry3D

? 2025 CircuiTry3D
W.I.R.E. Circuit Builder v2.5

Made with ? for visual learners everywhere!
            `;
            alert(about);
        }

        // UI Functions
        function addComponent(type) {
            saveState(); // Save for undo
            
            if (isDragging || selectedComponent) {
                isDragging = false;
                selectedComponent = null;
                hideSnapIndicator();
            }
            
            const position = snapToGrid(new THREE.Vector3(
                (Math.random() - 0.5) * 10,
                0,
                (Math.random() - 0.5) * 10
            ));
            
            const component = new Component(type, position);
            components.push(component);
            selectComponent(component);
            
            setStatus(`? ${type} added - drag to grid position, tap to place, long press to edit values`);
            updateCircuitInfo();
            closeAllSubmenus();
        }

        function addJunction() {
            saveState(); // Save for undo
            
            if (isDragging || selectedComponent) {
                isDragging = false;
                selectedComponent = null;
                hideSnapIndicator();
            }
            
            const position = snapToGrid(new THREE.Vector3(
                (Math.random() - 0.5) * 10,
                0,
                (Math.random() - 0.5) * 10
            ));
            
            const junction = new Junction(position);
            junctions.push(junction);
            
            selectJunction(junction);
            
            setStatus(`? Junction node added - drag to grid position and tap to place!`);
            updateCircuitInfo();
            closeAllSubmenus();
        }
        
        // Split a wire by adding a junction at a specific point
        function splitWireWithJunction(wire, position) {
            if (!wire || !position) return null;
            
            saveState(); // Save for undo
            
            // Create junction at the split point
            const junction = new Junction(position);
            junctions.push(junction);
            
            // Store original wire info
            const startObj = wire.startObj;
            const startSide = wire.startSide;
            const endObj = wire.endObj;
            const endSide = wire.endSide;
            
            // Remove the original wire
            wire.remove();
            const wireIndex = wires.indexOf(wire);
            if (wireIndex > -1) {
                wires.splice(wireIndex, 1);
            }
            
            // Create two new wires: start -> junction and junction -> end
            const wire1 = new Wire(startObj, startSide, junction, 'center');
            const wire2 = new Wire(junction, 'center', endObj, endSide);
            
            wires.push(wire1, wire2);
            
            analyzeCircuit();
            updateCircuitInfo();
            
            setStatus('?? Wire split with junction - now you can branch from this point!');
            return junction;
        }

        // Create an equal-spaced parallel bus from a source to N targets (intelligent split)
        // This uses the new intelligent splitting logic for textbook-style parallel circuits
        function createParallelBus(sourceObj, targetObjs) {
            if (!sourceObj || !targetObjs || targetObjs.length === 0) return;
            
            // Use the new intelligent split function
            const result = createIntelligentSplit(sourceObj, targetObjs, 'parallel');
            
            // Analyze and update the circuit
            analyzeCircuit();
            updateCircuitInfo();
            
            setStatus(`? Created textbook-style parallel circuit with ${targetObjs.length} branches`);
        }

        function toggleWireMode() {
            isWireMode = !isWireMode;
            isRotateMode = false;
            
            if (wireStart) {
                highlightConnectionPoint(wireStart, false);
                wireStart = null;
            }
            
            updateButtonStates();
            closeAllSubmenus();
            
            if (isWireMode) {
                setStatus('?? WIRE MODE! Touch terminals to connect components');
            } else {
                setStatus('?? Wire mode disabled');
            }
        }

        function toggleRotateMode() {
            isRotateMode = !isRotateMode;
            isWireMode = false;
            
            if (wireStart) {
                highlightConnectionPoint(wireStart, false);
                wireStart = null;
            }
            
            updateButtonStates();
            closeAllSubmenus();
            
            if (isRotateMode) {
                setStatus('?? ROTATE MODE! Touch any component to rotate it 90?');
            } else {
                setStatus('?? Rotate mode disabled');
            }
        }

        function updateButtonStates() {
            try {
                const wireBtn = document.getElementById('wire-btn');
                const rotateBtn = document.getElementById('rotate-btn');
                
                if (wireBtn) wireBtn.classList.toggle('active', isWireMode);
                if (rotateBtn) rotateBtn.classList.toggle('active', isRotateMode);
                
                updateUndoRedoButtons();
            } catch (error) {
                console.warn('Button state update error:', error);
            }
        }



        // Circuit analysis
        function analyzeCircuit() {
            const batteries = components.filter(c => c.type === 'battery');
            
            if (batteries.length === 0) {
                updateCircuitDisplay(0, 0, Infinity, 0);
                animateCurrentFlow(false, 0);
                setStatus('?? ADD A BATTERY to start W.I.R.E. analysis!');
                return;
            }
            
            if (wires.length === 0) {
                const totalVoltage = batteries.reduce((sum, bat) => sum + bat.properties.voltage, 0);
                updateCircuitDisplay(totalVoltage, 0, Infinity, 0);
                animateCurrentFlow(false, 0);
                setStatus('?? ADD WIRES to complete the circuit for W.I.R.E. calculations!');
                return;
            }
            
            const result = performCircuitAnalysis();
            updateCircuitDisplay(result.voltage, result.current, result.resistance, result.power);
            
            const shouldAnimate = result.isComplete && result.current > 0;
            
            if (shouldAnimate) {
                animateCurrentFlow(true, result.current);
            } else {
                animateCurrentFlow(false, result.current);
            }
        }

        function performCircuitAnalysis() {
            const batteries = components.filter(c => c.type === 'battery');
            const resistors = components.filter(c => c.type === 'resistor' || c.type === 'led');
            const switches = components.filter(c => c.type === 'switch');
            
            const openSwitches = switches.filter(sw => !sw.properties.isOn);
            if (openSwitches.length > 0) {
                const totalVoltage = batteries.reduce((sum, bat) => sum + bat.properties.voltage, 0);
                updateTopologyDisplay('Open Circuit');
                return {
                    voltage: totalVoltage,
                    current: 0,
                    resistance: Infinity,
                    power: 0,
                    isComplete: false
                };
            }
            
            const connectedComponents = new Set();
            wires.forEach(wire => {
                connectedComponents.add(wire.startObj);
                connectedComponents.add(wire.endObj);
            });
            
            const connectedBatteries = batteries.filter(battery => connectedComponents.has(battery));
            
            // Check if we have batteries and they form a closed circuit
            if (connectedBatteries.length > 0 && connectedComponents.size >= 2) {
                // Verify the circuit is actually closed (has a complete path)
                const hasClosedPath = connectedBatteries.some(battery => 
                    hasClosedCircuitPath(battery, wires, components)
                );
                
                if (!hasClosedPath) {
                    // Circuit has components but no closed loop
                    const totalVoltage = batteries.reduce((sum, bat) => sum + bat.properties.voltage, 0);
                    updateTopologyDisplay('Incomplete');
                    return {
                        voltage: totalVoltage,
                        current: 0,
                        resistance: Infinity,
                        power: 0,
                        isComplete: false
                    };
                }
                
                let totalVoltage = 0;
                batteries.forEach(battery => totalVoltage += battery.properties.voltage);
                
                // Detect circuit topology
                const topology = detectCircuitTopology(resistors, wires, junctions);
                
                // Calculate resistance based on topology
                let totalResistance = 0.01; // Wire resistance
                
                if (topology.type === 'series') {
                    // Series: R_total = R1 + R2 + ... + Rn
                    resistors.forEach(resistor => {
                        totalResistance += resistor.properties.resistance || 100;
                    });
                } else if (topology.type === 'parallel') {
                    // Parallel: 1/R_total = 1/R1 + 1/R2 + ... + 1/Rn
                    let reciprocalSum = 0;
                    resistors.forEach(resistor => {
                        const r = resistor.properties.resistance || 100;
                        reciprocalSum += 1 / r;
                    });
                    totalResistance += (reciprocalSum > 0) ? (1 / reciprocalSum) : 100;
                } else if (topology.type === 'combination') {
                    // For combination circuits, calculate series and parallel groups separately
                    totalResistance += calculateCombinationResistance(topology);
                } else {
                    // Unknown or simple circuit - use basic addition
                    resistors.forEach(resistor => {
                        totalResistance += resistor.properties.resistance || 100;
                    });
                }
                
                // Add switch resistance
                switches.forEach(sw => {
                    if (sw.properties.isOn) {
                        totalResistance += sw.properties.resistance || 0.1;
                    }
                });
                
                const current = totalVoltage / totalResistance;
                const power = totalVoltage * current;
                
                updateTopologyDisplay(topology.type);
                
                return {
                    voltage: totalVoltage,
                    current: current,
                    resistance: totalResistance,
                    power: power,
                    isComplete: true
                };
            } else {
                const totalVoltage = batteries.reduce((sum, bat) => sum + bat.properties.voltage, 0);
                updateTopologyDisplay(connectedComponents.size === 0 ? 'No Circuit' : 'Incomplete');
                return {
                    voltage: totalVoltage,
                    current: 0,
                    resistance: Infinity,
                    power: 0,
                    isComplete: false
                };
            }
        }
        
        // Detect whether circuit is series, parallel, or combination
        function detectCircuitTopology(resistors, wires, junctions) {
            if (resistors.length === 0) {
                return { type: 'none', groups: [] };
            }
            
            // If there are junctions, likely parallel or combination
            if (junctions.length > 0) {
                // Check if junctions create parallel paths
                const hasParallelPaths = checkForParallelPaths(resistors, wires, junctions);
                if (hasParallelPaths) {
                    return { type: 'parallel', groups: [] };
                }
                return { type: 'combination', groups: [] };
            }
            
            // No junctions - check connection pattern
            // If all resistors are in a single chain, it's series
            if (resistors.length === 1) {
                return { type: 'series', groups: [resistors] };
            }
            
            // Check if all resistors are connected in sequence
            const isSeriesChain = checkSeriesConnection(resistors, wires);
            if (isSeriesChain) {
                return { type: 'series', groups: [resistors] };
            }
            
            return { type: 'simple', groups: [] };
        }
        
        // Check if resistors are connected in series (one after another)
        function checkSeriesConnection(resistors, wires) {
            if (resistors.length < 2) return true;
            
            // Build connection map
            const connectionMap = new Map();
            resistors.forEach(r => connectionMap.set(r, []));
            
            wires.forEach(wire => {
                if (resistors.includes(wire.startObj) && resistors.includes(wire.endObj)) {
                    connectionMap.get(wire.startObj).push(wire.endObj);
                    connectionMap.get(wire.endObj).push(wire.startObj);
                }
            });
            
            // In series, each resistor should connect to at most 2 other resistors
            // and they should form a single chain
            for (const [resistor, connections] of connectionMap) {
                if (connections.length > 2) return false; // Branching indicates not pure series
            }
            
            return true;
        }
        
        // Check if there are parallel current paths
        function checkForParallelPaths(resistors, wires, junctions) {
            // If there are junctions and multiple resistors, likely parallel
            if (junctions.length > 1 && resistors.length > 1) {
                // Count paths between junction pairs
                for (let i = 0; i < junctions.length; i++) {
                    for (let j = i + 1; j < junctions.length; j++) {
                        const paths = findPathsBetween(junctions[i], junctions[j], wires, resistors);
                        if (paths.length > 1) {
                            return true; // Multiple paths = parallel
                        }
                    }
                }
            }
            return false;
        }
        
        // Find all paths between two nodes
        function findPathsBetween(start, end, wires, throughComponents) {
            const paths = [];
            const visited = new Set();
            
            function dfs(current, path) {
                if (current === end) {
                    paths.push([...path]);
                    return;
                }
                
                visited.add(current);
                
                const connectedWires = wires.filter(w => 
                    w.startObj === current || w.endObj === current
                );
                
                for (const wire of connectedWires) {
                    const next = wire.startObj === current ? wire.endObj : wire.startObj;
                    if (!visited.has(next)) {
                        path.push(next);
                        dfs(next, path);
                        path.pop();
                    }
                }
                
                visited.delete(current);
            }
            
            dfs(start, [start]);
            return paths;
        }
        
        // Check if there's a complete circuit path from battery positive to negative
        function hasClosedCircuitPath(battery, wires, allComponents) {
            if (!battery || wires.length === 0) return false;
            
            // Build adjacency graph of all connections
            const graph = new Map();
            
            // Add all components and junctions to graph
            allComponents.forEach(comp => graph.set(comp, []));
            junctions.forEach(j => graph.set(j, []));
            
            // Build connections from wires
            wires.forEach(wire => {
                const start = wire.startObj;
                const end = wire.endObj;
                
                if (!graph.has(start)) graph.set(start, []);
                if (!graph.has(end)) graph.set(end, []);
                
                graph.get(start).push(end);
                graph.get(end).push(start);
            });
            
            // Check if we can reach back to the battery from any connected component
            // This creates a closed loop
            const visited = new Set();
            const startConnections = graph.get(battery) || [];
            
            if (startConnections.length === 0) return false;
            
            // For each initial connection from battery, try to find path back
            for (const firstConnection of startConnections) {
                visited.clear();
                visited.add(battery); // Don't revisit battery in the middle
                
                if (canReachBattery(firstConnection, battery, graph, visited)) {
                    return true; // Found a closed loop
                }
            }
            
            return false;
        }
        
        // Helper function to check if we can reach the battery
        function canReachBattery(current, target, graph, visited) {
            if (current === target) return true;
            if (visited.has(current)) return false;
            
            visited.add(current);
            const neighbors = graph.get(current) || [];
            
            for (const neighbor of neighbors) {
                if (canReachBattery(neighbor, target, graph, visited)) {
                    return true;
                }
            }
            
            return false;
        }
        
        // Calculate resistance for combination circuits
        function calculateCombinationResistance(topology) {
            // Simplified calculation - just use series sum for now
            // A full implementation would require complex graph analysis
            return 100;
        }
        
        // Update topology display in UI
        function updateTopologyDisplay(type) {
            const topologyEl = document.getElementById('topology-type');
            if (topologyEl) {
                let displayText = type;
                let color = '#88ccff';
                
                switch(type) {
                    case 'series':
                        displayText = '? Series';
                        color = '#ffaa44';
                        break;
                    case 'parallel':
                        displayText = '?? Parallel';
                        color = '#44ff88';
                        break;
                    case 'combination':
                        displayText = '??? Combination';
                        color = '#ff88ff';
                        break;
                    case 'simple':
                        displayText = '? Simple';
                        color = '#88ccff';
                        break;
                    case 'Open Circuit':
                        displayText = '? Open';
                        color = '#ff4444';
                        break;
                    case 'Incomplete':
                        displayText = '?? Incomplete';
                        color = '#ffaa44';
                        break;
                    case 'No Circuit':
                        displayText = '? None';
                        color = '#888888';
                        break;
                    default:
                        displayText = '? Unknown';
                        color = '#888888';
                }
                
                topologyEl.textContent = displayText;
                topologyEl.style.color = color;
            }
        }

        function updateCircuitDisplay(voltage, current, resistance, power) {
            // Store values for educational modes
            lastKnownValues = { voltage, current, resistance, power };
            
            // Update W.I.R.E. analysis display
            const voltageEl = document.getElementById('voltage');
            const currentEl = document.getElementById('current');
            const resistanceEl = document.getElementById('resistance');
            const powerEl = document.getElementById('power');
            
            if (voltageEl) voltageEl.textContent = voltage.toFixed(1) + 'V';
            if (currentEl) currentEl.textContent = current.toFixed(3) + 'A';
            if (resistanceEl) resistanceEl.textContent = 
                resistance === Infinity ? '??' : resistance.toFixed(1) + '?';
            if (powerEl) powerEl.textContent = power.toFixed(2) + 'W';
            
            const countEl = document.getElementById('count');
            const wireCountEl = document.getElementById('wire-count');
            const junctionCountEl = document.getElementById('junction-count');
            
            if (countEl) countEl.textContent = components.length;
            if (wireCountEl) wireCountEl.textContent = wires.length;
            if (junctionCountEl) junctionCountEl.textContent = junctions.length;
            
            // Update worksheet mode if active
            if (currentAnalysisTab === 'worksheet') {
                updateCalculationFormulas();
            }
            
            // Update practice status if in practice mode
            if (currentAnalysisTab === 'practice' && currentPracticeCircuit) {
                updatePracticeStatus();
            }
            
            if (current > 0 && resistance !== Infinity) {
                setStatus(`?? W.I.R.E. COMPLETE! W=${power.toFixed(2)}W, I=${current.toFixed(3)}A, R=${resistance.toFixed(1)}?, E=${voltage.toFixed(1)}V`);
            } else if (resistance === Infinity) {
                const switches = components.filter(c => c.type === 'switch');
                const openSwitch = switches.find(sw => !sw.properties.isOn);
                
                if (openSwitch) {
                    setStatus(`?? OPEN CIRCUIT: Switch is OFF - touch it to complete W.I.R.E. analysis!`);
                } else {
                    setStatus(`?? INCOMPLETE CIRCUIT: Connect components to enable W.I.R.E. calculations`);
                }
            } else {
                setStatus('?? W.I.R.E. Circuit Builder - Learn with visual methodology!');
            }
        }

        function animateCurrentFlow(hasFlow, currentValue = 0) {
            currentFlowParticles.forEach(particle => {
                if (particle && scene) {
                    scene.remove(particle);
                }
            });
            currentFlowParticles = [];
            
            if (!hasFlow || currentValue <= 0) return;
            
            const wiresForAnimation = wires;
            if (wiresForAnimation.length === 0) return;
            
            const currentIntensity = Math.min(currentValue / 0.5, 1.0);
            const flowColor = calculateCurrentColor(currentValue);
            const flowSpeed = calculateFlowSpeed(currentValue);
            
            // Reduce particle count for mobile performance
            const baseParticleCount = isMobile ? 3 : 4;
            const maxParticles = isMobile ? 8 : 12;
            const particleCount = Math.max(baseParticleCount, Math.min(maxParticles, Math.floor(currentValue * (isMobile ? 15 : 20))));
            
            wiresForAnimation.forEach((wire, wireIndex) => {
                if (!wire || !wire.wireGroup) return;
                
                if (!wire.curve) {
                    wire.createCurve();
                }
                if (!wire.curve) return;
                
                for (let i = 0; i < particleCount; i++) {
                    try {
                        const particleSize = 0.08 + (currentIntensity * 0.06);
                        const particleGeometry = new THREE.SphereGeometry(particleSize, isMobile ? 8 : 10, isMobile ? 6 : 8);
                        
                        // Apply misty or solid style
                        const baseMaterialProps = {
                            color: flowColor.hex,
                            emissive: flowColor.emissive,
                            shininess: 150,
                            transparent: true
                        };
                        
                        if (currentFlowStyle === 'misty') {
                            // Misty style: lower opacity, more ethereal
                            baseMaterialProps.opacity = 0.4 + (currentIntensity * 0.3);
                            baseMaterialProps.emissiveIntensity = 0.8;
                        } else {
                            // Solid style: higher opacity, more defined
                            baseMaterialProps.opacity = 0.85 + (currentIntensity * 0.15);
                            baseMaterialProps.emissiveIntensity = 1.0;
                        }
                        
                        const particleMaterial = new THREE.MeshPhongMaterial(baseMaterialProps);
                        const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                        
                        const initialProgress = (i / particleCount) + (wireIndex * 0.1);
                        const clampedProgress = Math.max(0, Math.min(1, initialProgress % 1));
                        
                        const initialPosition = wire.curve.getPoint(clampedProgress);
                        particle.position.copy(initialPosition);
                        
                        particle.userData = { 
                            wire: wire,
                            progress: clampedProgress,
                            baseSpeed: flowSpeed,
                            currentValue: currentValue,
                            flowColor: flowColor,
                            isFlowing: true,
                            flowStyle: currentFlowStyle
                        };
                        
                        scene.add(particle);
                        currentFlowParticles.push(particle);
                        
                    } catch (error) {
                        console.error(`Error creating particle ${i}:`, error);
                    }
                }
            });
        }

        function calculateCurrentColor(current) {
            if (current <= 0.02) {
                return { hex: 0xff3333, emissive: 0x330000 };
            } else if (current <= 0.05) {
                return { hex: 0xff8800, emissive: 0x331100 };
            } else if (current <= 0.1) {
                return { hex: 0xffff00, emissive: 0x333300 };
            } else if (current <= 0.2) {
                return { hex: 0xffffff, emissive: 0x444444 };
            } else {
                return { hex: 0xaaffff, emissive: 0x0044aa };
            }
        }

        function calculateFlowSpeed(current) {
            const baseSpeed = isMobile ? 0.008 : 0.01;
            const speedMultiplier = 1 + (current * 8);
            return Math.min(baseSpeed * speedMultiplier, isMobile ? 0.06 : 0.08);
        }

        function updateCircuitInfo() {
            updateCircuitDisplay(0, 0, Infinity, 0);
            analyzeCircuit();
        }

        // Educational Analysis Functions
        function switchAnalysisTab(tabName) {
            // Update tab buttons
            document.querySelectorAll('.analysis-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            document.getElementById(`tab-${tabName}`).classList.add('active');
            
            // Show/hide content panels
            document.querySelectorAll('.analysis-content').forEach(content => {
                content.style.display = 'none';
            });
            document.getElementById(`content-${tabName}`).style.display = 'block';
            
            currentAnalysisTab = tabName;
            
            // Update content based on tab
            switch(tabName) {
                case 'worksheet':
                    updateWorksheetDisplay();
                    break;
                case 'eir':
                    updateCircuitSchematic();
                    break;
                case 'power':
                    // Power triangle is static, no need to update
                    break;
                case 'problem':
                    updateProblemMode();
                    break;
                case 'practice':
                    updatePracticeStatus();
                    break;
            }
            
            setStatus(`?? Switched to ${tabName.toUpperCase()} analysis mode`);
        }

        function explainOhmsLaw(variable) {
            const formulaEl = document.getElementById('eir-formula');
            
            switch(variable) {
                case 'E':
                    formulaEl.textContent = 'E = I ? R (EMF/Voltage = Current ? Resistance)';
                    formulaEl.style.color = '#ff4444';
                    setStatus('?? EMF/VOLTAGE: E = I ? R | Measured in Volts (V)');
                    break;
                case 'I':
                    formulaEl.textContent = 'I = E ? R (Current = EMF/Voltage ? Resistance)';
                    formulaEl.style.color = '#ff8844';
                    setStatus('?? CURRENT: I = E ? R | Measured in Amperes (A)');
                    break;
                case 'R':
                    formulaEl.textContent = 'R = E ? I (Resistance = EMF/Voltage ? Current)';
                    formulaEl.style.color = '#44ff88';
                    setStatus('?? RESISTANCE: R = E ? I | Measured in Ohms (?)');
                    break;
            }
            
            // Add visual feedback
            const triangleEl = document.querySelector(`.triangle-${variable.toLowerCase()}`);
            if (triangleEl) {
                triangleEl.style.textShadow = '0 0 20px currentColor';
                setTimeout(() => {
                    triangleEl.style.textShadow = '0 0 10px currentColor';
                }, 1000);
            }
        }

        function explainPowerLaw(variable) {
            const formulaEl = document.getElementById('power-formula');
            
            switch(variable) {
                case 'W':
                    formulaEl.textContent = 'W = I ? E (Power = Current ? EMF/Voltage)';
                    formulaEl.style.color = '#4488ff';
                    setStatus('?? POWER: W = I ? E | Also W = I?R or W = E??R | Measured in Watts (W)');
                    break;
                case 'I':
                    formulaEl.textContent = 'I = W ? E (Current = Power ? EMF/Voltage)';
                    formulaEl.style.color = '#ff8844';
                    setStatus('?? CURRENT: I = W ? E | From power triangle | Measured in Amperes (A)');
                    break;
                case 'E':
                    formulaEl.textContent = 'E = W ? I (EMF/Voltage = Power ? Current)';
                    formulaEl.style.color = '#ff4444';
                    setStatus('?? EMF/VOLTAGE: E = W ? I | From power triangle | Measured in Volts (V)');
                    break;
            }
            
            // Add visual feedback
            let triangleSelector;
            if (variable === 'W') triangleSelector = '.triangle-v'; // W is in top position
            else if (variable === 'I') triangleSelector = '.triangle-i'; // I is in bottom left
            else if (variable === 'E') triangleSelector = '.triangle-r'; // E is in bottom right position
            
            const triangleEl = document.querySelector(`#content-power ${triangleSelector}`);
            if (triangleEl) {
                triangleEl.style.textShadow = '0 0 20px currentColor';
                setTimeout(() => {
                    triangleEl.style.textShadow = '0 0 10px currentColor';
                }, 1000);
            }
        }

        function updateWorksheetDisplay() {
            const componentList = document.getElementById('component-list');
            if (!componentList) return;
            
            // Clear existing list
            componentList.innerHTML = '';
            
            // Add batteries
            components.filter(c => c.type === 'battery').forEach(battery => {
                const item = document.createElement('div');
                item.className = 'component-item';
                item.style.borderColor = '#ff4444';
                item.innerHTML = `
                    <div class="component-label">Battery ${battery.componentNumber}</div>
                    <div class="component-value" style="color: #ff4444;">${battery.properties.voltage}V</div>
                `;
                componentList.appendChild(item);
            });
            
            // Add resistors
            components.filter(c => c.type === 'resistor').forEach(resistor => {
                const item = document.createElement('div');
                item.className = 'component-item';
                item.style.borderColor = '#44ff88';
                item.innerHTML = `
                    <div class="component-label">R${resistor.componentNumber}</div>
                    <div class="component-value" style="color: #44ff88;">${resistor.properties.resistance}?</div>
                `;
                componentList.appendChild(item);
            });
            
            // Add LEDs
            components.filter(c => c.type === 'led').forEach(led => {
                const item = document.createElement('div');
                item.className = 'component-item';
                item.style.borderColor = '#44ff88';
                item.innerHTML = `
                    <div class="component-label">LED${led.componentNumber}</div>
                    <div class="component-value" style="color: #44ff88;">${led.properties.resistance}?</div>
                `;
                componentList.appendChild(item);
            });
            
            // Add switches
            components.filter(c => c.type === 'switch').forEach(sw => {
                const item = document.createElement('div');
                item.className = 'component-item';
                item.style.borderColor = sw.properties.isOn ? '#44ff88' : '#ff4444';
                item.innerHTML = `
                    <div class="component-label">SW${sw.componentNumber}</div>
                    <div class="component-value" style="color: ${sw.properties.isOn ? '#44ff88' : '#ff4444'};">
                        ${sw.properties.isOn ? sw.properties.resistance + '?' : 'OPEN'}
                    </div>
                `;
                componentList.appendChild(item);
            });
            
            // Update calculation formulas
            updateCalculationFormulas();
        }

        function updateCalculationFormulas() {
            const resistors = components.filter(c => c.type === 'resistor' || c.type === 'led');
            const batteries = components.filter(c => c.type === 'battery');
            const switches = components.filter(c => c.type === 'switch' && c.properties.isOn);
            
            // Update resistance formula
            const resistanceFormula = document.getElementById('resistance-formula');
            if (resistanceFormula) {
                let formula = 'R_total = ';
                const allResistors = [...resistors, ...switches];
                if (allResistors.length > 0) {
                    formula += allResistors.map(r => {
                        if (r.type === 'resistor') return `R${r.componentNumber}`;
                        if (r.type === 'led') return `LED${r.componentNumber}`;
                        if (r.type === 'switch') return `SW${r.componentNumber}`;
                        return 'X';
                    }).join(' + ');
                } else {
                    formula += '? (no resistors)';
                }
                resistanceFormula.textContent = formula;
            }
            
            // Update voltage formula
            const voltageFormula = document.getElementById('voltage-formula');
            if (voltageFormula) {
                let formula = 'V_total = ';
                if (batteries.length > 0) {
                    formula += batteries.map(b => `B${b.componentNumber}`).join(' + ');
                } else {
                    formula += '0 (no batteries)';
                }
                voltageFormula.textContent = formula;
            }

            // Update calculated values in worksheet
            const calcElements = {
                'calc-resistance': lastKnownValues.resistance === Infinity ? '??' : lastKnownValues.resistance.toFixed(1) + '?',
                'calc-current': lastKnownValues.current.toFixed(3) + 'A',
                'calc-voltage': lastKnownValues.voltage.toFixed(1) + 'V',
                'calc-power': lastKnownValues.power.toFixed(2) + 'W'
            };

            Object.entries(calcElements).forEach(([id, value]) => {
                const el = document.getElementById(id);
                if (el) el.textContent = value;
            });
        }

        function updateCircuitSchematic() {
            const schematicEl = document.getElementById('circuit-schematic');
            if (!schematicEl) return;
            
            const batteries = components.filter(c => c.type === 'battery');
            const resistors = components.filter(c => c.type === 'resistor' || c.type === 'led');
            
            if (batteries.length === 0 && resistors.length === 0) {
                schematicEl.innerHTML = `
                    <div class="schematic-line">No components added yet</div>
                    <div class="schematic-line">Add battery and resistors</div>
                    <div class="schematic-line">to see circuit diagram</div>
                `;
                return;
            }
            
            // Generate ASCII circuit based on components
            let schematic = '';
            if (batteries.length > 0 && resistors.length > 0) {
                schematic = `
                    <div class="schematic-line">     +?????[R?]?????+</div>
                    <div class="schematic-line">     ?              ?</div>
                    <div class="schematic-line">   [BAT]          [R?]</div>
                    <div class="schematic-line">     ?              ?</div>
                    <div class="schematic-line">     +??????????????+</div>
                `;
            } else if (batteries.length > 0) {
                schematic = `
                    <div class="schematic-line">     +??????????????+</div>
                    <div class="schematic-line">     ?              ?</div>
                    <div class="schematic-line">   [BAT]         (no load)</div>
                    <div class="schematic-line">     ?              ?</div>
                    <div class="schematic-line">     +??????????????+</div>
                `;
            }
            
            schematicEl.innerHTML = schematic;
        }

        function updateProblemMode() {
            // Clear any previous answers
            document.getElementById('student-voltage').value = '';
            document.getElementById('student-current').value = '';
            document.getElementById('student-resistance').value = '';
            document.getElementById('student-power').value = '';
            
            const feedbackEl = document.getElementById('answer-feedback');
            if (feedbackEl) {
                feedbackEl.innerHTML = '';
            }
        }

        function checkStudentAnswers() {
            const studentVoltage = parseFloat(document.getElementById('student-voltage').value);
            const studentCurrent = parseFloat(document.getElementById('student-current').value);
            const studentResistance = parseFloat(document.getElementById('student-resistance').value);
            const studentPower = parseFloat(document.getElementById('student-power').value);
            
            const tolerance = 0.05; // 5% tolerance for answers
            const feedbackEl = document.getElementById('answer-feedback');
            
            let results = [];
            let allCorrect = true;
            
            // Check voltage
            if (!isNaN(studentVoltage)) {
                const voltageCorrect = Math.abs(studentVoltage - lastKnownValues.voltage) / lastKnownValues.voltage < tolerance;
                results.push({
                    label: 'Voltage',
                    student: studentVoltage.toFixed(1) + 'V',
                    correct: lastKnownValues.voltage.toFixed(1) + 'V',
                    isCorrect: voltageCorrect,
                    color: '#ff4444'
                });
                if (!voltageCorrect) allCorrect = false;
            }
            
            // Check current
            if (!isNaN(studentCurrent)) {
                const currentCorrect = Math.abs(studentCurrent - lastKnownValues.current) / Math.max(lastKnownValues.current, 0.001) < tolerance;
                results.push({
                    label: 'Current',
                    student: studentCurrent.toFixed(3) + 'A',
                    correct: lastKnownValues.current.toFixed(3) + 'A',
                    isCorrect: currentCorrect,
                    color: '#ff8844'
                });
                if (!currentCorrect) allCorrect = false;
            }
            
            // Check resistance
            if (!isNaN(studentResistance)) {
                const resistanceCorrect = lastKnownValues.resistance === Infinity ? 
                    studentResistance > 10000 : 
                    Math.abs(studentResistance - lastKnownValues.resistance) / lastKnownValues.resistance < tolerance;
                results.push({
                    label: 'Resistance',
                    student: studentResistance.toFixed(1) + '?',
                    correct: lastKnownValues.resistance === Infinity ? '??' : lastKnownValues.resistance.toFixed(1) + '?',
                    isCorrect: resistanceCorrect,
                    color: '#44ff88'
                });
                if (!resistanceCorrect) allCorrect = false;
            }
            
            // Check power
            if (!isNaN(studentPower)) {
                const powerCorrect = Math.abs(studentPower - lastKnownValues.power) / Math.max(lastKnownValues.power, 0.001) < tolerance;
                results.push({
                    label: 'Power',
                    student: studentPower.toFixed(2) + 'W',
                    correct: lastKnownValues.power.toFixed(2) + 'W',
                    isCorrect: powerCorrect,
                    color: '#4488ff'
                });
                if (!powerCorrect) allCorrect = false;
            }
            
            // Display results
            let feedback = `<div class="result-feedback ${allCorrect ? 'feedback-correct' : 'feedback-incorrect'}">`;
            
            if (allCorrect && results.length > 0) {
                feedback += '?? Excellent! All answers are correct!';
            } else if (results.length === 0) {
                feedback += '? Please enter at least one answer to check.';
            } else {
                feedback += '?? Results:<br>';
                results.forEach(result => {
                    const icon = result.isCorrect ? '?' : '?';
                    feedback += `${icon} ${result.label}: ${result.student} ${result.isCorrect ? '(Correct!)' : '(Expected: ' + result.correct + ')'}<br>`;
                });
            }
            
            feedback += '</div>';
            feedbackEl.innerHTML = feedback;
        }

        // Preset Circuit Library
        const PRESET_CIRCUITS = {
            series_basic: {
                name: "Basic Series Circuit",
                description: "Simple series circuit with battery and two resistors",
                objectives: [
                    "Calculate total resistance in series (R_total = R? + R?)",
                    "Apply Ohm's law to find current (I = V ? R_total)",
                    "Calculate power consumption (P = V ? I)"
                ],
                components: [
                    { type: 'battery', position: [-4, 0, 0], properties: { voltage: 12 } },
                    { type: 'resistor', position: [0, 0, 0], properties: { resistance: 100 } },
                    { type: 'resistor', position: [4, 0, 0], properties: { resistance: 200 } }
                ],
                connections: [
                    { from: 'battery_1_positive', to: 'resistor_1_left' },
                    { from: 'resistor_1_right', to: 'resistor_2_left' },
                    { from: 'resistor_2_right', to: 'battery_1_negative' }
                ]
            },
            parallel_basic: {
                name: "Basic Parallel Circuit",
                description: "Two resistors in parallel with a battery",
                objectives: [
                    "Calculate total resistance in parallel (1/R_total = 1/R? + 1/R?)",
                    "Understand current division in parallel circuits",
                    "Compare parallel vs series power consumption"
                ],
                components: [
                    { type: 'battery', position: [-4, 0, 0], properties: { voltage: 9 } },
                    { type: 'resistor', position: [2, 0, 2], properties: { resistance: 150 } },
                    { type: 'resistor', position: [2, 0, -2], properties: { resistance: 300 } }
                ]
            },
            mixed_circuit: {
                name: "Mixed Series-Parallel Circuit",
                description: "Combination of series and parallel resistors",
                objectives: [
                    "Analyze complex circuits with mixed connections",
                    "Break down circuit into series and parallel sections",
                    "Apply equivalent resistance concepts"
                ],
                components: [
                    { type: 'battery', position: [-6, 0, 0], properties: { voltage: 15 } },
                    { type: 'resistor', position: [-2, 0, 0], properties: { resistance: 50 } },
                    { type: 'resistor', position: [2, 0, 2], properties: { resistance: 100 } },
                    { type: 'resistor', position: [2, 0, -2], properties: { resistance: 200 } },
                    { type: 'led', position: [6, 0, 0], properties: { resistance: 25 } }
                ]
            },
            switch_control: {
                name: "Switch-Controlled Circuit",
                description: "Circuit with switch to control current flow",
                objectives: [
                    "Understand open vs closed circuit behavior",
                    "Analyze the effect of switches on circuit operation",
                    "Calculate power consumption when switch is ON vs OFF",
                    "Practice with switch resistance calculations"
                ],
                components: [
                    { type: 'battery', position: [-4, 0, 0], properties: { voltage: 6 } },
                    { type: 'switch', position: [0, 0, 0], properties: { resistance: 0.1, isOn: false } },
                    { type: 'led', position: [4, 0, 0], properties: { resistance: 20 } }
                ]
            },
            combination_advanced: {
                name: "Advanced Combination Circuit",
                description: "Complex circuit combining series, parallel, and mixed configurations",
                objectives: [
                    "Master combination circuit analysis techniques",
                    "Use junction nodes to create complex topologies",
                    "Calculate equivalent resistance step by step",
                    "Apply W.I.R.E. method to advanced circuits",
                    "Understand current division in complex paths"
                ],
                components: [
                    { type: 'battery', position: [-6, 0, 0], properties: { voltage: 18 } },
                    { type: 'resistor', position: [-2, 0, 0], properties: { resistance: 80 } },
                    { type: 'resistor', position: [2, 0, 3], properties: { resistance: 120 } },
                    { type: 'resistor', position: [2, 0, 0], properties: { resistance: 180 } },
                    { type: 'resistor', position: [2, 0, -3], properties: { resistance: 240 } },
                    { type: 'led', position: [6, 0, 0], properties: { resistance: 30 } }
                ]
            }
        };

        function updatePracticeStatus() {
            if (!currentPracticeCircuit) return;
            
            const circuitStatusEl = document.getElementById('circuit-status');
            const circuitStatusTextEl = document.getElementById('circuit-status-text');
            const wireInstructionsEl = document.getElementById('wire-instructions');
            
            // Check if circuit is complete (has wires connecting components)
            const isComplete = wires.length > 0 && components.length > 1;
            const hasFlow = lastKnownValues.current > 0 && lastKnownValues.resistance !== Infinity;
            
            if (circuitStatusEl && circuitStatusTextEl) {
                if (hasFlow) {
                    circuitStatusEl.className = 'circuit-status status-complete';
                    circuitStatusTextEl.textContent = '? Circuit complete - Current flowing! Switch to Solve tab.';
                    if (wireInstructionsEl) wireInstructionsEl.style.display = 'none';
                } else if (isComplete) {
                    circuitStatusEl.className = 'circuit-status status-incomplete';
                    circuitStatusTextEl.textContent = '?? Circuit wired but not complete - Check connections';
                    if (wireInstructionsEl) wireInstructionsEl.style.display = 'block';
                } else {
                    circuitStatusEl.className = 'circuit-status status-incomplete';
                    circuitStatusTextEl.textContent = '?? Circuit incomplete - Add wires to connect components';
                    if (wireInstructionsEl) wireInstructionsEl.style.display = 'block';
                }
            }
        }

        function loadPresetCircuit(presetName) {
            const preset = PRESET_CIRCUITS[presetName];
            if (!preset) {
                setStatus('? Preset circuit not found!');
                return;
            }
            
            // Clear current circuit
            clearAll(false);
            
            // Set current practice circuit
            currentPracticeCircuit = presetName;
            
            // If loading individual circuit (not from sequence), update index
            if (!practiceProblems.includes(presetName)) {
                // This is for individual button clicks
                currentProblemIndex = practiceProblems.indexOf(presetName);
                if (currentProblemIndex === -1) currentProblemIndex = 0;
            }
            
            // Load preset components
            preset.components.forEach((compData, index) => {
                const position = new THREE.Vector3(compData.position[0], compData.position[1], compData.position[2]);
                const component = new Component(compData.type, position);
                component.updateProperties(compData.properties);
                components.push(component);
            });
            
            // Update practice mode displays
            const questionEl = document.getElementById('practice-question');
            const descriptionEl = document.getElementById('practice-description');
            const practiceCardEl = document.getElementById('practice-problem-card');
            const helpTextEl = document.getElementById('practice-help-text');
            const objList = document.getElementById('objectives-list');
            
            const practiceInfo = practiceQuestions[presetName];
            
            if (questionEl && practiceInfo) {
                questionEl.textContent = `?? Problem: ${practiceInfo.question}`;
            }
            
            if (descriptionEl && practiceInfo) {
                descriptionEl.textContent = practiceInfo.description;
            }
            
            if (practiceCardEl) {
                practiceCardEl.style.display = 'block';
            }
            
            if (helpTextEl) {
                helpTextEl.style.display = 'none';
            }
            
            if (objList && preset.objectives) {
                objList.innerHTML = preset.objectives.map(obj => `<li>${obj}</li>`).join('');
            }
            
            // Highlight the selected button (only for individual clicks)
            document.querySelectorAll('.practice-btn').forEach(btn => btn.classList.remove('active'));
            const buttonIds = {
                'series_basic': 'btn-series',
                'parallel_basic': 'btn-parallel', 
                'mixed_circuit': 'btn-mixed',
                'combination_advanced': 'btn-combination'
            };
            const buttonId = buttonIds[presetName];
            if (buttonId) {
                const button = document.getElementById(buttonId);
                if (button) button.classList.add('active');
            }
            
            // Update counter and navigation
            updatePracticeCounter();
            updateNavigationButtons();
            
            // Switch to practice tab if not already there
            if (currentAnalysisTab !== 'practice') {
                switchAnalysisTab('practice');
            }
            
            updateCircuitInfo();
            updatePracticeStatus();
            setStatus(`?? Loaded practice problem: ${preset.name} - Wire the components!`);
        }

        function autoConnectSeries() {
            // Auto-connect components in series for educational purposes
            // Note: This is mainly used for demonstration, practice mode requires manual wiring
            if (components.length < 2) return;
            
            try {
                for (let i = 0; i < components.length - 1; i++) {
                    const comp1 = components[i];
                    const comp2 = components[i + 1];
                    
                    let startSide, endSide;
                    
                    // Determine connection sides based on component types
                    if (comp1.type === 'battery') {
                        startSide = 'positive';
                    } else {
                        startSide = 'right';
                    }
                    
                    endSide = 'left';
                    
                    const wire = new Wire(comp1, startSide, comp2, endSide);
                    wires.push(wire);
                }
                
                // Close the circuit - connect last component back to battery
                if (components.length > 1) {
                    const lastComp = components[components.length - 1];
                    const battery = components.find(c => c.type === 'battery');
                    
                    if (lastComp && battery && lastComp !== battery) {
                        const wire = new Wire(lastComp, 'right', battery, 'negative');
                        wires.push(wire);
                    }
                }
                
                analyzeCircuit();
                setStatus('?? Circuit auto-wired for demonstration');
            } catch (error) {
                console.log('Auto-connect failed, students can wire manually');
            }
        }

        function generateRandomProblem() {
            // Generate a random circuit problem
            const problemTypes = ['series_basic', 'parallel_basic', 'mixed_circuit'];
            const randomType = problemTypes[Math.floor(Math.random() * problemTypes.length)];
            
            loadPresetCircuit(randomType);
            
            // Randomize component values
            components.forEach(comp => {
                if (comp.type === 'battery') {
                    comp.updateProperties({ voltage: Math.floor(Math.random() * 15) + 3 }); // 3-18V
                } else if (comp.type === 'resistor') {
                    comp.updateProperties({ resistance: Math.floor(Math.random() * 500) + 50 }); // 50-550?
                } else if (comp.type === 'led') {
                    comp.updateProperties({ resistance: Math.floor(Math.random() * 30) + 10 }); // 10-40?
                }
            });
            
            // Highlight random button
            document.querySelectorAll('.practice-btn').forEach(btn => btn.classList.remove('active'));
            const randomBtn = document.getElementById('btn-random');
            if (randomBtn) randomBtn.classList.add('active');
            
            // Reset practice sequence tracking
            currentPracticeCircuit = 'random';
            updatePracticeCounter();
            
            updateCircuitInfo();
            updatePracticeStatus();
            setStatus('?? Generated random practice problem with randomized values!');
        }

        // Practice sequence navigation functions
        function startPracticeSequence() {
            currentProblemIndex = 0;
            loadPracticeSequenceProblem();
            setStatus('?? Started practice sequence - Problem 1 of 4');
        }

        function nextProblem() {
            if (currentProblemIndex < practiceProblems.length - 1) {
                currentProblemIndex++;
                loadPracticeSequenceProblem();
                setStatus(`?? Advanced to problem ${currentProblemIndex + 1} of ${practiceProblems.length}`);
            } else {
                setStatus('?? Congratulations! You completed all practice problems!');
                alert('?? Great job! You\'ve completed all practice problems.\n\nYou can:\n? Start over with "Start Practice Sequence"\n? Try "Random" for extra practice\n? Use individual problem buttons for review');
            }
        }

        function previousProblem() {
            if (currentProblemIndex > 0) {
                currentProblemIndex--;
                loadPracticeSequenceProblem();
                setStatus(`?? Returned to problem ${currentProblemIndex + 1} of ${practiceProblems.length}`);
            } else {
                setStatus('?? Already at the first problem');
            }
        }

        function loadPracticeSequenceProblem() {
            const problemType = practiceProblems[currentProblemIndex];
            loadPresetCircuit(problemType);
            updatePracticeCounter();
            updateNavigationButtons();
        }

        function updatePracticeCounter() {
            const counterEl = document.getElementById('problem-counter');
            const totalEl = document.getElementById('total-problems');
            
            if (counterEl && totalEl) {
                if (currentPracticeCircuit === 'random') {
                    counterEl.textContent = '?';
                    totalEl.textContent = '?';
                } else {
                    counterEl.textContent = currentProblemIndex + 1;
                    totalEl.textContent = practiceProblems.length;
                }
            }
        }

        function updateNavigationButtons() {
            const prevBtn = document.getElementById('prev-btn');
            const nextBtn = document.getElementById('next-btn');
            
            if (prevBtn && nextBtn) {
                // Show/hide buttons based on position
                prevBtn.style.opacity = currentProblemIndex > 0 ? '1.0' : '0.5';
                prevBtn.disabled = currentProblemIndex === 0;
                
                if (currentProblemIndex >= practiceProblems.length - 1) {
                    nextBtn.textContent = 'Finish ??';
                    nextBtn.style.background = 'linear-gradient(135deg, #ff6b6b, #ee5a52)';
                } else {
                    nextBtn.textContent = 'Next ?';
                    nextBtn.style.background = 'linear-gradient(135deg, #333, #444)';
                }
            }
        }

        function clearAll(shouldSaveState = true) {
            if (shouldSaveState) {
                saveState(); // Save for undo
            }
            
            isWireMode = false;
            isRotateMode = false;
            wireStart = null;
            isDragging = false;
            selectedComponent = null;
            selectedComponents.clear();
            hideSnapIndicator();
            currentPracticeCircuit = null; // Reset practice circuit
            // Note: Don't reset currentProblemIndex to allow "Clear" during practice sequence
            
            // Reset component counters
            componentCounters = {
                battery: 0,
                resistor: 0,
                led: 0,
                switch: 0
            };
            
            currentFlowParticles.forEach(particle => {
                if (particle) scene.remove(particle);
            });
            currentFlowParticles = [];
            
            wires.forEach(wire => {
                if (wire?.wireGroup) scene.remove(wire.wireGroup);
            });
            wires = [];
            
            components.forEach(comp => {
                if (comp?.mesh) scene.remove(comp.mesh);
                if (comp?.labelDiv) document.body.removeChild(comp.labelDiv);
                // Remove polarity indicators
                if (comp?.polarityDivs) {
                    comp.polarityDivs.forEach(item => {
                        if (item.div && item.div.parentNode) {
                            document.body.removeChild(item.div);
                        }
                    });
                    comp.polarityDivs = null;
                }
            });
            components = [];
            
            junctions.forEach(junction => {
                if (junction?.mesh) scene.remove(junction.mesh);
            });
            junctions = [];
            
            // Clean up any orphaned polarity indicators as a safety measure
            document.querySelectorAll('.polarity-indicator').forEach(el => {
                if (el.parentNode) {
                    document.body.removeChild(el);
                }
            });
            
            // Reset practice mode UI only if not in a practice sequence
            if (!currentPracticeCircuit) {
                const practiceCardEl = document.getElementById('practice-problem-card');
                const helpTextEl = document.getElementById('practice-help-text');
                if (practiceCardEl) practiceCardEl.style.display = 'none';
                if (helpTextEl) helpTextEl.style.display = 'block';
                
                // Remove active state from practice buttons
                document.querySelectorAll('.practice-btn').forEach(btn => btn.classList.remove('active'));
                
                // Reset practice sequence
                currentProblemIndex = 0;
            }
            
            updateButtonStates();
            updateCircuitInfo();
            closeAllSubmenus();
            setStatus('??? ALL CLEARED! Circuit builder reset with fresh component numbering');
        }

        function showPracticeModeHelp() {
            const help = `
?? PRACTICE MODE HELP

?? HOW TO GET NEXT PROBLEMS:

?? PRACTICE SEQUENCE (Recommended):
   ? Click "Start Practice Sequence" for guided progression
   ? Work through 4 problems in order: Series ? Parallel ? Mixed ? Switch
   ? Use "? Prev" and "Next ?" buttons to navigate
   ? See "Problem 1 of 4" counter to track progress
   ? Click "Finish ??" on the last problem

?? INDIVIDUAL PROBLEMS:
   ? Click specific buttons: "Basic Series", "Basic Parallel", etc.
   ? Jump to any problem for review or extra practice
   ? Still shows problem counter and navigation

?? RANDOM PROBLEMS:
   ? Click "Random" for randomized component values
   ? Same circuit types, but different numbers each time
   ? Perfect for extra practice and testing

?? WIRING PROCESS:
   1. Problem loads with components placed automatically
   2. Read the question: "Find total resistance", etc.
   3. Click ??? Tools ? ?? Wire Mode
   4. Touch colored terminals to connect:
      - Red = Battery positive (+)
      - Gray = Battery negative (-)
      - White = Component terminals
   5. Status changes: ?? Incomplete ? ? Complete

?? SOLVING PROBLEMS:
   ? Switch to EIR ? for Ohm's law (E=I?R)
   ? Use Power ? for power calculations (W=I?E)
   ? Try Worksheet for step-by-step formulas
   ? Go to Solve tab to check your answers

Perfect sequence for learning circuit analysis!
            `;
            alert(help);
        }

        function setStatus(message) {
            const statusEl = document.getElementById('status');
            if (statusEl) {
                statusEl.textContent = message;
                statusEl.style.display = 'block';
                
                setTimeout(() => {
                    if (statusEl.style.display !== 'none') {
                        statusEl.style.display = 'none';
                    }
                }, isMobile ? 6000 : 5000); // Longer display time on mobile
            }
        }

        // Start the application
        init();
    </script>
</body>
</html>