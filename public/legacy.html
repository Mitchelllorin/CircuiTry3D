<!DOCTYPE html>
<html>
<head>
    <script>
        // Immediately detect embedded mode and add class to prevent splash flash
        (function() {
            try {
                var urlParams = new URLSearchParams(window.location.search);
                var isEmbedded = urlParams.has("embed") || window.self !== window.top;
                if (isEmbedded) {
                    document.documentElement.classList.add("embedded");
                }
            } catch (e) {
                // Fallback: just check URL params
                try {
                    var params = new URLSearchParams(window.location.search);
                    if (params.has("embed")) {
                        document.documentElement.classList.add("embedded");
                    }
                } catch (err) {}
            }
        })();
    </script>
    <title>CircuiTry - Professional Circuit Design</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0, viewport-fit=cover">
    <meta name="application-name" content="CircuiTry3D">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="format-detection" content="telephone=no">
    <meta name="theme-color" content="#0f172a">
    <link rel="manifest" href="/manifest.json" />
    <link rel="icon" href="/favicon.ico" sizes="any" />
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png" />
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png" />
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png" />
    <style>
        * { 
            margin: 0; 
            padding: 0; 
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        
        :root {
            --legacy-menu-gap: 20px;
            --legacy-menu-width: clamp(260px, 22vw, 360px);
        }
        
        body { 
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            color: white; 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            touch-action: none;
            position: fixed;
            width: 100%;
            height: 100%;
            -webkit-overflow-scrolling: touch;
        }

        body.embedded,
        html.embedded body {
            overflow: hidden;
        }

        body.embedded #menu-bar,
        body.embedded #menu-toggle,
        body.embedded #wire-analysis,
        body.embedded #status,
        body.embedded #branding-overlay,
        body.embedded #landing-page,
        body.embedded #launch-btn,
        body.embedded #loading,
        body.embedded #loading-progress,
        body.embedded #loading-text,
        html.embedded #menu-bar,
        html.embedded #menu-toggle,
        html.embedded #wire-analysis,
        html.embedded #status,
        html.embedded #branding-overlay,
        html.embedded #landing-page,
        html.embedded #launch-btn,
        html.embedded #loading,
        html.embedded #loading-progress,
        html.embedded #loading-text {
            display: none !important;
        }

        body.embedded #canvas,
        html.embedded #canvas {
            display: block !important;
        }
        
        .menu-bar {
            position: fixed;
            top: var(--legacy-menu-gap);
            bottom: var(--legacy-menu-gap);
            left: var(--legacy-menu-gap);
            right: auto;
            width: var(--legacy-menu-width);
            height: calc(100vh - (var(--legacy-menu-gap) * 2));
            z-index: 100;
            background: rgba(0,0,0,0.95);
            backdrop-filter: blur(15px);
            border-right: 2px solid rgba(0,255,136,0.3);
            border-radius: 16px;
            padding: 16px 18px;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            box-shadow: 6px 0 24px rgba(0, 0, 0, 0.35);
        }
        
        .menu-bar.hidden {
            transform: translateX(calc(-100% - var(--legacy-menu-gap)));
            box-shadow: none;
        }
        
        .menu-tabs {
            display: flex;
            flex-direction: column;
            gap: 12px;
            justify-content: flex-start;
            max-width: 100%;
            margin: 0;
            flex: 1 1 auto;
            min-height: 0;
            overflow-y: auto;
            padding-right: 6px;
        }
        
        .menu-tab {
            padding: 16px 20px;
            background: linear-gradient(135deg, #333, #444);
            border: 2px solid #555;
            color: white;
            border-radius: 12px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            white-space: nowrap;
            position: relative;
            text-align: center;
            min-height: 56px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .menu-tab:hover, .menu-tab:active {
            background: linear-gradient(135deg, #444, #555);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,255,136,0.2);
        }
        
        .menu-tab.active {
            background: linear-gradient(135deg, #00ff88, #00cc66);
            color: #000;
            border-color: #00ff88;
            box-shadow: 0 0 20px rgba(0,255,136,0.4);
        }
        
        .submenu {
            background: rgba(0,0,0,0.95);
            backdrop-filter: blur(15px);
            border: 2px solid rgba(0,255,136,0.3);
            border-radius: 12px;
            padding: 16px;
            margin-top: 8px;
            display: none;
            width: 100%;
            z-index: 200;
        }
        
        .submenu.active {
            display: block;
        }
        
        .submenu-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
        }
        
        .submenu-row {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin-bottom: 12px;
        }
        
        .submenu-row:last-child {
            margin-bottom: 0;
        }
        
        .btn { 
            padding: 16px 20px; 
            background: linear-gradient(135deg, #333, #444);
            border: 2px solid #555;
            color: white; 
            border-radius: 12px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            white-space: nowrap;
            min-height: 56px;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
        }
        
        .btn:hover, .btn:active { 
            background: linear-gradient(135deg, #444, #555);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }
        
        .wire-btn.active { 
            background: linear-gradient(135deg, #00ff88, #00cc66);
            color: #000;
            border-color: #00ff88;
            box-shadow: 0 0 20px rgba(0,255,136,0.4);
        }
        
        .rotate-btn.active { 
            background: linear-gradient(135deg, #8800ff, #6600cc);
            border-color: #8800ff;
            box-shadow: 0 0 20px rgba(136,0,255,0.4);
        }

        .component-context-menu {
            position: fixed;
            display: none;
            flex-direction: column;
            gap: 6px;
            min-width: 200px;
            max-width: 320px;
            padding: 0;
            border-radius: 12px;
            background: rgba(10, 22, 44, 0.94);
            border: 1px solid rgba(136, 204, 255, 0.35);
            box-shadow: 0 16px 32px rgba(0, 0, 0, 0.45);
            z-index: 10000;
            backdrop-filter: blur(18px);
            touch-action: auto;
        }

        .component-context-menu[data-visible="true"] {
            display: flex;
        }

        .component-menu-header {
            padding: 14px 14px 12px 14px;
            border-bottom: 1px solid rgba(136, 204, 255, 0.2);
            background: rgba(20, 40, 80, 0.5);
            border-radius: 12px 12px 0 0;
        }

        .component-menu-title {
            font-size: 16px;
            font-weight: 700;
            color: rgba(136, 204, 255, 0.95);
            margin-bottom: 6px;
            letter-spacing: 0.5px;
        }

        .component-menu-description {
            font-size: 12px;
            line-height: 1.5;
            color: rgba(180, 200, 220, 0.85);
            font-weight: 400;
        }

        .component-menu-actions {
            padding: 8px;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .component-context-menu button {
            border: 1px solid rgba(136, 204, 255, 0.18);
            border-radius: 10px;
            background: rgba(34, 62, 108, 0.78);
            color: rgba(228, 240, 255, 0.96);
            font-size: 14px;
            font-weight: 600;
            padding: 10px 12px;
            text-align: left;
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            transition: border-color 0.2s ease, background 0.2s ease, transform 0.2s ease;
        }

        .component-context-menu button:hover,
        .component-context-menu button:focus {
            border-color: rgba(136, 204, 255, 0.5);
            background: rgba(46, 92, 152, 0.92);
            transform: translateY(-1px);
        }

        .component-context-menu button[data-action="wire"] {
            color: #00ffb2;
        }
        
        .wire-analysis-fixed {
            position: fixed;
            bottom: 20px;
            left: 20px;
            right: 20px;
            background: rgba(0,0,0,0.95);
            backdrop-filter: blur(15px);
            padding: 20px;
            border-radius: 16px;
            border: 2px solid rgba(0,255,136,0.4);
            z-index: 90;
            transition: transform 0.3s ease;
            max-height: 60vh;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
        }
        
        .wire-analysis-fixed.collapsed {
            transform: translateY(calc(100% - 60px));
        }

        .analysis-tabs {
            display: flex;
            margin-bottom: 16px;
            border-radius: 8px;
            overflow: hidden;
            background: rgba(255,255,255,0.1);
            flex-wrap: wrap;
        }

        .analysis-tab {
            flex: 1;
            padding: 10px 6px;
            background: rgba(255,255,255,0.1);
            border: none;
            color: #ccc;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 60px;
            text-align: center;
        }

        .analysis-tab.active {
            background: #00ff88;
            color: #000;
        }

        .analysis-tab:hover {
            background: rgba(255,255,255,0.2);
        }

        .analysis-tab.active:hover {
            background: #00cc66;
        }

        .vir-triangle {
            text-align: center;
            margin-bottom: 20px;
            background: rgba(255,255,255,0.1);
            padding: 16px;
            border-radius: 12px;
            border: 2px solid rgba(255,255,255,0.3);
        }

        .triangle-container {
            position: relative;
            width: 160px;
            height: 140px;
            margin: 0 auto 16px;
        }

        .triangle-shape {
            width: 0;
            height: 0;
            border-left: 80px solid transparent;
            border-right: 80px solid transparent;
            border-bottom: 140px solid rgba(0,255,136,0.3);
            position: relative;
            margin: 0 auto;
        }

        .triangle-sections {
            position: absolute;
            top: 0;
            left: 0;
            width: 160px;
            height: 140px;
        }

        .triangle-v {
            position: absolute;
            top: 15px;
            left: 50%;
            transform: translateX(-50%);
            color: #ff4444;
            font-size: 20px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .triangle-i {
            position: absolute;
            bottom: 15px;
            left: 25%;
            transform: translateX(-50%);
            color: #ff8844;
            font-size: 20px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .triangle-r {
            position: absolute;
            bottom: 15px;
            right: 25%;
            transform: translateX(50%);
            color: #44ff88;
            font-size: 20px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .triangle-v:hover, .triangle-i:hover, .triangle-r:hover {
            transform: translateX(-50%) scale(1.2);
            text-shadow: 0 0 10px currentColor;
        }

        .triangle-formula {
            color: #00ff88;
            font-size: 12px;
            margin-top: 10px;
            font-weight: 600;
        }

        .worksheet-panel {
            background: rgba(255,255,255,0.05);
            border: 2px solid rgba(255,255,255,0.2);
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 16px;
        }

        .worksheet-title {
            color: #00ff88;
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 16px;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .component-list {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            gap: 8px;
            margin-bottom: 16px;
        }

        .component-item {
            background: rgba(255,255,255,0.1);
            padding: 8px;
            border-radius: 8px;
            border: 1px solid rgba(255,255,255,0.3);
            text-align: center;
        }

        .component-label {
            color: #ccc;
            font-size: 10px;
            margin-bottom: 4px;
        }

        .component-value {
            color: white;
            font-weight: bold;
            font-size: 12px;
        }

        .calculations-section {
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
            padding: 12px;
            margin-top: 16px;
        }

        .calculation-step {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 8px;
            background: rgba(255,255,255,0.05);
            border-radius: 6px;
            margin-bottom: 6px;
            border-left: 3px solid;
        }

        .step-voltage { border-left-color: #ff4444; }
        .step-current { border-left-color: #ff8844; }
        .step-resistance { border-left-color: #44ff88; }
        .step-power { border-left-color: #4488ff; }

        .step-label {
            color: #ccc;
            font-size: 12px;
            font-weight: 600;
        }

        .step-formula {
            color: #888;
            font-size: 10px;
            font-family: monospace;
        }

        .step-value {
            color: white;
            font-weight: bold;
            font-size: 14px;
        }

        .problem-mode {
            background: rgba(255,165,0,0.1);
            border: 2px solid rgba(255,165,0,0.3);
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 16px;
        }

        .problem-title {
            color: #ffaa00;
            font-weight: bold;
            margin-bottom: 12px;
            text-align: center;
            font-size: 16px;
        }

        .unknown-input {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }

        .unknown-input label {
            font-size: 12px;
            width: 100px;
        }

        .unknown-input input {
            width: 70px;
            padding: 6px;
            border: 2px solid #555;
            border-radius: 6px;
            background: rgba(255,255,255,0.1);
            color: white;
            text-align: center;
            font-weight: bold;
            font-size: 12px;
        }

        .unknown-input input:focus {
            outline: none;
            border-color: #00ff88;
        }

        .check-answer-btn {
            background: linear-gradient(135deg, #00ff88, #00cc66);
            color: #000;
            border: none;
            padding: 8px 16px;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 12px;
            width: 100%;
        }

        .check-answer-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0,255,136,0.3);
        }

        .result-feedback {
            padding: 8px;
            border-radius: 8px;
            margin-top: 8px;
            font-weight: bold;
            text-align: center;
            font-size: 12px;
        }

        .feedback-correct {
            background: rgba(0,255,0,0.2);
            border: 2px solid #00ff00;
            color: #00ff88;
        }

        .feedback-incorrect {
            background: rgba(255,0,0,0.2);
            border: 2px solid #ff0000;
            color: #ff6666;
        }

        .circuit-diagram {
            background: rgba(255,255,255,0.05);
            border: 2px solid rgba(255,255,255,0.2);
            border-radius: 12px;
            padding: 12px;
            margin-bottom: 16px;
            min-height: 120px;
            position: relative;
        }

        .diagram-title {
            color: #00ff88;
            font-size: 14px;
            font-weight: bold;
            margin-bottom: 8px;
            text-align: center;
        }

        .circuit-schematic {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100px;
            font-family: monospace;
            color: #ccc;
            line-height: 1.2;
            font-size: 11px;
        }

        .schematic-line {
            margin: 1px 0;
            white-space: pre;
        }

        .practice-problem-card {
            background: rgba(0,150,255,0.1);
            border: 2px solid rgba(0,150,255,0.3);
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 16px;
        }

        .problem-question {
            color: #4da6ff;
            font-weight: bold;
            font-size: 16px;
            margin-bottom: 12px;
            text-align: center;
        }

        .problem-description {
            color: #ccc;
            margin-bottom: 12px;
            text-align: center;
            font-size: 14px;
        }

        .circuit-status {
            background: rgba(255,255,255,0.1);
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 12px;
            text-align: center;
        }

        .status-complete {
            border: 2px solid #00ff88;
            color: #00ff88;
        }

        .status-incomplete {
            border: 2px solid #ffaa00;
            color: #ffaa00;
        }

        .wire-instructions {
            background: rgba(255,200,0,0.1);
            border: 1px solid rgba(255,200,0,0.3);
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 12px;
            color: #ffcc66;
            font-size: 12px;
            text-align: center;
        }

        .wire-table-wrapper {
            background: rgba(14, 30, 58, 0.55);
            border: 1px solid rgba(136, 204, 255, 0.25);
            border-radius: 12px;
            padding: 12px;
            margin-top: 12px;
        }

        .wire-table-header {
            display: flex;
            align-items: baseline;
            justify-content: space-between;
            font-weight: 700;
            color: #8bc7ff;
            font-size: 14px;
            margin-bottom: 6px;
        }

        .wire-table-header span {
            color: rgba(199, 222, 255, 0.8);
            font-size: 11px;
            font-weight: 500;
        }

        .wire-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 12px;
        }

        .wire-table th,
        .wire-table td {
            border: 1px solid rgba(136, 204, 255, 0.2);
            padding: 6px 8px;
            text-align: center;
        }

        .wire-table th {
            background: rgba(26, 60, 110, 0.6);
            color: rgba(199, 222, 255, 0.95);
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.04em;
        }

        .wire-table th:first-child,
        .wire-table td:first-child {
            text-align: left;
        }

        .wire-table tbody tr:nth-child(even) {
            background: rgba(12, 24, 48, 0.35);
        }

        .wire-table tbody tr:nth-child(odd) {
            background: rgba(12, 24, 48, 0.18);
        }

        .wire-table-total {
            background: rgba(40, 90, 150, 0.4) !important;
            font-weight: 700;
        }

        .wire-input {
            width: 100%;
            background: rgba(0, 0, 0, 0.25);
            border: 1px solid rgba(136, 204, 255, 0.35);
            border-radius: 6px;
            padding: 4px 6px;
            color: #cbe0ff;
            font-size: 12px;
            text-align: center;
        }

        .wire-input::placeholder {
            color: rgba(203, 224, 255, 0.45);
        }

        .wire-input:focus {
            outline: none;
            border-color: rgba(0, 200, 255, 0.75);
            background: rgba(0, 40, 80, 0.5);
        }

        .wire-cell-given {
            display: inline-block;
            font-weight: 600;
            color: #8bc7ff;
        }

        .wire-solution {
            display: none;
            font-size: 10px;
            color: rgba(180, 236, 255, 0.75);
            margin-top: 4px;
            text-transform: uppercase;
            letter-spacing: 0.04em;
        }

        .wire-table-guide {
            font-size: 11px;
            color: rgba(199, 222, 255, 0.85);
            line-height: 1.4;
            margin-bottom: 8px;
        }

        .wire-table-note {
            font-size: 10px;
            color: rgba(136, 204, 255, 0.6);
            margin-top: 8px;
            text-align: left;
        }

        .wire-table-actions {
            display: flex;
            justify-content: flex-end;
            gap: 8px;
            margin-top: 8px;
        }

        .practice-btn.secondary {
            background: transparent;
            border-color: rgba(136, 204, 255, 0.4);
            color: #9fcfff;
        }

        .practice-btn.secondary:hover {
            background: rgba(20, 60, 110, 0.5);
            border-color: rgba(136, 204, 255, 0.7);
        }

        .practice-btn.secondary[data-active="true"] {
            background: rgba(20, 80, 150, 0.6);
            border-color: rgba(136, 204, 255, 0.9);
            color: #d8f0ff;
        }

        .practice-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-bottom: 16px;
        }

        .practice-btn {
            padding: 12px 8px;
            background: linear-gradient(135deg, #333, #444);
            border: 2px solid #555;
            color: white;
            border-radius: 8px;
            font-size: 11px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
        }

        .practice-btn:hover {
            background: linear-gradient(135deg, #444, #555);
            transform: translateY(-1px);
        }

        .practice-btn.active {
            background: linear-gradient(135deg, #00ff88, #00cc66);
            color: #000;
            border-color: #00ff88;
        }
        
        .analysis-toggle {
            position: absolute;
            left: 50%;
            top: -30px;
            transform: translateX(-50%);
            background: #00ff88;
            border: 3px solid #ffffff;
            color: #000000;
            border-radius: 50%;
            width: 60px;
            height: 60px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 18px;
            box-shadow: 0 4px 12px rgba(0,255,136,0.3);
        }
        
        .menu-toggle {
            position: fixed;
            top: var(--legacy-menu-gap);
            left: var(--legacy-menu-gap);
            background: #00ff88;
            border: 3px solid #ffffff;
            color: #000000;
            border-radius: 50%;
            width: 64px;
            height: 64px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 300;
            font-weight: bold;
            font-size: 20px;
            box-shadow: 0 4px 12px rgba(0,255,136,0.3);
            transition: left 0.3s ease;
        }

        .menu-toggle.open {
            left: calc(var(--legacy-menu-gap) + var(--legacy-menu-width) + 16px);
        }
        
        .status {
            position: fixed;
            bottom: 300px;
            left: 20px;
            right: 20px;
            background: rgba(0,255,136,0.1);
            backdrop-filter: blur(10px);
            padding: 16px 20px;
            border-radius: 16px;
            border: 1px solid rgba(0,255,136,0.3);
            z-index: 100;
            color: #00ff88;
            font-weight: 600;
            text-align: center;
            font-size: 16px;
            line-height: 1.4;
        }
        
        .edit-popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.95);
            backdrop-filter: blur(15px);
            border: 2px solid #00ff88;
            border-radius: 16px;
            padding: 24px;
            z-index: 10001;
            display: none;
            width: 90%;
            max-width: 400px;
            max-height: 80vh;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            box-shadow: 0 10px 30px rgba(0,255,136,0.3);
            touch-action: auto;
        }
        
        .edit-popup h3 {
            color: #00ff88;
            margin: 0 0 20px 0;
            text-align: center;
            font-size: 20px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .edit-row {
            margin-bottom: 20px;
        }
        
        .edit-row label {
            display: block;
            color: #ccc;
            margin-bottom: 8px;
            font-size: 16px;
            font-weight: 600;
        }
        
        .edit-row input, .edit-row select {
            width: 100%;
            padding: 16px;
            border: 2px solid #555;
            border-radius: 12px;
            background: rgba(255,255,255,0.1);
            color: white;
            font-size: 16px;
            transition: border-color 0.3s ease;
            min-height: 56px;
        }
        
        .edit-row input:focus, .edit-row select:focus {
            outline: none;
            border-color: #00ff88;
            box-shadow: 0 0 10px rgba(0,255,136,0.2);
        }
        
        .edit-buttons {
            display: flex;
            gap: 16px;
            margin-top: 24px;
        }
        
        .edit-btn {
            flex: 1;
            padding: 16px;
            border: none;
            border-radius: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 16px;
            min-height: 56px;
        }
        
        .edit-btn.save {
            background: linear-gradient(135deg, #00ff88, #00cc66);
            color: #000;
        }
        
        .e<!DOCTYPE html>
<html>
<head>
    <title>CircuiTry - Professional Circuit Design</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <style>
        * { 
            margin: 0; 
            padding: 0; 
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        
        body { 
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            color: white; 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            touch-action: none;
            position: fixed;
            width: 100%;
            height: 100%;
            -webkit-overflow-scrolling: touch;
        }

        :root {
            --legacy-menu-gap: 20px;
            --legacy-menu-width: clamp(260px, 22vw, 360px);
        }
        
        .menu-bar {
            position: fixed;
            top: var(--legacy-menu-gap);
            bottom: var(--legacy-menu-gap);
            left: var(--legacy-menu-gap);
            right: auto;
            width: var(--legacy-menu-width);
            height: calc(100vh - (var(--legacy-menu-gap) * 2));
            z-index: 100;
            background: rgba(0,0,0,0.95);
            backdrop-filter: blur(15px);
            border-right: 2px solid rgba(0,255,136,0.3);
            border-radius: 16px;
            padding: 16px 18px;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            box-shadow: 6px 0 24px rgba(0, 0, 0, 0.35);
        }
        
        .menu-bar.hidden {
            transform: translateX(calc(-100% - var(--legacy-menu-gap)));
            box-shadow: none;
        }
        
        .menu-tabs {
            display: flex;
            flex-direction: column;
            gap: 12px;
            justify-content: flex-start;
            max-width: 100%;
            margin: 0;
            flex: 1 1 auto;
            min-height: 0;
            overflow-y: auto;
            padding-right: 6px;
        }
        
        .menu-tab {
            padding: 16px 20px;
            background: linear-gradient(135deg, #333, #444);
            border: 2px solid #555;
            color: white;
            border-radius: 12px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            white-space: nowrap;
            position: relative;
            text-align: center;
            min-height: 56px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .menu-tab:hover, .menu-tab:active {
            background: linear-gradient(135deg, #444, #555);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,255,136,0.2);
        }
        
        .menu-tab.active {
            background: linear-gradient(135deg, #00ff88, #00cc66);
            color: #000;
            border-color: #00ff88;
            box-shadow: 0 0 20px rgba(0,255,136,0.4);
        }
        
        .submenu {
            background: rgba(0,0,0,0.95);
            backdrop-filter: blur(15px);
            border: 2px solid rgba(0,255,136,0.3);
            border-radius: 12px;
            padding: 16px;
            margin-top: 8px;
            display: none;
            width: 100%;
            z-index: 200;
        }
        
        .submenu.active {
            display: block;
        }
        
        .submenu-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
        }
        
        .submenu-row {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin-bottom: 12px;
        }
        
        .submenu-row:last-child {
            margin-bottom: 0;
        }
        
        .btn { 
            padding: 16px 20px; 
            background: linear-gradient(135deg, #333, #444);
            border: 2px solid #555;
            color: white; 
            border-radius: 12px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            white-space: nowrap;
            min-height: 56px;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
        }
        
        .btn:hover, .btn:active { 
            background: linear-gradient(135deg, #444, #555);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }
        
        .wire-btn.active { 
            background: linear-gradient(135deg, #00ff88, #00cc66);
            color: #000;
            border-color: #00ff88;
            box-shadow: 0 0 20px rgba(0,255,136,0.4);
        }
        
        .rotate-btn.active { 
            background: linear-gradient(135deg, #8800ff, #6600cc);
            border-color: #8800ff;
            box-shadow: 0 0 20px rgba(136,0,255,0.4);
        }
        
        .wire-analysis-fixed {
            position: fixed;
            bottom: 20px;
            left: 20px;
            right: 20px;
            background: rgba(0,0,0,0.95);
            backdrop-filter: blur(15px);
            padding: 20px;
            border-radius: 16px;
            border: 2px solid rgba(0,255,136,0.4);
            z-index: 90;
            transition: transform 0.3s ease;
            max-height: 60vh;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
        }
        
        .wire-analysis-fixed.collapsed {
            transform: translateY(calc(100% - 60px));
        }

        .analysis-tabs {
            display: flex;
            margin-bottom: 16px;
            border-radius: 8px;
            overflow: hidden;
            background: rgba(255,255,255,0.1);
            flex-wrap: wrap;
        }

        .analysis-tab {
            flex: 1;
            padding: 10px 6px;
            background: rgba(255,255,255,0.1);
            border: none;
            color: #ccc;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 60px;
            text-align: center;
        }

        .analysis-tab.active {
            background: #00ff88;
            color: #000;
        }

        .analysis-tab:hover {
            background: rgba(255,255,255,0.2);
        }

        .analysis-tab.active:hover {
            background: #00cc66;
        }

        .vir-triangle {
            text-align: center;
            margin-bottom: 20px;
            background: rgba(255,255,255,0.1);
            padding: 16px;
            border-radius: 12px;
            border: 2px solid rgba(255,255,255,0.3);
        }

        .triangle-container {
            position: relative;
            width: 160px;
            height: 140px;
            margin: 0 auto 16px;
        }

        .triangle-shape {
            width: 0;
            height: 0;
            border-left: 80px solid transparent;
            border-right: 80px solid transparent;
            border-bottom: 140px solid rgba(0,255,136,0.3);
            position: relative;
            margin: 0 auto;
        }

        .triangle-sections {
            position: absolute;
            top: 0;
            left: 0;
            width: 160px;
            height: 140px;
        }

        .triangle-v {
            position: absolute;
            top: 15px;
            left: 50%;
            transform: translateX(-50%);
            color: #ff4444;
            font-size: 20px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .triangle-i {
            position: absolute;
            bottom: 15px;
            left: 25%;
            transform: translateX(-50%);
            color: #ff8844;
            font-size: 20px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .triangle-r {
            position: absolute;
            bottom: 15px;
            right: 25%;
            transform: translateX(50%);
            color: #44ff88;
            font-size: 20px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .triangle-v:hover, .triangle-i:hover, .triangle-r:hover {
            transform: translateX(-50%) scale(1.2);
            text-shadow: 0 0 10px currentColor;
        }

        .triangle-formula {
            color: #00ff88;
            font-size: 12px;
            margin-top: 10px;
            font-weight: 600;
        }

        .worksheet-panel {
            background: rgba(255,255,255,0.05);
            border: 2px solid rgba(255,255,255,0.2);
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 16px;
        }

        .worksheet-title {
            color: #00ff88;
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 16px;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .component-list {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            gap: 8px;
            margin-bottom: 16px;
        }

        .component-item {
            background: rgba(255,255,255,0.1);
            padding: 8px;
            border-radius: 8px;
            border: 1px solid rgba(255,255,255,0.3);
            text-align: center;
        }

        .component-label {
            color: #ccc;
            font-size: 10px;
            margin-bottom: 4px;
        }

        .component-value {
            color: white;
            font-weight: bold;
            font-size: 12px;
        }

        .calculations-section {
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
            padding: 12px;
            margin-top: 16px;
        }

        .calculation-step {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 8px;
            background: rgba(255,255,255,0.05);
            border-radius: 6px;
            margin-bottom: 6px;
            border-left: 3px solid;
        }

        .step-voltage { border-left-color: #ff4444; }
        .step-current { border-left-color: #ff8844; }
        .step-resistance { border-left-color: #44ff88; }
        .step-power { border-left-color: #4488ff; }

        .step-label {
            color: #ccc;
            font-size: 12px;
            font-weight: 600;
        }

        .step-formula {
            color: #888;
            font-size: 10px;
            font-family: monospace;
        }

        .step-value {
            color: white;
            font-weight: bold;
            font-size: 14px;
        }

        .problem-mode {
            background: rgba(255,165,0,0.1);
            border: 2px solid rgba(255,165,0,0.3);
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 16px;
        }

        .problem-title {
            color: #ffaa00;
            font-weight: bold;
            margin-bottom: 12px;
            text-align: center;
            font-size: 16px;
        }

        .unknown-input {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }

        .unknown-input label {
            font-size: 12px;
            width: 100px;
        }

        .unknown-input input {
            width: 70px;
            padding: 6px;
            border: 2px solid #555;
            border-radius: 6px;
            background: rgba(255,255,255,0.1);
            color: white;
            text-align: center;
            font-weight: bold;
            font-size: 12px;
        }

        .unknown-input input:focus {
            outline: none;
            border-color: #00ff88;
        }

        .check-answer-btn {
            background: linear-gradient(135deg, #00ff88, #00cc66);
            color: #000;
            border: none;
            padding: 8px 16px;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 12px;
            width: 100%;
        }

        .check-answer-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0,255,136,0.3);
        }

        .result-feedback {
            padding: 8px;
            border-radius: 8px;
            margin-top: 8px;
            font-weight: bold;
            text-align: center;
            font-size: 12px;
        }

        .feedback-correct {
            background: rgba(0,255,0,0.2);
            border: 2px solid #00ff00;
            color: #00ff88;
        }

        .feedback-incorrect {
            background: rgba(255,0,0,0.2);
            border: 2px solid #ff0000;
            color: #ff6666;
        }

        .circuit-diagram {
            background: rgba(255,255,255,0.05);
            border: 2px solid rgba(255,255,255,0.2);
            border-radius: 12px;
            padding: 12px;
            margin-bottom: 16px;
            min-height: 120px;
            position: relative;
        }

        .diagram-title {
            color: #00ff88;
            font-size: 14px;
            font-weight: bold;
            margin-bottom: 8px;
            text-align: center;
        }

        .circuit-schematic {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100px;
            font-family: monospace;
            color: #ccc;
            line-height: 1.2;
            font-size: 11px;
        }

        .schematic-line {
            margin: 1px 0;
            white-space: pre;
        }

        .practice-problem-card {
            background: rgba(0,150,255,0.1);
            border: 2px solid rgba(0,150,255,0.3);
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 16px;
        }

        .problem-question {
            color: #4da6ff;
            font-weight: bold;
            font-size: 16px;
            margin-bottom: 12px;
            text-align: center;
        }

        .problem-description {
            color: #ccc;
            margin-bottom: 12px;
            text-align: center;
            font-size: 14px;
        }

        .circuit-status {
            background: rgba(255,255,255,0.1);
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 12px;
            text-align: center;
        }

        .status-complete {
            border: 2px solid #00ff88;
            color: #00ff88;
        }

        .status-incomplete {
            border: 2px solid #ffaa00;
            color: #ffaa00;
        }

        .wire-instructions {
            background: rgba(255,200,0,0.1);
            border: 1px solid rgba(255,200,0,0.3);
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 12px;
            color: #ffcc66;
            font-size: 12px;
            text-align: center;
        }

        .practice-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-bottom: 16px;
        }

        .practice-btn {
            padding: 12px 8px;
            background: linear-gradient(135deg, #333, #444);
            border: 2px solid #555;
            color: white;
            border-radius: 8px;
            font-size: 11px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
        }

        .practice-btn:hover {
            background: linear-gradient(135deg, #444, #555);
            transform: translateY(-1px);
        }

        .practice-btn.active {
            background: linear-gradient(135deg, #00ff88, #00cc66);
            color: #000;
            border-color: #00ff88;
        }
        
        .analysis-toggle {
            position: absolute;
            left: 50%;
            top: -30px;
            transform: translateX(-50%);
            background: #00ff88;
            border: 3px solid #ffffff;
            color: #000000;
            border-radius: 50%;
            width: 60px;
            height: 60px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 18px;
            box-shadow: 0 4px 12px rgba(0,255,136,0.3);
        }
        
        .menu-toggle {
            position: fixed;
            top: var(--legacy-menu-gap);
            left: var(--legacy-menu-gap);
            background: #00ff88;
            border: 3px solid #ffffff;
            color: #000000;
            border-radius: 50%;
            width: 64px;
            height: 64px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 300;
            font-weight: bold;
            font-size: 20px;
            box-shadow: 0 4px 12px rgba(0,255,136,0.3);
            transition: left 0.3s ease;
        }

        .menu-toggle.open {
            left: calc(var(--legacy-menu-gap) + var(--legacy-menu-width) + 16px);
        }
        
        .status {
            position: fixed;
            bottom: 300px;
            left: 20px;
            right: 20px;
            background: rgba(0,255,136,0.1);
            backdrop-filter: blur(10px);
            padding: 16px 20px;
            border-radius: 16px;
            border: 1px solid rgba(0,255,136,0.3);
            z-index: 100;
            color: #00ff88;
            font-weight: 600;
            text-align: center;
            font-size: 16px;
            line-height: 1.4;
        }
        
        .edit-popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.95);
            backdrop-filter: blur(15px);
            border: 2px solid #00ff88;
            border-radius: 16px;
            padding: 24px;
            z-index: 10001;
            display: none;
            width: 90%;
            max-width: 400px;
            max-height: 80vh;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            box-shadow: 0 10px 30px rgba(0,255,136,0.3);
            touch-action: auto;
        }
        
        .edit-popup h3 {
            color: #00ff88;
            margin: 0 0 20px 0;
            text-align: center;
            font-size: 20px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .edit-row {
            margin-bottom: 20px;
        }
        
        .edit-row label {
            display: block;
            color: #ccc;
            margin-bottom: 8px;
            font-size: 16px;
            font-weight: 600;
        }
        
        .edit-row input, .edit-row select {
            width: 100%;
            padding: 16px;
            border: 2px solid #555;
            border-radius: 12px;
            background: rgba(255,255,255,0.1);
            color: white;
            font-size: 16px;
            transition: border-color 0.3s ease;
            min-height: 56px;
        }
        
        .edit-row input:focus, .edit-row select:focus {
            outline: none;
            border-color: #00ff88;
            box-shadow: 0 0 10px rgba(0,255,136,0.2);
        }
        
        .edit-buttons {
            display: flex;
            gap: 16px;
            margin-top: 24px;
        }
        
        .edit-btn {
            flex: 1;
            padding: 16px;
            border: none;
            border-radius: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 16px;
            min-height: 56px;
        }
        
        .edit-btn.save {
            background: linear-gradient(135deg, #00ff88, #00cc66);
            color: #000;
        }
        
        .edit-btn.cancel {
            background: linear-gradient(135deg, #ff4444, #cc3333);
            color: white;
        }
        
        .edit-btn:hover, .edit-btn:active {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }
        
        .edit-popup-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        
        .edit-close {
            background: transparent;
            border: none;
            color: #ff4444;
            font-size: 28px;
            cursor: pointer;
            padding: 0;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .edit-actions {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        
        .edit-action-btn {
            width: 100%;
            padding: 16px;
            border: 2px solid #00ff88;
            border-radius: 12px;
            background: rgba(0,255,136,0.1);
            color: white;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            min-height: 56px;
        }
        
        .edit-action-btn:hover, .edit-action-btn:active {
            background: rgba(0,255,136,0.2);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,255,136,0.3);
        }
        
        .edit-action-btn.delete-btn {
            border-color: #ff4444;
            background: rgba(255,68,68,0.1);
        }
        
        .edit-action-btn.delete-btn:hover, .edit-action-btn.delete-btn:active {
            background: rgba(255,68,68,0.2);
            box-shadow: 0 4px 12px rgba(255,68,68,0.3);
        }
        
        .wire-analysis {
            text-align: center;
            margin-bottom: 16px;
            background: rgba(0,255,136,0.1);
            padding: 20px;
            border-radius: 16px;
            border: 2px solid rgba(0,255,136,0.3);
        }
        
        .wire-title {
            color: #00ff88;
            font-weight: bold;
            font-size: 20px;
            margin-bottom: 16px;
            text-transform: uppercase;
            letter-spacing: 2px;
            text-shadow: 0 0 10px rgba(0,255,136,0.5);
        }
        
        .wire-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            margin-bottom: 12px;
        }
        
        .wire-item {
            background: rgba(255,255,255,0.12);
            padding: 16px 12px;
            border-radius: 12px;
            border: 2px solid;
            text-align: center;
            transition: all 0.3s ease;
            min-height: 80px;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }
        
        .wire-item:hover, .wire-item:active {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }
        
        .wire-letter {
            font-weight: bold;
            font-size: 28px;
            margin-bottom: 6px;
            text-shadow: 0 0 8px currentColor;
        }
        
        .wire-label {
            color: #ccc;
            font-size: 11px;
            text-transform: uppercase;
            margin-bottom: 6px;
            letter-spacing: 0.5px;
        }
        
        .wire-value {
            font-weight: bold;
            font-size: 18px;
            text-shadow: 0 0 6px currentColor;
        }
        
        .wire-w { border-color: #4488ff; }
        .wire-w .wire-letter { color: #4488ff; }
        .wire-w .wire-value { color: #4488ff; }
        
        .wire-i { border-color: #ff8844; }
        .wire-i .wire-letter { color: #ff8844; }
        .wire-i .wire-value { color: #ff8844; }
        
        .wire-r { border-color: #44ff88; }
        .wire-r .wire-letter { color: #44ff88; }
        .wire-r .wire-value { color: #44ff88; }
        
        .wire-e { border-color: #ff4444; }
        .wire-e .wire-letter { color: #ff4444; }
        .wire-e .wire-value { color: #ff4444; }
        
        #canvas {
            width: 100vw;
            height: 100vh;
            display: block;
            touch-action: none;
            position: fixed;
            top: 0;
            left: 0;
            background-color: #0a0a1a;
        }
        
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 20px;
            z-index: 1000;
            text-align: center;
            padding: 20px;
        }
        
        .component-label {
            position: absolute;
            pointer-events: none;
            color: white;
            font-weight: bold;
            font-size: 14px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            white-space: nowrap;
            z-index: 10;
            background: rgba(0,0,0,0.7);
            padding: 4px 8px;
            border-radius: 8px;
            border: 1px solid rgba(255,255,255,0.3);
        }

        .component-label.component-label-floating {
            background: transparent;
            padding: 0;
            border: none;
            border-radius: 0;
            text-shadow:
                0 0 2px rgba(0, 0, 0, 0.95),
                0 0 8px rgba(0, 0, 0, 0.85);
        }
        
        .branding-overlay {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 32px;
            font-weight: 900;
            pointer-events: none;
            z-index: 1;
            user-select: none;
            letter-spacing: -1px;
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
            text-align: center;
            line-height: 1;
            animation: brandingFloat 6s ease-in-out infinite;
        }
        
        .branding-overlay .logo-circui {
            color: rgba(0, 255, 136, 0.15);
            text-shadow: 0 0 12px rgba(0,255,136,0.3), 0 0 24px rgba(0,136,255,0.1);
        }
        
        .branding-overlay .logo-try {
            color: rgba(255, 136, 0, 0.15);
            text-shadow: 0 0 12px rgba(255,136,0,0.3), 0 0 24px rgba(255,255,255,0.08);
        }
        
        .branding-overlay .logo-3d {
            color: rgba(0, 255, 136, 0.15);
            text-shadow: 0 0 12px rgba(0,255,136,0.3), 0 0 24px rgba(0,136,255,0.1);
        }
        
        @keyframes brandingFloat {
            0%, 100% { 
                transform: translateX(-50%) translateY(0px);
                opacity: 0.8;
            }
            50% { 
                transform: translateX(-50%) translateY(-10px);
                opacity: 1;
            }
        }
        
        .branding-overlay.bounce {
            animation: brandingBounce 4s ease-in-out infinite;
        }
        
        @keyframes brandingBounce {
            0%, 100% { 
                transform: translateX(-50%) translateY(0px);
            }
            25% { 
                transform: translateX(-50%) translateY(-20px);
            }
            50% { 
                transform: translateX(-50%) translateY(0px);
            }
            75% { 
                transform: translateX(-50%) translateY(-10px);
            }
        }
        
        .polarity-indicator {
            position: absolute;
            pointer-events: none;
            font-size: 20px;
            font-weight: bold;
            z-index: 15;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.9);
            background: rgba(0,0,0,0.7);
            padding: 2px 6px;
            border-radius: 50%;
            border: 2px solid;
        }
        
        .polarity-positive {
            color: #ff4444;
            border-color: #ff4444;
        }
        
        .polarity-negative {
            color: #4444ff;
            border-color: #4444ff;
        }

        /* Desktop styles for larger screens */
        @media (min-width: 769px) {
            .wire-analysis-fixed {
                top: 80px;
                right: 20px;
                left: auto;
                bottom: auto;
                max-width: 320px;
                max-height: none;
            }
            
            .wire-analysis-fixed.collapsed {
                transform: translateX(calc(100% - 60px));
            }
            
            .analysis-toggle {
                left: -40px;
                top: 50%;
                transform: translateY(-50%);
                width: 40px;
                height: 40px;
                font-size: 14px;
            }
            
            .status {
                bottom: 20px;
                left: 50%;
                right: auto;
                transform: translateX(-50%);
                max-width: 600px;
                font-size: 14px;
            }
            
            .menu-toggle {
                width: 45px;
                height: 45px;
                font-size: 16px;
            }
            
            .edit-popup {
                position: fixed;
                width: 320px;
                max-width: none;
            }
        }

        /* Stack menu across the top on narrow screens */
        @media (max-width: 720px) {
            .menu-bar {
                top: 0;
                bottom: auto;
                left: 0;
                right: 0;
                width: 100%;
                height: auto;
                max-height: 90vh;
                border-right: none;
                border-bottom: 2px solid rgba(0,255,136,0.3);
                border-radius: 0 0 16px 16px;
                padding: 12px 16px;
                box-shadow: 0 8px 24px rgba(0,0,0,0.35);
            }

            .menu-bar.hidden {
                transform: translateY(-100%);
            }

            .menu-tabs {
                padding-right: 0;
            }

            .menu-toggle {
                top: 15px;
                left: 15px;
            }

            .menu-toggle.open {
                left: 15px;
            }
        }

        /* Additional mobile optimizations */
        @media (max-width: 480px) {
            .menu-bar {
                padding: 8px 12px;
            }
            
            .menu-tab {
                padding: 14px 16px;
                font-size: 15px;
            }
            
            .btn {
                padding: 14px 16px;
                font-size: 15px;
            }
            
            .wire-analysis-fixed {
                padding: 16px;
                left: 10px;
                right: 10px;
                bottom: 10px;
            }
            
            .status {
                bottom: 280px;
                left: 10px;
                right: 10px;
                padding: 12px 16px;
                font-size: 15px;
            }
            
            .menu-toggle {
                top: 15px;
                left: 15px;
                width: 56px;
                height: 56px;
            }
            
            .analysis-toggle {
                width: 56px;
                height: 56px;
                top: -28px;
            }
        }

        /* High DPI screens */
        @media (-webkit-min-device-pixel-ratio: 2), (min-resolution: 192dpi) {
            .component-label {
                font-size: 16px;
            }
            
            .wire-letter {
                font-size: 32px;
            }
            
            .wire-value {
                font-size: 20px;
            }
        }

        /* Landscape orientation on mobile */
        @media (orientation: landscape) and (max-height: 500px) {
            .wire-analysis-fixed {
                max-height: 30vh;
            }
            
            .menu-bar {
                max-height: 70vh;
            }
            
            .status {
                bottom: 200px;
            }
        }

        /* Reduce animations on lower-end devices */
        @media (prefers-reduced-motion: reduce) {
            * {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }
        
        /* Landing Page Styles */
        .landing-page {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f1419 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            padding: 20px;
            box-sizing: border-box;
        }
        
        .landing-logo {
            font-size: clamp(48px, 12vw, 92px);
            font-weight: 900;
            text-align: center;
            margin-bottom: 20px;
            letter-spacing: -2px;
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
        }
        .logo-circui { color: #00ff88; text-shadow: 0 0 12px rgba(0,255,136,0.6), 0 0 24px rgba(0,136,255,0.2); }
        .logo-try { color: #ff8800; text-shadow: 0 0 12px rgba(255,136,0,0.6), 0 0 24px rgba(255,255,255,0.15); }
        .logo-pulse { animation: logoPulse 2.2s ease-in-out infinite; }
        @keyframes logoPulse {
            0% { filter: drop-shadow(0 0 8px rgba(100,160,255,0.4)) drop-shadow(0 0 18px rgba(255,255,255,0.25)); }
            50% { filter: drop-shadow(0 0 14px rgba(140,200,255,0.8)) drop-shadow(0 0 28px rgba(255,255,255,0.35)); }
            100% { filter: drop-shadow(0 0 10px rgba(100,160,255,0.6)) drop-shadow(0 0 24px rgba(255,255,255,0.3)); }
        }
        
        .landing-subtitle {
            font-size: clamp(14px, 3vw, 18px);
            color: #8899aa;
            text-align: center;
            margin-bottom: 40px;
            letter-spacing: 3px;
            text-transform: uppercase;
            font-weight: 500;
        }
        
        .circuit-preview {
            width: min(90vw, 400px);
            height: 180px;
            background: rgba(0, 20, 40, 0.6);
            border: 3px solid #00ff88;
            border-radius: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 30px;
            position: relative;
            overflow: hidden;
            backdrop-filter: blur(10px);
        }
        
        .circuit-preview::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(0, 255, 136, 0.1), transparent);
            animation: shimmer 3s infinite;
        }
        
        @keyframes shimmer {
            0% { left: -100%; }
            100% { left: 100%; }
        }
        
        .circuit-svg {
            width: 320px;
            height: 140px;
        }
        
        .circuit-element {
            stroke: #00ff88;
            stroke-width: 2.5;
            fill: none;
        }
        
        .circuit-wire {
            stroke: #66bbff;
            stroke-width: 2;
            fill: none;
        }
        
        .circuit-text {
            fill: #ffffff;
            font-family: 'Segoe UI', sans-serif;
            font-size: 12px;
            font-weight: bold;
        }
        
        .circuit-voltage {
            fill: #ff6666;
            font-size: 11px;
        }
        
        .launch-button {
            background: linear-gradient(135deg, #00ff88 0%, #00cc66 100%);
            color: #000;
            border: none;
            padding: 18px 40px;
            border-radius: 25px;
            font-size: clamp(16px, 4vw, 20px);
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
            box-shadow: 0 8px 25px rgba(0, 255, 136, 0.3);
            margin-bottom: 30px;
        }
        
        .launch-button:hover {
            transform: translateY(-3px);
            box-shadow: 0 12px 35px rgba(0, 255, 136, 0.4);
            background: linear-gradient(135deg, #00ff88 0%, #00dd77 100%);
        }
        
        .launch-button:active {
            transform: translateY(-1px);
        }
        
        .loading-progress {
            width: min(80vw, 300px);
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            overflow: hidden;
            margin-bottom: 20px;
        }
        
        .loading-bar {
            height: 100%;
            background: linear-gradient(90deg, #00ff88, #00cc66, #00ff88);
            background-size: 200% 100%;
            animation: loading 2s ease-in-out;
            border-radius: 2px;
        }
        
        @keyframes loading {
            0% { width: 0%; }
            50% { width: 70%; }
            100% { width: 100%; }
        }
        
        .loading-text {
            color: #00ff88;
            font-size: clamp(14px, 3.5vw, 16px);
            font-weight: 600;
            text-align: center;
            margin-bottom: 15px;
        }
        
        .version-text {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            color: #666;
            font-size: 12px;
        }
        
        .landing-hidden {
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s ease;
        }
        
        /* Subscription Pricing Overlay */
        .subscription-overlay-backdrop {
            position: fixed;
            inset: 0;
            z-index: 110;
            background: rgba(4, 12, 24, 0.78);
            backdrop-filter: blur(6px);
            display: none;
        }
        
        .subscription-overlay-backdrop.visible {
            display: block;
        }
        
        .subscription-overlay {
            position: fixed;
            inset: auto;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: min(960px, calc(100vw - 48px));
            max-height: calc(100vh - 64px);
            padding: clamp(24px, 4vw, 40px);
            background: rgba(12, 24, 48, 0.96);
            border: 1px solid rgba(0, 255, 136, 0.28);
            border-radius: 28px;
            box-shadow: 0 40px 90px rgba(0, 0, 0, 0.55);
            color: #e8f6ff;
            overflow-y: auto;
            display: none;
            flex-direction: column;
            gap: clamp(24px, 4vw, 40px);
            z-index: 120;
            backdrop-filter: blur(12px);
        }
        
        .subscription-overlay.visible {
            display: flex;
        }
        
        .subscription-overlay:focus {
            outline: none;
        }
        
        .subscription-close {
            position: absolute;
            top: 18px;
            right: 18px;
            width: 40px;
            height: 40px;
            border-radius: 999px;
            border: 1px solid rgba(232, 246, 255, 0.35);
            background: radial-gradient(circle at 50% 50%, rgba(0, 255, 136, 0.25), rgba(0, 0, 0, 0.65));
            color: #e8f6ff;
            font-size: 24px;
            font-weight: 600;
            line-height: 1;
            cursor: pointer;
            display: grid;
            place-items: center;
            transition: transform 0.2s ease, box-shadow 0.2s ease, border-color 0.2s ease;
        }
        
        .subscription-close:hover,
        .subscription-close:focus-visible {
            transform: scale(1.05);
            box-shadow: 0 0 18px rgba(0, 255, 136, 0.45);
            border-color: rgba(0, 255, 136, 0.55);
        }
        
        .subscription-header {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        
        .subscription-kicker {
            font-size: 13px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.32em;
            color: rgba(0, 255, 136, 0.85);
        }
        
        .subscription-header h2 {
            font-size: clamp(26px, 4vw, 36px);
            letter-spacing: -0.02em;
        }
        
        .subscription-header p {
            color: rgba(220, 234, 255, 0.78);
            max-width: 640px;
            line-height: 1.6;
        }

        .subscription-status {
            align-self: flex-start;
            margin-top: 4px;
            padding: 12px 16px;
            border-radius: 14px;
            border: 1px solid rgba(0, 255, 136, 0.28);
            background: rgba(8, 20, 40, 0.65);
            display: inline-flex;
            flex-direction: column;
            gap: 4px;
        }

        .subscription-status-label {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.18em;
            color: rgba(220, 234, 255, 0.66);
        }

        .subscription-status-value {
            font-size: 16px;
            font-weight: 700;
            color: rgba(0, 255, 136, 0.88);
            letter-spacing: 0.08em;
        }

        .subscription-status-note {
            font-size: 12px;
            color: rgba(220, 234, 255, 0.72);
            max-width: 380px;
            line-height: 1.4;
        }
        
        .subscription-cycle-toggle {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
            align-items: center;
        }
        
        .subscription-cycle-btn {
            border: 1px solid rgba(0, 255, 136, 0.28);
            background: rgba(8, 20, 40, 0.6);
            color: #e8f6ff;
            padding: 12px 18px;
            border-radius: 999px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            transition: background 0.2s ease, border-color 0.2s ease, transform 0.2s ease;
        }
        
        .subscription-cycle-btn .subscription-cycle-note {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.12em;
            color: rgba(0, 255, 136, 0.72);
        }
        
        .subscription-cycle-btn:hover,
        .subscription-cycle-btn:focus-visible {
            border-color: rgba(0, 255, 136, 0.55);
            transform: translateY(-1px);
        }
        
        .subscription-cycle-btn.active {
            background: linear-gradient(135deg, rgba(0, 255, 136, 0.18), rgba(0, 255, 136, 0.05));
            border-color: rgba(0, 255, 136, 0.7);
            box-shadow: 0 0 18px rgba(0, 255, 136, 0.2);
        }
        
        .subscription-plan-grid {
            display: grid;
            gap: clamp(16px, 3vw, 24px);
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
        }
        
        .subscription-plan-card {
            background: linear-gradient(160deg, rgba(15, 32, 64, 0.85), rgba(10, 24, 52, 0.65));
            border: 1px solid rgba(0, 255, 136, 0.22);
            border-radius: 20px;
            padding: 24px;
            display: flex;
            flex-direction: column;
            gap: 18px;
            position: relative;
            overflow: hidden;
        }
        
        .subscription-plan-card::after {
            content: "";
            position: absolute;
            inset: 0;
            background: radial-gradient(circle at top right, rgba(0, 255, 136, 0.08), transparent 58%);
            pointer-events: none;
        }
        
        .subscription-plan-header h3 {
            font-size: 20px;
            margin-bottom: 6px;
        }
        
        .subscription-plan-header p {
            color: rgba(220, 234, 255, 0.68);
            font-size: 14px;
            margin: 0;
        }
        
        .subscription-plan-price {
            display: flex;
            flex-direction: column;
            gap: 6px;
            font-weight: 700;
        }

        .subscription-plan-renewal {
            font-size: 13px;
            color: rgba(220, 234, 255, 0.62);
        }
        
        .subscription-price-amount {
            font-size: 28px;
            letter-spacing: -0.01em;
            display: none;
        }
        
        .subscription-overlay[data-active-cycle="monthly"] .subscription-price-amount[data-price-cycle="monthly"],
        .subscription-overlay[data-active-cycle="annual"] .subscription-price-amount[data-price-cycle="annual"] {
            display: inline-flex;
        }
        
        .subscription-price-unit {
            font-size: 14px;
            color: rgba(220, 234, 255, 0.68);
        }
        
        .subscription-price-cycle-note {
            font-size: 12px;
            color: rgba(0, 255, 136, 0.65);
            text-transform: uppercase;
            letter-spacing: 0.14em;
            display: none;
        }

        .subscription-overlay[data-active-cycle="monthly"] .subscription-price-cycle-note[data-price-cycle="monthly"],
        .subscription-overlay[data-active-cycle="annual"] .subscription-price-cycle-note[data-price-cycle="annual"] {
            display: inline-flex;
        }
        
        .subscription-plan-features {
            margin: 0;
            padding: 0;
            list-style: none;
            display: flex;
            flex-direction: column;
            gap: 10px;
            color: rgba(220, 234, 255, 0.78);
        }
        
        .subscription-plan-features li::before {
            content: "?";
            color: rgba(0, 255, 136, 0.85);
            margin-right: 10px;
        }
        
        .subscription-plan-cta {
            margin-top: auto;
        }

        .subscription-plan-bulk {
            font-size: 13px;
            color: rgba(220, 234, 255, 0.68);
            background: rgba(8, 20, 40, 0.55);
            border: 1px solid rgba(0, 255, 136, 0.18);
            border-radius: 12px;
            padding: 12px;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        
        .subscription-plan-button {
            width: 100%;
            padding: 12px 16px;
            border-radius: 999px;
            border: 1px solid rgba(0, 255, 136, 0.35);
            background: rgba(0, 255, 136, 0.12);
            color: #e8f6ff;
            font-weight: 600;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            cursor: pointer;
            text-decoration: none;
            transition: transform 0.2s ease, box-shadow 0.2s ease, border-color 0.2s ease;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        
        .subscription-plan-button:hover,
        .subscription-plan-button:focus-visible {
            transform: translateY(-1px);
            box-shadow: 0 12px 30px rgba(0, 255, 136, 0.25);
            border-color: rgba(0, 255, 136, 0.6);
        }
        
        .subscription-support-grid {
            display: grid;
            gap: clamp(16px, 3vw, 24px);
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
        }
        
        .subscription-support-card {
            border: 1px solid rgba(0, 255, 136, 0.22);
            border-radius: 18px;
            padding: 20px;
            background: rgba(8, 20, 40, 0.65);
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        
        .subscription-support-badge {
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 0.18em;
            color: rgba(0, 255, 136, 0.82);
        }
        
        .subscription-support-card h4 {
            margin: 0;
            font-size: 18px;
        }
        
        .subscription-support-summary {
            color: rgba(220, 234, 255, 0.74);
            font-size: 14px;
            line-height: 1.5;
        }
        
        .subscription-support-card ul {
            margin: 0;
            padding-left: 18px;
            color: rgba(220, 234, 255, 0.78);
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .subscription-steps h3,
        .subscription-faq h3 {
            font-size: 18px;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            margin-bottom: 12px;
            color: rgba(0, 255, 136, 0.75);
        }
        
        .subscription-step-list {
            margin: 0;
            padding: 0;
            list-style: none;
            display: grid;
            gap: 16px;
        }
        
        .subscription-step {
            display: flex;
            gap: 16px;
            align-items: flex-start;
            background: rgba(8, 20, 40, 0.6);
            border: 1px solid rgba(0, 255, 136, 0.18);
            border-radius: 16px;
            padding: 16px 18px;
        }
        
        .subscription-step-number {
            font-size: 16px;
            font-weight: 700;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background: rgba(0, 255, 136, 0.18);
            border: 1px solid rgba(0, 255, 136, 0.4);
            display: flex;
            align-items: center;
            justify-content: center;
            color: #e8f6ff;
        }
        
        .subscription-step-content h4 {
            margin: 0 0 6px 0;
            font-size: 16px;
        }
        
        .subscription-step-content p {
            margin: 0;
            color: rgba(220, 234, 255, 0.78);
            line-height: 1.5;
        }
        
        .subscription-faq-grid {
            display: grid;
            gap: 14px;
            grid-template-columns: 1fr;
        }
        
        .subscription-faq-item {
            background: rgba(8, 20, 40, 0.6);
            border: 1px solid rgba(0, 255, 136, 0.18);
            border-radius: 14px;
            padding: 14px 16px;
            color: rgba(220, 234, 255, 0.85);
        }
        
        .subscription-faq-item summary {
            cursor: pointer;
            font-weight: 600;
            letter-spacing: 0.02em;
        }
        
        .subscription-faq-item p {
            margin: 10px 0 0 0;
            color: rgba(220, 234, 255, 0.78);
            line-height: 1.5;
        }
        
        .subscription-cta {
            display: flex;
            flex-direction: column;
            gap: 18px;
            padding: 20px;
            border-radius: 18px;
            border: 1px solid rgba(0, 255, 136, 0.22);
            background: linear-gradient(160deg, rgba(15, 32, 64, 0.75), rgba(10, 24, 52, 0.55));
        }
        
        .subscription-cta-text h3 {
            margin: 0 0 8px 0;
            font-size: 20px;
        }
        
        .subscription-cta-text p {
            margin: 0;
            color: rgba(220, 234, 255, 0.78);
        }
        
        .subscription-cta-actions {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
        }
        
        .subscription-cta-button {
            padding: 12px 18px;
            border-radius: 999px;
            border: 1px solid rgba(0, 255, 136, 0.35);
            background: rgba(0, 255, 136, 0.15);
            color: #e8f6ff;
            font-weight: 600;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            transition: transform 0.2s ease, box-shadow 0.2s ease, border-color 0.2s ease;
        }
        
        .subscription-cta-button:hover,
        .subscription-cta-button:focus-visible {
            transform: translateY(-1px);
            box-shadow: 0 12px 30px rgba(0, 255, 136, 0.25);
            border-color: rgba(0, 255, 136, 0.6);
        }
        
        body.subscription-pricing-open {
            overflow: hidden;
        }
        
        @media (min-width: 768px) {
            .subscription-faq-grid {
                grid-template-columns: repeat(2, minmax(0, 1fr));
            }
            
            .subscription-cta {
                flex-direction: row;
                align-items: center;
                justify-content: space-between;
            }
            
            .subscription-cta-text {
                max-width: 60%;
            }
        }
        
        @media (max-width: 599px) {
            .subscription-plan-card {
                padding: 20px;
            }
            
            .subscription-overlay {
                width: calc(100vw - 24px);
                padding: 24px 18px 28px;
            }
            
            .subscription-close {
                top: 12px;
                right: 12px;
            }
        }
        
        /* Improved circuit centering and alignment */
        .circuit-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            padding: 20px;
        }
        
        /* Professional schematic styling */
        .schematic-mode .component-label {
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.5);
            padding: 6px 10px;
            border-radius: 6px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 12px;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <!-- Landing Page -->
    <div id="landing-page" class="landing-page">
        <div class="landing-logo logo-pulse"><span class="logo-circui">Circui</span><span class="logo-try">Try</span><span style="color:#00ff88">3D</span></div>
        <div class="landing-subtitle">Professional Circuit Design</div>
        
        <div class="circuit-preview">
            <svg class="circuit-svg" viewBox="0 0 320 140">
                <!-- Main circuit outline -->
                <path class="circuit-wire" d="M 60 70 L 100 70 L 100 40 L 160 40 L 160 70 L 200 70 L 200 100 L 160 100 L 160 70" />
                <path class="circuit-wire" d="M 160 70 L 160 100 L 100 100 L 100 70" />
                
                <!-- Battery -->
                <rect class="circuit-element" x="50" y="60" width="20" height="20" />
                <text class="circuit-voltage" x="45" y="55">12V</text>
                
                <!-- Resistor R1 -->
                <rect class="circuit-element" x="150" y="30" width="20" height="20" />
                <path class="circuit-element" d="M 155 35 L 165 45 L 155 45 L 165 35" />
                <text class="circuit-text" x="158" y="28">R1</text>
                
                <!-- Resistor R2 -->
                <rect class="circuit-element" x="190" y="60" width="20" height="20" />
                <path class="circuit-element" d="M 195 65 L 205 75 L 195 75 L 205 65" />
                <text class="circuit-text" x="198" y="58">R2</text>
                
                <!-- Resistor R3 -->
                <rect class="circuit-element" x="150" y="90" width="20" height="20" />
                <path class="circuit-element" d="M 155 95 L 165 105 L 155 105 L 165 95" />
                <text class="circuit-text" x="158" y="118">R3</text>
                
                <!-- Connection dots -->
                <circle class="circuit-element" cx="160" cy="70" r="2" fill="#00ff88" />
                <circle class="circuit-element" cx="100" cy="70" r="2" fill="#00ff88" />
            </svg>
        </div>
        
        <button class="launch-button" id="launch-btn" style="display:none">
            Launch CircuiTry
        </button>
        
        <div class="loading-progress" id="loading-progress" style="display: none;">
            <div class="loading-bar"></div>
        </div>
        
        <div class="loading-text" id="loading-text" style="display: none;">
            circuit environment initializing
        </div>
        
        <div class="version-text">Professional Edition v2.0</div>
    </div>

    <div id="loading" class="loading" style="display: none;">Loading CircuiTry...</div>
    
    <button class="menu-toggle" id="menu-toggle" onclick="toggleMenuBar()">Menu</button>
    
    <div class="menu-bar" id="menu-bar" style="display: none;">
        <div class="menu-tabs">
            <div class="menu-tab" onclick="toggleSubmenu('components')">
                Components
                <div class="submenu" id="submenu-components">
                    <div class="submenu-grid">
                        <button class="btn" onclick="addComponent('battery')">Battery</button>
                        <button class="btn" onclick="addComponent('resistor')">Resistor</button>
                        <button class="btn" onclick="addComponent('led')">LED</button>
                        <button class="btn" onclick="addComponent('switch')">Switch</button>
                    </div>
                </div>
            </div>
            
            <div class="menu-tab" onclick="toggleSubmenu('tools')">
                Tools
                <div class="submenu" id="submenu-tools">
                    <div class="submenu-row">
                        <button class="btn wire-btn" id="wire-btn" onclick="toggleWireMode()">Wire</button>
                        <button class="btn rotate-btn" id="rotate-btn" onclick="toggleRotateMode()">Rotate</button>
                    </div>
                    <div class="submenu-row">
                        <button class="btn" onclick="addJunction()">Junction</button>
                        <button class="btn" onclick="arrangeByLayoutMode()">Auto-Arrange</button>
                    </div>
                    <div class="submenu-row">
                        <button class="btn" onclick="cycleRoutingMode()">Route: <span id="route-mode">Free-form</span></button>
                        <button class="btn" onclick="centerCircuit()">Center Circuit</button>
                    </div>
                    <div class="submenu-row">
                        <button class="btn" onclick="clearAll()">Clear All</button>
                    </div>
                </div>
            </div>
            
            <div class="menu-tab" onclick="toggleSubmenu('edit')">
                Edit
                <div class="submenu" id="submenu-edit">
                    <div class="submenu-row">
                        <button class="btn" onclick="undo()" id="undo-btn">Undo</button>
                        <button class="btn" onclick="redo()" id="redo-btn">Redo</button>
                    </div>
                    <div class="submenu-row">
                        <button class="btn" onclick="copySelected()">Copy</button>
                        <button class="btn" onclick="pasteSelected()">Paste</button>
                    </div>
                    <div class="submenu-row">
                        <button class="btn" onclick="selectAll()">Select All</button>
                        <button class="btn" onclick="deleteSelected()">Delete</button>
                    </div>
                </div>
            </div>
            
            <div class="menu-tab" onclick="toggleSubmenu('file')">
                File
                <div class="submenu" id="submenu-file">
                    <div class="submenu-row">
                        <button class="btn" onclick="saveCircuit()">Save</button>
                        <button class="btn" onclick="loadCircuit()">Load</button>
                    </div>
                    <div class="submenu-row">
                        <button class="btn" onclick="exportImage()">Export</button>
                        <button class="btn" onclick="newCircuit()">New</button>
                    </div>
                </div>
            </div>
            
            <div class="menu-tab" onclick="toggleSubmenu('view')">
                View
                <div class="submenu" id="submenu-view">
                    <div class="submenu-row">
                        <button class="btn" onclick="resetCamera()">Reset View</button>
                        <button class="btn" onclick="fitToScreen()">Fit Screen</button>
                    </div>
                    <div class="submenu-row">
                        <button class="btn" onclick="toggleGrid()">Toggle Grid</button>
                        <button class="btn" onclick="toggleLabels()">Labels</button>
                    </div>
                    <div class="submenu-row">
                        <button class="btn" onclick="toggleCurrentFlowStyle()">Flow: <span id="flow-style">Electron Flow</span></button>
                        <button class="btn" onclick="togglePolarityIndicators()">Polarity</button>
                    </div>
                    <div class="submenu-row">
                        <button class="btn" onclick="toggleBranding()">Branding</button>
                        <button class="btn" onclick="cycleLayoutMode()">Layout: <span id="layout-mode">Free</span></button>
                    </div>
                </div>
            </div>
            
            <div class="menu-tab" onclick="toggleSubmenu('practice')">
                Practice
                <div class="submenu" id="submenu-practice">
                    <div class="submenu-row">
                        <button class="btn" onclick="loadPresetCircuit('series_basic')">Series Circuit</button>
                        <button class="btn" onclick="loadPresetCircuit('parallel_basic')">Parallel Circuit</button>
                    </div>
                    <div class="submenu-row">
                        <button class="btn" onclick="loadPresetCircuit('mixed_circuit')">Mixed Circuit</button>
                        <button class="btn" onclick="loadPresetCircuit('combination_advanced')">Combo Challenge</button>
                    </div>
                    <div class="submenu-row">
                        <button class="btn" onclick="generateRandomProblem()">Random Problem</button>
                        <button class="btn" onclick="showPracticeModeHelp()">How to Use</button>
                    </div>
                </div>
            </div>

            <div class="menu-tab" onclick="toggleSubmenu('arena')">
                Arena
                <div class="submenu" id="submenu-arena">
                    <div class="submenu-row">
                        <button class="btn" onclick="openArena()">Open Component Arena</button>
                    </div>
                </div>
            </div>

            <div class="menu-tab" onclick="toggleSubmenu('subscription')">
                Subscription
                <div class="submenu" id="submenu-subscription">
                    <div class="submenu-row">
                        <button class="btn" onclick="openSubscriptionPricing()">Subscription Pricing</button>
                        <button class="btn" onclick="contactSubscriptionTeam()">Contact Team</button>
                    </div>
                </div>
            </div>
            
            <div class="menu-tab" onclick="toggleSubmenu('help')">
                Help
                <div class="submenu" id="submenu-help">
                    <div class="submenu-row">
                        <button class="btn" onclick="showTutorial()">Tutorial</button>
                        <button class="btn" onclick="showWireGuide()">W.I.R.E. Guide</button>
                    </div>
                    <div class="submenu-row">
                        <button class="btn" onclick="showShortcuts()">Shortcuts</button>
                        <button class="btn" onclick="showAbout()">About</button>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <div class="wire-analysis-fixed" id="wire-analysis">
        <button class="analysis-toggle" onclick="toggleAnalysis()">Toggle</button>
        
        <div class="analysis-tabs">
            <button class="analysis-tab active" onclick="switchAnalysisTab('wire')" id="tab-wire">W.I.R.E.</button>
            <button class="analysis-tab" onclick="switchAnalysisTab('eir')" id="tab-eir">EIR</button>
            <button class="analysis-tab" onclick="switchAnalysisTab('power')" id="tab-power">Power</button>
            <button class="analysis-tab" onclick="switchAnalysisTab('worksheet')" id="tab-worksheet">Sheet</button>
            <button class="analysis-tab" onclick="switchAnalysisTab('problem')" id="tab-problem">Solve</button>
            <button class="analysis-tab" onclick="switchAnalysisTab('practice')" id="tab-practice">Practice</button>
            <button class="analysis-tab" onclick="switchAnalysisTab('meter')" id="tab-meter">Meter</button>
        </div>

        <!-- W.I.R.E. Method Panel -->
        <div class="analysis-content" id="content-wire">
            <div class="wire-analysis">
                <div class="wire-title"> W.I.R.E. METHOD</div>
                <div class="wire-grid">
                    <div class="wire-item wire-w">
                        <div class="wire-letter">W</div>
                        <div class="wire-label">Watts (Power)</div>
                        <div class="wire-value" id="power">0W</div>
                    </div>
                    <div class="wire-item wire-i">
                        <div class="wire-letter">I</div>
                        <div class="wire-label">Current (Amps)</div>
                        <div class="wire-value" id="current">0A</div>
                    </div>
                    <div class="wire-item wire-r">
                        <div class="wire-letter">R</div>
                        <div class="wire-label">Resistance (Ohms)</div>
                        <div class="wire-value" id="resistance">--</div>
                    </div>
                    <div class="wire-item wire-e">
                        <div class="wire-letter">E</div>
                        <div class="wire-label">Voltage (EMF)</div>
                        <div class="wire-value" id="voltage">0V</div>
                    </div>
                </div>
                <div style="font-size: 12px; color: #888; margin-top: 12px; text-align: center;">
                    <strong> Circuit Status:</strong><br>
                    Components: <span id="count" style="color: #00ff88;">0</span> | 
                    Wires: <span id="wire-count" style="color: #ffaa88;">0</span> | 
                    Junctions: <span id="junction-count" style="color: #aa88ff;">0</span>
                    <br>
                    <strong> Topology:</strong> <span id="topology-type" style="color: #88ccff;">Unknown</span>
                </div>
            </div>
        </div>

        <!-- EIR Triangle Panel (EMF, Current, Resistance) -->
        <div class="analysis-content" id="content-eir" style="display: none;">
            <div class="vir-triangle">
                <div class="triangle-container">
                    <div class="triangle-shape"></div>
                    <div class="triangle-sections">
                        <div class="triangle-v" onclick="explainOhmsLaw('E')">E</div>
                        <div class="triangle-i" onclick="explainOhmsLaw('I')">I</div>
                        <div class="triangle-r" onclick="explainOhmsLaw('R')">R</div>
                    </div>
                </div>
                <div class="triangle-formula" id="eir-formula">
                    E = I  R | I = E  R | R = E  I
                </div>
                <div style="color: #ccc; font-size: 12px; margin-top: 12px; text-align: center;">
                    Click E, I, or R to see the formula<br>
                    <strong>E</strong> = EMF/Voltage | <strong>I</strong> = Current | <strong>R</strong> = Resistance
                </div>
            </div>
            
            <div class="circuit-diagram">
                <div class="diagram-title">Circuit Schematic</div>
                <div class="circuit-schematic" id="circuit-schematic">
                    <div class="schematic-line">     +[R]+</div>
                    <div class="schematic-line">                   </div>
                    <div class="schematic-line">   [BAT]          [R]</div>
                    <div class="schematic-line">                   </div>
                    <div class="schematic-line">     ++</div>
                </div>
            </div>
        </div>

        <!-- Power Triangle Panel (Watts, Current, EMF) -->
        <div class="analysis-content" id="content-power" style="display: none;">
            <div class="vir-triangle">
                <div class="triangle-container">
                    <div class="triangle-shape" style="border-bottom-color: rgba(68,136,255,0.3);"></div>
                    <div class="triangle-sections">
                        <div class="triangle-v" onclick="explainPowerLaw('W')" style="color: #4488ff;">W</div>
                        <div class="triangle-i" onclick="explainPowerLaw('I')" style="color: #ff8844;">I</div>
                        <div class="triangle-r" onclick="explainPowerLaw('E')" style="color: #ff4444;">E</div>
                    </div>
                </div>
                <div class="triangle-formula" id="power-formula" style="color: #4488ff;">
                    W = I  E | I = W  E | E = W  I
                </div>
                <div style="color: #ccc; font-size: 12px; margin-top: 12px; text-align: center;">
                    Click W, I, or E to see the power formula<br>
                    <strong>W</strong> = Watts/Power | <strong>I</strong> = Current | <strong>E</strong> = EMF/Voltage
                </div>
                
                <div style="background: rgba(68,136,255,0.1); padding: 12px; border-radius: 8px; margin-top: 12px; border: 1px solid rgba(68,136,255,0.3);">
                    <div style="color: #4488ff; font-weight: bold; text-align: center; margin-bottom: 8px;">
                         Additional Power Formulas
                    </div>
                    <div style="color: #ccc; font-size: 11px; text-align: center; line-height: 1.4;">
                        W = I  R (Power = Current  Resistance)<br>
                        W = E  R (Power = Voltage  Resistance)
                    </div>
                </div>
            </div>
        </div>

        <!-- Worksheet Panel -->
        <div class="analysis-content" id="content-worksheet" style="display: none;">
            <div class="worksheet-panel">
                <div class="worksheet-title">Circuit Analysis Worksheet</div>
                
                <div class="component-list" id="component-list">
                    <!-- Components will be populated here -->
                </div>

                <div class="calculations-section">
                    <div class="calculation-step step-resistance">
                        <div>
                            <div class="step-label">Total Resistance</div>
                            <div class="step-formula" id="resistance-formula">R_total = R + R + R...</div>
                        </div>
                        <div class="step-value" id="calc-resistance">--</div>
                    </div>
                    
                    <div class="calculation-step step-current">
                        <div>
                            <div class="step-label">Total Current</div>
                            <div class="step-formula" id="current-formula">I = V  R_total</div>
                        </div>
                        <div class="step-value" id="calc-current">0A</div>
                    </div>
                    
                    <div class="calculation-step step-voltage">
                        <div>
                            <div class="step-label">Source Voltage</div>
                            <div class="step-formula" id="voltage-formula">V = V_bat1 + V_bat2...</div>
                        </div>
                        <div class="step-value" id="calc-voltage">0V</div>
                    </div>
                    
                    <div class="calculation-step step-power">
                        <div>
                            <div class="step-label">Total Power</div>
                            <div class="step-formula" id="power-formula">P = V  I</div>
                        </div>
                        <div class="step-value" id="calc-power">0W</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Problem Solving Panel -->
        <div class="analysis-content" id="content-problem" style="display: none;">
            <div class="problem-mode">
                <div class="problem-title"> Solve for the Unknown</div>
                <div style="color: #ccc; margin-bottom: 16px; text-align: center;">
                    Enter your calculated values below:
                </div>
                
                <div class="unknown-input">
                    <label style="color: #ff4444; width: 120px;">Total Voltage:</label>
                    <input type="number" id="student-voltage" step="0.1" placeholder="V">
                    <span style="color: #ff4444;">V</span>
                </div>
                
                <div class="unknown-input">
                    <label style="color: #ff8844; width: 120px;">Total Current:</label>
                    <input type="number" id="student-current" step="0.001" placeholder="A">
                    <span style="color: #ff8844;">A</span>
                </div>
                
                <div class="unknown-input">
                    <label style="color: #44ff88; width: 120px;">Total Resistance:</label>
                    <input type="number" id="student-resistance" step="0.1" placeholder="">
                    <span style="color: #44ff88;"></span>
                </div>
                
                <div class="unknown-input">
                    <label style="color: #4488ff; width: 120px;">Total Power:</label>
                    <input type="number" id="student-power" step="0.01" placeholder="W">
                    <span style="color: #4488ff;">W</span>
                </div>
                
                <div style="text-align: center; margin-top: 16px;">
                    <button class="check-answer-btn" onclick="checkStudentAnswers()">
                         Check My Answers
                    </button>
                </div>
                
                <div id="answer-feedback"></div>
            </div>
        </div>

        <!-- Practice Mode Panel -->
        <div class="analysis-content" id="content-practice" style="display: none;">
            <div class="practice-problem-card" id="practice-problem-card" style="display: none;">
                <div class="problem-question" id="practice-question">
                     Problem: Find the total resistance
                </div>
                <div class="problem-description" id="practice-description">
                    Calculate the total resistance of this series circuit
                </div>
                
                <div style="display: flex; justify-content: space-between; align-items: center; margin: 12px 0;">
                    <div style="color: #4da6ff; font-size: 12px; font-weight: bold;">
                        Problem <span id="problem-counter">1</span> of <span id="total-problems">4</span>
                    </div>
                    <div style="display: flex; gap: 8px;">
                        <button class="practice-btn" onclick="previousProblem()" id="prev-btn" style="padding: 6px 12px; font-size: 11px;">Prev</button>
                        <button class="practice-btn" onclick="nextProblem()" id="next-btn" style="padding: 6px 12px; font-size: 11px;">Next</button>
                    </div>
                </div>
                
                <div class="circuit-status" id="circuit-status">
                    <div id="circuit-status-text">Circuit incomplete - add wires to connect components.</div>
                </div>
                
                <div class="wire-instructions" id="wire-instructions">
                    <strong>Use W.I.R.E.:</strong> 1) Log the givens in the worksheet  2) Choose the matching Ohm's or power identity  3) Tap <em>Reveal totals</em> to verify with Kirchhoff's laws. (Use Clear if you want to rebuild the wiring yourself.)
                </div>

                <div class="wire-table-wrapper" id="wire-table-wrapper" style="display: none;">
                    <div class="wire-table-header">
                        W.I.R.E. Worksheet
                        <span id="wire-table-scenario"></span>
                    </div>
                    <div class="wire-table-guide" id="wire-table-guide">
                        Record the givens, then apply Ohm's Law and power identities to fill the blanks.
                    </div>
                    <table class="wire-table" aria-describedby="wire-table-guide wire-table-note">
                        <thead>
                            <tr>
                                <th scope="col">Component</th>
                                <th scope="col">W (Power)</th>
                                <th scope="col">I (Current)</th>
                                <th scope="col">R (Resistance)</th>
                                <th scope="col">E (Voltage)</th>
                            </tr>
                        </thead>
                        <tbody id="wire-table-body"></tbody>
                    </table>
                    <div class="wire-table-note" id="wire-table-note">
                        Totals appear after you tap Reveal totals and the circuit has a valid solution. Use them to check your work.
                    </div>
                    <div class="wire-table-actions">
                        <button class="practice-btn secondary" type="button" onclick="resetWireWorksheetInputs()">
                            Clear entries
                        </button>
                        <button class="practice-btn secondary" type="button" id="wire-table-toggle-solutions" onclick="toggleWireWorksheetSolutions()">
                            Reveal totals
                        </button>
                    </div>
                </div>
                
                <div id="practice-objectives" style="margin-top: 12px;">
                    <div style="color: #4da6ff; font-weight: bold; margin-bottom: 8px; font-size: 14px;">Learning Objectives:</div>
                    <ul id="objectives-list" style="color: #ccc; margin-left: 20px; line-height: 1.5; font-size: 12px;">
                        <!-- Objectives will be populated here -->
                    </ul>
                </div>
            </div>
            
            <div class="worksheet-panel">
                <div class="worksheet-title">Practice Circuit Problems</div>
                
                <div style="text-align: center; margin-bottom: 16px;">
                    <button class="practice-btn" onclick="startPracticeSequence()" style="background: linear-gradient(135deg, #00ff88, #00cc66); color: #000; padding: 12px 24px; font-size: 14px; font-weight: bold;">
                        Start Practice Sequence
                    </button>
                </div>
                
                <div class="practice-buttons">
                    <button class="practice-btn" onclick="loadPresetCircuit('series_basic')" id="btn-series">Basic Series</button>
                    <button class="practice-btn" onclick="loadPresetCircuit('parallel_basic')" id="btn-parallel">Basic Parallel</button>
                    <button class="practice-btn" onclick="loadPresetCircuit('mixed_circuit')" id="btn-mixed">Mixed Circuit</button>
                    <button class="practice-btn" onclick="loadPresetCircuit('combination_advanced')" id="btn-combination">Advanced Combo</button>
                    <button class="practice-btn" onclick="generateRandomProblem()" id="btn-random">Random</button>
                </div>
                
                <div id="practice-help-text" style="background: rgba(255,255,255,0.1); padding: 16px; border-radius: 8px; color: #ccc; text-align: center; font-size: 12px;">
                    <strong>Run the Table Method on every problem:</strong><br>
                    1. Load a circuit above, then scroll to the W.I.R.E. worksheet that appears below.<br>
                    2. Record the givens for each component across W, I, R, E columns.<br>
                    3. Use the matching Ohm's Law or power formula to solve the blanks, then tap <em>Reveal totals</em> to check.<br><br>
                    <strong>Pick your practice flow:</strong><br>
                    - <strong>Practice Sequence</strong> - Work through all four problems in order.<br>
                    - <strong>Individual Problems</strong> - Jump straight to series, parallel, mixed, or combo.<br>
                    - <strong>Random</strong> - Regenerate the same layouts with fresh values.<br><br>
                    <small>Need a printable sheet? Open the Table Method Guide from the Builder panel or tap Clear entries to start over.</small>
                </div>
            </div>
        </div>

        <!-- Measurement Tools Panel -->
        <div class="analysis-content" id="content-meter" style="display: none;">
            <div class="wire-analysis">
                <div class="wire-title"> MEASUREMENT TOOLS</div>
                <div style="display:flex; flex-wrap:wrap; gap:10px; justify-content:center; margin: 10px 0 14px;">
                    <button class="practice-btn" type="button" onclick="setMeterMode('voltage')" id="meter-mode-voltage">Volts (V)</button>
                    <button class="practice-btn secondary" type="button" onclick="setMeterMode('current')" id="meter-mode-current">Amps (A)</button>
                    <button class="practice-btn secondary" type="button" onclick="setMeterMode('resistance')" id="meter-mode-resistance">Ohms ()</button>
                    <button class="practice-btn secondary" type="button" onclick="setMeterMode('scope')" id="meter-mode-scope">Scope</button>
                </div>

                <div style="display:flex; flex-wrap:wrap; gap:10px; justify-content:center; margin-bottom: 10px;">
                    <button class="practice-btn secondary" type="button" onclick="toggleMeterArmed()" id="meter-toggle-armed">
                        Enable probes
                    </button>
                    <button class="practice-btn secondary" type="button" onclick="clearMeterSelection()">
                        Clear
                    </button>
                </div>

                <div style="color:#ccc; font-size: 12px; line-height:1.5; text-align:center; margin-bottom: 12px;">
                    <div id="meter-instructions">Enable probes, then click two terminals to measure voltage.</div>
                </div>

                <div style="display:grid; grid-template-columns: repeat(2, minmax(0, 1fr)); gap: 10px; margin-bottom: 10px;">
                    <div style="background: rgba(255,255,255,0.06); border: 1px solid rgba(255,255,255,0.12); border-radius: 12px; padding: 12px;">
                        <div style="color:#ff6666; font-weight:700; margin-bottom:6px;">Red probe</div>
                        <div id="meter-probe-a" style="color:#e8f6ff; font-family: Consolas, Monaco, monospace; font-size: 12px;"></div>
                    </div>
                    <div style="background: rgba(255,255,255,0.06); border: 1px solid rgba(255,255,255,0.12); border-radius: 12px; padding: 12px;">
                        <div style="color:#aab0b8; font-weight:700; margin-bottom:6px;">Black probe</div>
                        <div id="meter-probe-b" style="color:#e8f6ff; font-family: Consolas, Monaco, monospace; font-size: 12px;"></div>
                    </div>
                </div>

                <div style="background: rgba(0,0,0,0.25); border: 1px solid rgba(0,255,136,0.22); border-radius: 12px; padding: 12px; margin-bottom: 10px;">
                    <div style="display:flex; justify-content:space-between; gap: 12px; flex-wrap:wrap; align-items:baseline;">
                        <div style="color:#00ff88; font-weight:800; letter-spacing:0.03em;">Reading</div>
                        <div id="meter-reading" style="color:#e8f6ff; font-family: Consolas, Monaco, monospace; font-size: 16px; font-weight:700;"></div>
                    </div>
                    <div id="meter-subreading" style="margin-top:6px; color: rgba(220,234,255,0.72); font-size: 12px;"></div>
                </div>

                <div id="scope-panel" style="display:none; background: rgba(255,255,255,0.05); border: 1px solid rgba(136, 204, 255, 0.24); border-radius: 12px; padding: 12px;">
                    <div style="display:flex; justify-content:space-between; align-items:center; gap: 10px; margin-bottom: 8px; flex-wrap:wrap;">
                        <div style="color:#88ccff; font-weight:800; letter-spacing:0.03em;">Oscilloscope (DC)</div>
                        <div id="scope-readout" style="color:#e8f6ff; font-family: Consolas, Monaco, monospace; font-size: 12px;"></div>
                    </div>
                    <canvas id="scope-canvas" width="640" height="160" style="width: 100%; height: 160px; background: rgba(0,0,0,0.55); border-radius: 10px; border: 1px solid rgba(255,255,255,0.12);"></canvas>
                    <div style="margin-top:8px; color: rgba(220,234,255,0.72); font-size: 12px; text-align:center;">
                        Pick a terminal for the scope probe (black is the reference).
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <div class="status" id="status" style="display: none;">W.I.R.E. Circuit Builder Ready!</div>
    
    <div class="edit-popup" id="edit-popup">
        <h3 id="edit-title">Edit Component</h3>
        <div id="edit-content">
            <!-- Dynamic content will be inserted here -->
        </div>
        <div class="edit-buttons">
            <button class="edit-btn save" onclick="saveEdit()">Save</button>
            <button class="edit-btn cancel" onclick="cancelEdit()">Cancel</button>
        </div>
    </div>
    
    <canvas id="canvas" style="display: none;"></canvas>

    <div class="subscription-overlay-backdrop" id="subscription-pricing-backdrop"></div>

    <div
        class="subscription-overlay"
        id="subscription-pricing-overlay"
        role="dialog"
        aria-modal="true"
        aria-labelledby="subscription-pricing-title"
        tabindex="-1"
        data-active-cycle="annual"
    >
        <button class="subscription-close" type="button" aria-label="Close subscription pricing" onclick="closeSubscriptionPricing()">&times;</button>
        <div class="subscription-header">
            <span class="subscription-kicker">Subscription Success</span>
            <h2 id="subscription-pricing-title">Launch CircuiTry3D across your program</h2>
            <p>Planning a classroom, campus, or district rollout? This playbook highlights the support included in every subscription tier so your team can move from pilot to full adoption with confidence.</p>
            <div class="subscription-status" data-subscription-status="pending">
                <span class="subscription-status-label">Billing status</span>
                <span class="subscription-status-value">Pending</span>
                <span class="subscription-status-note">Stripe checkout links will populate sku-based buttons as soon as they are live.</span>
            </div>
        </div>
        <div class="subscription-cycle-toggle" role="group" aria-label="Billing cycle selector">
            <button type="button" class="subscription-cycle-btn active" data-cycle="annual" aria-pressed="true" onclick="setSubscriptionPricingCycle('annual')">
                Annual
                <span class="subscription-cycle-note">Save 15%</span>
            </button>
            <button type="button" class="subscription-cycle-btn" data-cycle="monthly" aria-pressed="false" onclick="setSubscriptionPricingCycle('monthly')">
                Monthly
                <span class="subscription-cycle-note">Pay as you go</span>
            </button>
        </div>

        <div class="subscription-plan-grid">
            <article class="subscription-plan-card" data-plan="free">
                <header class="subscription-plan-header">
                    <h3>Free Sandbox</h3>
                    <p>Explore core circuit tools</p>
                </header>
                <div class="subscription-plan-price">
                    <span class="subscription-price-amount" data-price-cycle="annual">Free</span>
                    <span class="subscription-price-amount" data-price-cycle="monthly">Free</span>
                    <span class="subscription-price-unit">per educator</span>
                    <span class="subscription-price-cycle-note" data-price-cycle="annual">per year</span>
                    <span class="subscription-price-cycle-note" data-price-cycle="monthly">per month</span>
                </div>
                <ul class="subscription-plan-features">
                    <li>3 active circuits</li>
                    <li>Core component library</li>
                    <li>W.I.R.E. analysis preview</li>
                    <li>Community resource hub</li>
                </ul>
                <div class="subscription-plan-cta">
                    <button type="button" class="subscription-plan-button" onclick="startSandboxFromPricing()">Start Free</button>
                </div>
            </article>

            <article class="subscription-plan-card" data-plan="educator">
                <header class="subscription-plan-header">
                    <h3>Educator License</h3>
                    <p>Full toolkit for classroom instruction</p>
                </header>
                <div class="subscription-plan-price">
                    <span class="subscription-price-amount" data-price-cycle="annual">$299</span>
                    <span class="subscription-price-amount" data-price-cycle="monthly">$29</span>
                    <span class="subscription-price-unit">per educator</span>
                    <span class="subscription-price-cycle-note" data-price-cycle="annual">per year</span>
                    <span class="subscription-price-cycle-note" data-price-cycle="monthly">per month</span>
                    <span class="subscription-plan-renewal">Auto-renews, cancel anytime</span>
                </div>
                <ul class="subscription-plan-features">
                    <li>Unlimited saved circuits</li>
                    <li>Advanced W.I.R.E. coaching</li>
                    <li>Lesson templates &amp; assessments</li>
                    <li>Priority email support</li>
                </ul>
                <div class="subscription-plan-cta">
                    <button type="button" class="subscription-plan-button" onclick="launchStripeComingSoon('educator-license')">Stripe checkout (coming soon)</button>
                </div>
            </article>

            <article class="subscription-plan-card" data-plan="institutional">
                <header class="subscription-plan-header">
                    <h3>Institutional License</h3>
                    <p>Campus-wide access with admin controls</p>
                </header>
                <div class="subscription-plan-price">
                    <span class="subscription-price-amount" data-price-cycle="annual">Contact</span>
                    <span class="subscription-price-amount" data-price-cycle="monthly">Contact</span>
                    <span class="subscription-price-unit">per site</span>
                </div>
                <ul class="subscription-plan-features">
                    <li>Bulk educator seats</li>
                    <li>Dedicated onboarding</li>
                    <li>SIS integrations &amp; SSO</li>
                    <li>Curriculum alignment toolkit</li>
                </ul>
                <div class="subscription-plan-bulk">
                    <span>Minimum 10 seats</span>
                    <span>Volume discounts start at 25 seats</span>
                </div>
                <div class="subscription-plan-cta">
                    <a class="subscription-plan-button" href="mailto:hello@circuitry3d.com?subject=Institutional%20Pricing">Contact Us</a>
                </div>
            </article>
        </div>

        <div class="subscription-support-grid">
            <article class="subscription-support-card">
                <span class="subscription-support-badge">Program Planning</span>
                <h4>District &amp; Campus Rollouts</h4>
                <p class="subscription-support-summary">Partner with our team to scope the right subscription footprint for your program.</p>
                <ul>
                    <li>Discovery session with admin &amp; lead teachers</li>
                    <li>Seat provisioning and roster import guidance</li>
                    <li>Dedicated rollout timeline template</li>
                </ul>
            </article>
            <article class="subscription-support-card">
                <span class="subscription-support-badge">Teacher Enablement</span>
                <h4>Teacher Success Accelerator</h4>
                <p class="subscription-support-summary">Ensure every educator is confident launching CircuiTry3D on day one.</p>
                <ul>
                    <li>Live or recorded onboarding workshops</li>
                    <li>Lesson launch kits with pacing guides</li>
                    <li>Priority support channel for classroom questions</li>
                </ul>
            </article>
            <article class="subscription-support-card">
                <span class="subscription-support-badge">Student Experience</span>
                <h4>Student Engagement Toolkit</h4>
                <p class="subscription-support-summary">Keep learners motivated with ready-to-run activities and analytics.</p>
                <ul>
                    <li>Circuit templates aligned to NGSS &amp; CTE standards</li>
                    <li>Auto-saved progress and classroom monitoring</li>
                    <li>W.I.R.E. analytics exports for reflections</li>
                </ul>
            </article>
        </div>

        <div class="subscription-steps">
            <h3>Rollout playbook</h3>
            <ol class="subscription-step-list">
                <li class="subscription-step">
                    <span class="subscription-step-number">01</span>
                    <div class="subscription-step-content">
                        <h4>Discovery &amp; Goal Setting</h4>
                        <p>Share your outcomes, roster counts, and timelines so we can scope the subscription tier that fits best.</p>
                    </div>
                </li>
                <li class="subscription-step">
                    <span class="subscription-step-number">02</span>
                    <div class="subscription-step-content">
                        <h4>Pilot With Lead Classrooms</h4>
                        <p>Launch a focused pilot with a small teacher cohort and capture quick feedback on access, pacing, and support needs.</p>
                    </div>
                </li>
                <li class="subscription-step">
                    <span class="subscription-step-number">03</span>
                    <div class="subscription-step-content">
                        <h4>Campus-Wide Launch</h4>
                        <p>Provision remaining seats, finalize billing, and host an all-staff enablement session to kick off the program.</p>
                    </div>
                </li>
                <li class="subscription-step">
                    <span class="subscription-step-number">04</span>
                    <div class="subscription-step-content">
                        <h4>Measure &amp; Expand</h4>
                        <p>Review usage analytics, celebrate wins, and plan the next phase - additional campuses, certifications, or advanced bundles.</p>
                    </div>
                </li>
            </ol>
        </div>

        <div class="subscription-faq">
            <h3>Common questions</h3>
            <div class="subscription-faq-grid">
                <details class="subscription-faq-item">
                    <summary>How do we purchase educator seats?</summary>
                    <p>Start with a discovery call so we can confirm seat counts and billing cadence. Stripe checkout links roll out soon; until then we issue invoices or purchase orders.</p>
                </details>
                <details class="subscription-faq-item">
                    <summary>Can we mix monthly and annual billing?</summary>
                    <p>Educator plans can mix terms. Many districts choose annual licensing for core staff plus monthly add-ons during summer academies.</p>
                </details>
                <details class="subscription-faq-item">
                    <summary>Do you support purchase orders or vendor onboarding?</summary>
                    <p>Yes. We provide W-9, vendor packets, and Net 30 invoicing. Our team coordinates with your procurement office to simplify onboarding.</p>
                </details>
                <details class="subscription-faq-item">
                    <summary>How is student data handled?</summary>
                    <p>CircuiTry3D stores minimal student data, encrypts it in transit and at rest, and supports district SSO. Review our privacy policy or request a data-sharing agreement.</p>
                </details>
            </div>
        </div>

        <div class="subscription-cta">
            <div class="subscription-cta-text">
                <h3>Ready to activate your subscription?</h3>
                <p>Start in the sandbox today or schedule a planning call to customize your rollout, invoicing, and training needs.</p>
            </div>
            <div class="subscription-cta-actions">
                <button type="button" class="subscription-cta-button" onclick="startSandboxFromPricing()">Start free sandbox</button>
                <a class="subscription-cta-button" href="mailto:hello@circuitry3d.com?subject=CircuiTry3D%20Subscription%20Planning">Book a planning call</a>
            </div>
        </div>
    </div>
    
    <!-- Branding Overlay -->
    <div class="branding-overlay" id="branding-overlay">
        <span class="logo-circui">Circui</span><span class="logo-try">Try</span><span class="logo-3d">3D</span>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js" crossorigin="anonymous"></script>
    <script>
        if (typeof window.THREE === "undefined") {
            document.write('<script src="vendor/three.min.js"><\\/script>');
        }
    </script>
    <script>
        const urlParams = new URLSearchParams(window.location.search);
        let isEmbedded = false;
        try {
            isEmbedded = urlParams.has("embed") || window.self !== window.top;
        } catch (error) {
            isEmbedded = urlParams.has("embed");
        }

        if (isEmbedded) {
            document.documentElement.classList.add("embedded");
            window.addEventListener("DOMContentLoaded", () => {
                const body = document.body;
                if (body) {
                    body.classList.add("embedded");
                    body.classList.remove("menu-visible");
                }
                const hiddenIds = [
                    "menu-bar",
                    "menu-toggle",
                    "wire-analysis",
                    "status",
                    "branding-overlay",
                    "landing-page",
                    "launch-btn",
                    "loading",
                    "loading-progress",
                    "loading-text"
                ];
                hiddenIds.forEach((id) => {
                    const element = document.getElementById(id);
                    if (element) {
                        element.style.display = "none";
                    }
                });
            });
        }

        // Global variables
        const ARENA_STORAGE_KEY = 'circuiTry3d.arena.import';
        let scene, camera, renderer, raycaster, mouse;
        let components = [], wires = [], junctions = [];
        let isWireMode = false, isRotateMode = false, wireStart = null;
        let isMeasureMode = false;
        let measureStartPoint = null;
        // Measurement tools (multimeter + scope)
        let meterMode = 'voltage'; // 'voltage' | 'current' | 'resistance' | 'scope'
        let meterArmed = false;
        let meterProbeA = null; // pointData for red probe
        let meterProbeB = null; // pointData for black probe
        let meterCurrentTarget = null; // component for current measurement
        let lastDCSolution = null;

        let scopeTimer = null;
        let scopeBuffer = [];
        const SCOPE_BUFFER_SIZE = 220;
        let isDragging = false, selectedComponent = null;
        let currentFlowParticles = [];
        let menuVisible = isEmbedded ? false : true;
        let analysisVisible = isEmbedded ? false : true;

        const isAndroidDevice =
            (typeof navigator !== "undefined" && /Android/i.test(navigator.userAgent || "")) ||
            (typeof window !== "undefined" &&
                typeof window.Capacitor === "object" &&
                typeof window.Capacitor.getPlatform === "function" &&
                window.Capacitor.getPlatform() === "android");

        if (isAndroidDevice) {
            const applyAndroidClasses = () => {
                if (document.documentElement) {
                    document.documentElement.classList.add("android-optimized");
                }
                if (document.body) {
                    document.body.classList.add("android-optimized");
                    if (menuVisible) {
                        document.body.classList.add("menu-visible");
                    }
                }
            };

            if (document.readyState === "loading") {
                document.addEventListener("DOMContentLoaded", applyAndroidClasses, { once: true });
            } else {
                applyAndroidClasses();
            }

            if (!document.getElementById("android-layout-overrides")) {
                const androidStyle = document.createElement("style");
                androidStyle.id = "android-layout-overrides";
                androidStyle.textContent = `
body.android-optimized {
  --legacy-menu-width: min(320px, calc(100vw - 48px));
}

body.android-optimized .menu-bar {
  top: 0;
  bottom: 0;
  left: 0;
  right: auto;
  width: var(--legacy-menu-width);
  border-bottom: none;
  border-right: 2px solid rgba(0, 255, 136, 0.3);
  max-height: none;
  padding: 24px 16px 32px;
  display: flex;
  flex-direction: column;
  gap: 16px;
  box-shadow: 6px 0 24px rgba(0, 0, 0, 0.35);
}

body.android-optimized .menu-bar.hidden {
  transform: translateX(-100%);
  box-shadow: none;
}

body.android-optimized .menu-tabs {
  height: 100%;
  margin: 0;
  justify-content: flex-start;
}

body.android-optimized .menu-tab {
  justify-content: space-between;
  text-align: left;
}

body.android-optimized .submenu {
  position: static;
  margin-top: 12px;
}

body.android-optimized .menu-toggle {
  top: 16px;
  left: 16px;
  width: 56px;
  height: 56px;
  border-radius: 16px;
  transition: transform 0.3s ease;
}

body.android-optimized .menu-toggle.open {
  transform: translateX(calc(var(--legacy-menu-width) + 12px));
}

body.android-optimized.menu-visible #canvas {
  left: var(--legacy-menu-width);
  width: calc(100vw - var(--legacy-menu-width));
}

body.android-optimized.menu-visible .wire-analysis-fixed,
body.android-optimized.menu-visible .status {
  left: calc(var(--legacy-menu-width) + 24px);
  right: 24px;
}
                `;
                const headElement = document.head || document.getElementsByTagName("head")[0];
                if (headElement) {
                    headElement.appendChild(androidStyle);
                }
            }
        }

        function notifyParentReady() {
            if (window.parent && window.parent !== window) {
                try {
                    window.parent.postMessage({ type: 'legacy:ready' }, '*');
                    notifyParentModeState();
                } catch (error) {
                    console.warn('Builder bridge: unable to notify parent window', error);
                }
            }
        }

        function notifyParentAnalysisState() {
            if (window.parent && window.parent !== window) {
                try {
                    window.parent.postMessage({ type: 'legacy:analysis-state', payload: { open: analysisVisible } }, '*');
                } catch (error) {
                    console.warn('Builder bridge: unable to share analysis state', error);
                }
            }
        }

        function notifyParentToolState(tool) {
            if (!tool) {
                return;
            }
            if (window.parent && window.parent !== window) {
                try {
                    window.parent.postMessage({ type: 'legacy:tool-state', payload: { tool } }, '*');
                } catch (error) {
                    console.warn('Builder bridge: unable to share tool state', error);
                }
            }
        }

        function notifyParentSimulation(payload) {
            if (window.parent && window.parent !== window) {
                try {
                    window.parent.postMessage({ type: 'legacy:simulation', payload }, '*');
                } catch (error) {
                    console.warn('Builder bridge: unable to share simulation state', error);
                }
            }
        }

        function notifyParentMeasurement(payload) {
            if (window.parent && window.parent !== window) {
                try {
                    window.parent.postMessage({ type: 'legacy:measurement', payload }, '*');
                } catch (error) {
                    console.warn('Builder bridge: unable to share measurement result', error);
                }
            }
        }

        function notifyParentCircuitState(snapshot) {
            if (window.parent && window.parent !== window) {
                try {
                    window.parent.postMessage({ type: 'legacy:circuit-state', payload: snapshot }, '*');
                } catch (error) {
                    console.warn('Builder bridge: unable to share circuit state', error);
                }
            }
        }

        function notifyParentModeState(extraState) {
            if (window.parent && window.parent !== window) {
                try {
                    const payload = Object.assign({
                        isWireMode,
                        isRotateMode,
                        isMeasureMode,
                        currentFlowStyle,
                        showPolarityIndicators,
                        layoutMode,
                        showGrid,
                        showLabels,
                        wireRoutingMode: getRouterMode()
                    }, (extraState && typeof extraState === 'object') ? extraState : {});

                    window.parent.postMessage({ type: 'legacy:mode-state', payload }, '*');
                } catch (error) {
                    console.warn('Builder bridge: unable to share mode state', error);
                }
            }
        }

        function handleBuilderBridgeMessage(event) {
            const expectedSource = window.parent && window.parent !== window ? window.parent : null;
            if (expectedSource && event.source !== expectedSource) {
                return;
            }

            const data = event.data;
            if (!data || typeof data !== 'object') {
                return;
            }

            const { type, payload } = data;

            switch (type) {
                case 'builder:add-component': {
                    const componentType = payload?.componentType;
                    if (typeof componentType === 'string' && typeof addComponent === 'function') {
                        addComponent(componentType);
                    }
                    break;
                }
                case 'builder:add-junction': {
                    if (typeof addJunction === 'function') {
                        addJunction();
                    }
                    break;
                }
                case 'builder:set-analysis-open': {
                    if (!payload || typeof payload !== 'object' || !('open' in payload)) {
                        break;
                    }

                    const desired = Boolean(payload.open);
                    const panel = document.getElementById('wire-analysis');
                    const isCollapsed = panel?.classList.contains('collapsed');

                    if (panel) {
                        if (desired && isCollapsed) {
                            panel.classList.remove('collapsed');
                            analysisVisible = true;
                        } else if (!desired && !isCollapsed) {
                            panel.classList.add('collapsed');
                            analysisVisible = false;
                        } else {
                            analysisVisible = !panel.classList.contains('collapsed');
                        }
                    } else {
                        analysisVisible = desired;
                    }

                    notifyParentAnalysisState();
                    break;
                }
                case 'builder:export-arena': {
                    if (payload && typeof payload === 'object') {
                        exportArenaSession({
                            requestId: payload.requestId,
                            openWindow: Boolean(payload.openWindow),
                            sessionName: payload.sessionName,
                            testVariables: payload.testVariables
                        });
                    } else {
                        exportArenaSession({ openWindow: false });
                    }
                    break;
                }
                case 'builder:request-mode-state': {
                    notifyParentModeState();
                    break;
                }
                case 'builder:invoke-action': {
                    if (!payload || typeof payload !== 'object' || typeof payload.action !== 'string') {
                        break;
                    }

                    const action = payload.action;
                    const data = payload.data && typeof payload.data === 'object' ? payload.data : {};

                    try {
                        switch (action) {
                            case 'toggle-wire-mode':
                                if (typeof toggleWireMode === 'function') toggleWireMode();
                                break;
                            case 'toggle-rotate-mode':
                                if (typeof toggleRotateMode === 'function') toggleRotateMode();
                                break;
                            case 'add-junction':
                                if (typeof addJunction === 'function') addJunction();
                                break;
                            case 'auto-arrange':
                                if (typeof arrangeByLayoutMode === 'function') arrangeByLayoutMode();
                                break;
                            case 'reset-camera':
                                if (typeof resetCamera === 'function') resetCamera();
                                break;
                            case 'fit-screen':
                                if (typeof fitToScreen === 'function') fitToScreen();
                                break;
                            case 'toggle-current-flow':
                                if (typeof toggleCurrentFlowStyle === 'function') toggleCurrentFlowStyle();
                                break;
                            case 'toggle-polarity':
                                if (typeof togglePolarityIndicators === 'function') togglePolarityIndicators();
                                break;
                            case 'cycle-layout':
                                if (typeof cycleLayoutMode === 'function') cycleLayoutMode();
                                break;
                            case 'open-measurement-tools':
                                if (typeof openMeasurementTools === 'function') openMeasurementTools();
                                break;
                            case 'cycle-wire-routing':
                                if (typeof cycleRoutingMode === 'function') cycleRoutingMode();
                                break;
                            case 'toggle-grid':
                                if (typeof toggleGrid === 'function') toggleGrid();
                                break;
                            case 'toggle-labels':
                                if (typeof toggleLabels === 'function') toggleLabels();
                                break;
                            case 'set-tool':
                                if (typeof data.tool === 'string' && typeof setBuilderTool === 'function') {
                                    setBuilderTool(data.tool);
                                }
                                break;
                            case 'load-preset':
                                if (typeof data.preset === 'string' && typeof loadPresetCircuit === 'function') {
                                    loadPresetCircuit(data.preset);
                                }
                                break;
                            case 'generate-practice':
                                if (typeof generateRandomProblem === 'function') generateRandomProblem();
                                break;
                            case 'practice-help':
                                if (typeof showPracticeModeHelp === 'function') showPracticeModeHelp();
                                break;
                            case 'show-tutorial':
                                if (typeof showTutorial === 'function') showTutorial();
                                break;
                            case 'show-wire-guide':
                                if (typeof showWireGuide === 'function') showWireGuide();
                                break;
                            case 'show-shortcuts':
                                if (typeof showShortcuts === 'function') showShortcuts();
                                break;
                            case 'show-about':
                                if (typeof showAbout === 'function') showAbout();
                                break;
                            case 'open-arena':
                                if (typeof openArena === 'function') openArena();
                                break;
                            case 'clear-workspace':
                                if (typeof clearAll === 'function') clearAll();
                                break;
                            case 'run-simulation':
                                if (typeof runSimulation === 'function') runSimulation();
                                break;
                            case 'set-wire-profile':
                                if (typeof applyWireProfileFromBridge === 'function') {
                                    applyWireProfileFromBridge(data.wireProfile || null);
                                }
                                break;
                            case 'lock-circuit':
                                isCircuitEditLocked = true;
                                setStatus(' Circuit locked - complete the active challenge to edit');
                                break;
                            case 'unlock-circuit':
                                isCircuitEditLocked = false;
                                setStatus(' Circuit unlocked - you can now edit');
                                break;
                            default:
                                break;
                        }
                    } catch (error) {
                        console.warn('Builder bridge: invoke action failed', action, error);
                    }
                    break;
                }
                default:
                    break;
            }
        }

        if (window.parent && window.parent !== window) {
            window.addEventListener('message', handleBuilderBridgeMessage);
        }
        let undoStack = [], redoStack = [];
        let clipboard = null;
        let selectedComponents = new Set();
        let showGrid = true, showLabels = true;
        let currentAnalysisTab = 'wire';
        let lastKnownValues = { voltage: 0, current: 0, resistance: Infinity, power: 0 };
        let currentPracticeCircuit = null;
        let currentProblemIndex = 0;
        let practiceProblems = ['series_basic', 'parallel_basic', 'mixed_circuit', 'combination_advanced'];
        
        // New features variables
        let currentFlowStyle = 'misty'; // 'misty' (electron cloud) or 'solid' (conventional)
        let layoutMode = 'free'; // 'free', 'square', 'linear'
        let showPolarityIndicators = true;
        let isCircuitEditLocked = false; // When true, prevents editing components/wires (for practice mode)
        
        let practiceQuestions = {
            series_basic: {
                question: "Series circuit: solve for total current (I_T).",
                expectedAnswer: "current",
                description: [
                    "<strong>W</strong>: Note the 24 V supply (power is unknown until the end).",
                    "<strong>I</strong>: Target the circuit current I_T.",
                    "<strong>R</strong>: Known resistors R1=150 , R2=200 , R3=250  (pure series).",
                    "<strong>E</strong>: Use E = 24 V to select I = E / R_T from the Ohm's Law family.",
                    "Check Kirchhoff's Voltage Law by confirming the drops sum to 24 V."
                ].join("<br>")
            },
            parallel_basic: {
                question: "Parallel network: compute R_T and each branch current.",
                expectedAnswer: "resistance",
                description: [
                    "<strong>W</strong>: The 12 V source defines system power once currents are known.",
                    "<strong>I</strong>: Solve each branch current, then add them for I_T.",
                    "<strong>R</strong>: Branch resistors R1=100 ohm, R2=220 ohm, R3=330 ohm combine with reciprocal sums.",
                    "<strong>E</strong>: Voltage is common across the branches; use I = E / R_branch and W = I * E.",
                    "Validate with Kirchhoff's Current Law by summing the branch currents."
                ].join("<br>")
            },
            mixed_circuit: {
                question: "Series-parallel combo: collapse the ladder and solve for I_T.",
                expectedAnswer: "current",
                description: [
                    "<strong>Plan</strong>: Reduce the series resistor first, then the parallel pair, before finishing the loop.",
                    "<strong>W.I.R.E.</strong>: Track resistors R1=150 ohm, R2=220 ohm, R3=330 ohm, R4=180 ohm with the 18 V supply.",
                    "<strong>Formulas</strong>: Use the 12 Ohm's Law identities (E=I*R, I=E/R, R=E/I, W=I*E, W=I^2*R, W=E^2/R).",
                    "<strong>Kirchhoff</strong>: Verify KVL around the outer loop and KCL at the branch node."
                ].join("<br>")
            },
            combination_advanced: {
                question: "Multi-loop combo: determine drops, currents, and power everywhere.",
                expectedAnswer: "power",
                description: [
                    "<strong>Strategy</strong>: Work outward-in, simplifying parallel legs before folding the bridge back into series.",
                    "<strong>W.I.R.E.</strong>: Log each known resistor value and the 24 V supply; mark the unknowns for W, I, R, and E.",
                    "<strong>Formulas</strong>: Cycle through the Ohm's Law family plus power triangle (W=I*E, W=I^2*R, W=E^2/R).",
                    "<strong>Checks</strong>: Apply KCL at every junction and KVL for each independent loop.",
                    "Present the answer set as a W.I.R.E. table." 
                ].join("<br>")
            }
        };
        const WIRE_TABLE_HEADERS = ["W", "I", "R", "E"];

        const WIRE_FIELD_LABELS = {
            W: "power",
            I: "current",
            R: "resistance",
            E: "voltage"
        };

        const WIRE_TYPE_ORDER = {
            battery: 0,
            resistor: 1,
            led: 1,
            switch: 2
        };

        const PRACTICE_WORKSHEET_HINTS = {
            series_basic: {
                guide: "Series loop: the same current flows through every component. Sum R_T, solve I_T = E / R_T, then log W = I * E before checking totals.",
                note: "Use Reveal totals once your W.I.R.E. entries are complete to confirm the drops add back to 24 V."
            },
            parallel_basic: {
                guide: "Parallel network: voltage is common for each branch. Compute branch currents with I = E / R, then add them for I_T before checking totals.",
                note: "Reveal totals when you are ready to compare the branch sums with the source current and equivalent resistance."
            },
            mixed_circuit: {
                guide: "Collapse the ladder by simplifying the parallel section first, add the series portions, and document each step in the table.",
                note: "Tap Reveal totals only after updating the worksheet for every reduction you perform."
            },
            combination_advanced: {
                guide: "Work branch-by-branch: simplify parallel legs, fold them into series paths, and repeat while logging each equivalent in W.I.R.E.",
                note: "Reveal totals when you want to verify each loop against Kirchhoff's laws."
            },
            random: {
                guide: "Identify which elements share current or voltage before selecting the right Ohm's Law identity, then fill the blanks methodically.",
                note: "Record the givens first, then use Reveal totals to compare with the live W.I.R.E. analysis."
            },
            default: {
                guide: "Record the givens, apply Ohm's Law to uncover the unknowns, then tap Reveal totals to check your answers.",
                note: "Reveal totals only when you're ready to verify your work against the live W.I.R.E. metrics."
            }
        };

        let currentWireWorksheetContext = null;
        let wireWorksheetSolutionsVisible = false;

        function formatWireNumber(value, decimalsForSmall) {
            if (!isFinite(value)) {
                return "0";
            }

            const absValue = Math.abs(value);
            if (absValue >= 100) {
                return value.toFixed(0);
            }
            if (absValue >= 10) {
                return value.toFixed(1);
            }

            const decimals = typeof decimalsForSmall === "number" ? decimalsForSmall : 2;
            return value.toFixed(decimals);
        }

        function formatVoltage(value, options) {
            const opts = options || {};
            if (!isFinite(value)) {
                return opts.allowZero ? "0 V" : "--";
            }

            const formatted = formatWireNumber(value, 2);
            return opts.includeUnit === false ? formatted : `${formatted} V`;
        }

        function formatCurrent(value, options) {
            const opts = options || {};
            if (!isFinite(value)) {
                return opts.allowZero ? "0 A" : "--";
            }

            const absValue = Math.abs(value);
            let decimals = 3;
            if (absValue >= 10) {
                decimals = 1;
            } else if (absValue >= 1) {
                decimals = 2;
            }

            const formatted = value.toFixed(decimals);
            return opts.includeUnit === false ? formatted : `${formatted} A`;
        }

        function formatResistance(value, options) {
            const opts = options || {};
            if (!isFinite(value)) {
                return opts.allowOpen ? "open" : "--";
            }

            const formatted = formatWireNumber(value, 2);
            return opts.includeUnit === false ? formatted : `${formatted} ohm`;
        }

        function formatPower(value, options) {
            const opts = options || {};
            if (!isFinite(value)) {
                return opts.allowZero ? "0 W" : "--";
            }

            const absValue = Math.abs(value);
            let decimals = 2;
            if (absValue >= 100) {
                decimals = 0;
            } else if (absValue >= 10) {
                decimals = 1;
            }

            const formatted = value.toFixed(decimals);
            return opts.includeUnit === false ? formatted : `${formatted} W`;
        }

        function describeComponentForWorksheet(spec) {
            const props = spec?.properties || {};
            let baseId = spec?.id;

            if (!baseId) {
                if (typeof spec?.componentNumber === "number" && spec?.type) {
                    switch (spec.type) {
                        case "battery":
                            baseId = `B${spec.componentNumber}`;
                            break;
                        case "resistor":
                            baseId = `R${spec.componentNumber}`;
                            break;
                        case "led":
                            baseId = `LED${spec.componentNumber}`;
                            break;
                        case "switch":
                            baseId = `SW${spec.componentNumber}`;
                            break;
                        default:
                            baseId = `${spec.type.charAt(0).toUpperCase()}${spec.componentNumber}`;
                            break;
                    }
                } else if (spec?.type) {
                    baseId = spec.type.toUpperCase();
                } else {
                    baseId = "Component";
                }
            }

            const descriptor = {
                display: baseId,
                aria: baseId,
                key: String(baseId).toLowerCase().replace(/[^a-z0-9]+/g, "-") || "component"
            };

            switch (spec?.type) {
                case "battery": {
                    const voltage = Number(props.voltage);
                    const voltageText = isFinite(voltage) ? formatVoltage(voltage) : null;
                    descriptor.display = voltageText ? `${baseId} - source (${voltageText})` : `${baseId} - source`;
                    descriptor.aria = `${baseId} source`;
                    break;
                }
                case "resistor": {
                    const resistance = Number(props.resistance);
                    if (isFinite(resistance)) {
                        descriptor.display = `${baseId} (${formatResistance(resistance)})`;
                    }
                    descriptor.aria = `${baseId} resistor`;
                    break;
                }
                case "led": {
                    const resistance = Number(props.resistance ?? props.seriesResistance);
                    if (isFinite(resistance)) {
                        descriptor.display = `${baseId} (${formatResistance(resistance)})`;
                    }
                    descriptor.aria = `${baseId} led`;
                    break;
                }
                case "switch": {
                    const state = props.isOn === false ? "open" : "closed";
                    descriptor.display = `${baseId} - switch (${state})`;
                    descriptor.aria = `${baseId} switch ${state}`;
                    break;
                }
                default:
                    break;
            }

            return descriptor;
        }

        function getWorksheetPlaceholder(spec, field) {
            switch (field) {
                case "W":
                    return spec?.type === "battery" ? "W_T" : "W";
                case "I":
                    return spec?.type === "battery" ? "I_T" : "I";
                case "R":
                    return "R";
                case "E":
                    return spec?.type === "battery" ? "source" : "E";
                default:
                    return "?";
            }
        }

        function buildWorksheetCellDescriptor(spec, field) {
            const props = spec?.properties || {};

            if (field === "R") {
                if (spec?.type === "battery") {
                    return { type: "readonly", value: "n/a" };
                }

                if (spec?.type === "resistor" || spec?.type === "led") {
                    const resistance = Number(props.resistance ?? props.seriesResistance);
                    if (isFinite(resistance)) {
                        return { type: "given", value: formatResistance(resistance) };
                    }
                }

                if (spec?.type === "switch") {
                    if (props.isOn === false) {
                        return { type: "given", value: "open" };
                    }
                    const resistance = Number(props.resistance ?? props.onResistance);
                    if (isFinite(resistance)) {
                        return { type: "given", value: formatResistance(resistance) };
                    }
                }
            }

            if (field === "E" && spec?.type === "battery") {
                const voltage = Number(props.voltage);
                if (isFinite(voltage)) {
                    return { type: "given", value: formatVoltage(voltage) };
                }
            }

            return {
                type: "input",
                placeholder: getWorksheetPlaceholder(spec, field)
            };
        }

        function extractWorksheetSpecsFromPreset(preset) {
            if (!preset || !Array.isArray(preset.components)) {
                return [];
            }

            return preset.components.map((component) => ({
                id: component.id || null,
                type: component.type,
                componentNumber: component.componentNumber || null,
                properties: Object.assign({}, component.properties || {})
            }));
        }

        function extractWorksheetSpecsFromActiveScene() {
            return components.map((component) => ({
                id: typeof component.getComponentIdentifier === "function" ? component.getComponentIdentifier() : component.id,
                type: component.type,
                componentNumber: component.componentNumber,
                properties: Object.assign({}, component.properties || {})
            }));
        }

        function renderWireWorksheetFromSpecs(specs, options) {
            const wrapper = document.getElementById("wire-table-wrapper");
            const body = document.getElementById("wire-table-body");
            const scenarioEl = document.getElementById("wire-table-scenario");
            const guideEl = document.getElementById("wire-table-guide");
            const noteEl = document.getElementById("wire-table-note");

            if (!wrapper || !body) {
                return;
            }

            if (!Array.isArray(specs) || specs.length === 0) {
                body.innerHTML = "";
                wrapper.style.display = "none";
                if (scenarioEl) {
                    scenarioEl.textContent = "";
                }
                if (guideEl) {
                    guideEl.textContent = PRACTICE_WORKSHEET_HINTS.default.guide;
                }
                if (noteEl) {
                    noteEl.textContent = PRACTICE_WORKSHEET_HINTS.default.note;
                }
                currentWireWorksheetContext = null;
                return;
            }

            const sortedSpecs = specs
                .slice()
                .sort((a, b) => (WIRE_TYPE_ORDER[a?.type] ?? 99) - (WIRE_TYPE_ORDER[b?.type] ?? 99));

            body.innerHTML = "";

            let totalVoltage = 0;

            sortedSpecs.forEach((spec) => {
                const descriptor = describeComponentForWorksheet(spec);
                const row = document.createElement("tr");
                row.dataset.wireRow = descriptor.key;

                const labelCell = document.createElement("td");
                labelCell.textContent = descriptor.display;
                row.appendChild(labelCell);

                WIRE_TABLE_HEADERS.forEach((field) => {
                    const cell = document.createElement("td");
                    cell.dataset.wireField = field;

                    const cellDescriptor = buildWorksheetCellDescriptor(spec, field);
                    if (cellDescriptor.type === "given" || cellDescriptor.type === "readonly") {
                        const span = document.createElement("span");
                        span.className = "wire-cell-given";
                        span.textContent = cellDescriptor.value || (cellDescriptor.type === "readonly" ? "n/a" : "");
                        cell.appendChild(span);
                    } else {
                        const input = document.createElement("input");
                        input.type = "text";
                        input.className = "wire-input";
                        input.placeholder = cellDescriptor.placeholder || "?";
                        input.setAttribute("data-wire-input", `${descriptor.key}-${field}`);
                        input.setAttribute("aria-label", `${WIRE_FIELD_LABELS[field]} entry for ${descriptor.aria}`);
                        cell.appendChild(input);
                    }

                    row.appendChild(cell);
                });

                body.appendChild(row);

                if (spec?.type === "battery") {
                    const voltage = Number(spec?.properties?.voltage);
                    if (isFinite(voltage)) {
                        totalVoltage += voltage;
                    }
                }
            });

            const totalsRow = document.createElement("tr");
            totalsRow.className = "wire-table-total";
            totalsRow.dataset.wireRow = "totals";

            const totalsLabel = document.createElement("td");
            totalsLabel.textContent = "Totals";
            totalsRow.appendChild(totalsLabel);

            const totalsConfig = {
                W: { placeholder: "W_T", solution: true },
                I: { placeholder: "I_T", solution: true },
                R: { placeholder: "R_T", solution: true },
                E: { value: formatVoltage(totalVoltage) }
            };

            WIRE_TABLE_HEADERS.forEach((field) => {
                const cell = document.createElement("td");
                cell.dataset.wireField = field;

                const config = totalsConfig[field] || {};
                if (config.value !== undefined) {
                    const span = document.createElement("span");
                    span.className = "wire-cell-given";
                    span.textContent = config.value;
                    cell.appendChild(span);
                } else {
                    const input = document.createElement("input");
                    input.type = "text";
                    input.className = "wire-input";
                    input.placeholder = config.placeholder || "?";
                    input.setAttribute("data-wire-input", `total-${field}`);
                    input.setAttribute("aria-label", `${WIRE_FIELD_LABELS[field]} total entry`);
                    cell.appendChild(input);

                    if (config.solution) {
                        const solutionSpan = document.createElement("span");
                        solutionSpan.className = "wire-solution";
                        solutionSpan.dataset.wireField = field;
                        cell.appendChild(solutionSpan);
                    }
                }

                totalsRow.appendChild(cell);
            });

            body.appendChild(totalsRow);

            wrapper.style.display = "block";

            if (scenarioEl) {
                scenarioEl.textContent = options?.scenarioName ? `? ${options.scenarioName}` : "";
            }

            const hintKey = options?.scenarioKey && PRACTICE_WORKSHEET_HINTS[options.scenarioKey] ? options.scenarioKey : "default";
            const hint = PRACTICE_WORKSHEET_HINTS[hintKey] || PRACTICE_WORKSHEET_HINTS.default;

            if (guideEl) {
                guideEl.textContent = options?.guide || hint.guide;
            }

            if (noteEl) {
                noteEl.textContent = options?.note || hint.note;
            }

            currentWireWorksheetContext = {
                scenario: options?.scenarioName || "",
                totalVoltage
            };

            wireWorksheetSolutionsVisible = false;
            updateWireWorksheetToggleLabel();
            refreshWireWorksheetSolutions();
        }

        function renderWireWorksheetFromPreset(presetName, preset) {
            const specs = extractWorksheetSpecsFromPreset(preset);
            renderWireWorksheetFromSpecs(specs, {
                scenarioName: preset?.name || presetName,
                scenarioKey: presetName
            });
        }

        function renderWireWorksheetFromActiveCircuit(label) {
            const specs = extractWorksheetSpecsFromActiveScene();
            renderWireWorksheetFromSpecs(specs, {
                scenarioName: label || "Active Circuit",
                scenarioKey: "random"
            });
        }

        function resetWireWorksheetInputs() {
            const wrapper = document.getElementById("wire-table-wrapper");
            if (!wrapper) {
                return;
            }

            wrapper.querySelectorAll(".wire-input").forEach((input) => {
                input.value = "";
            });

            refreshWireWorksheetSolutions();
        }

        function clearWireWorksheetDisplay() {
            const wrapper = document.getElementById("wire-table-wrapper");
            const body = document.getElementById("wire-table-body");
            const scenarioEl = document.getElementById("wire-table-scenario");
            const guideEl = document.getElementById("wire-table-guide");
            const noteEl = document.getElementById("wire-table-note");

            if (body) {
                body.innerHTML = "";
            }
            if (wrapper) {
                wrapper.style.display = "none";
            }
            if (scenarioEl) {
                scenarioEl.textContent = "";
            }
            if (guideEl) {
                guideEl.textContent = PRACTICE_WORKSHEET_HINTS.default.guide;
            }
            if (noteEl) {
                noteEl.textContent = PRACTICE_WORKSHEET_HINTS.default.note;
            }

            currentWireWorksheetContext = null;
            wireWorksheetSolutionsVisible = false;
            updateWireWorksheetToggleLabel();
        }

        function refreshWireWorksheetSolutions() {
            const wrapper = document.getElementById("wire-table-wrapper");
            if (!wrapper || wrapper.style.display === "none") {
                return;
            }

            if (!lastKnownValues) {
                return;
            }

            const hasSolution =
                isFinite(lastKnownValues.resistance) &&
                lastKnownValues.resistance !== Infinity &&
                isFinite(lastKnownValues.current) &&
                lastKnownValues.voltage > 0 &&
                lastKnownValues.current >= 0;

            const solutions = [
                { field: "W", value: lastKnownValues.power, formatter: (value) => formatPower(value, { includeUnit: true }) },
                { field: "I", value: lastKnownValues.current, formatter: (value) => formatCurrent(value, { includeUnit: true }) },
                { field: "R", value: lastKnownValues.resistance, formatter: (value) => formatResistance(value, { includeUnit: true, allowOpen: true }) }
            ];

            solutions.forEach(({ field, value, formatter }) => {
                const element = wrapper.querySelector(`.wire-solution[data-wire-field="${field}"]`);
                if (!element) {
                    return;
                }

                if (hasSolution && wireWorksheetSolutionsVisible) {
                    element.textContent = `calc: ${formatter(value)}`;
                    element.style.display = "block";
                } else {
                    element.textContent = "";
                    element.style.display = "none";
                }
            });
        }

        function updateWireWorksheetToggleLabel() {
            const toggleButton = document.getElementById("wire-table-toggle-solutions");
            if (!toggleButton) {
                return;
            }

            toggleButton.textContent = wireWorksheetSolutionsVisible ? "Hide totals" : "Reveal totals";
            toggleButton.dataset.active = wireWorksheetSolutionsVisible ? "true" : "false";
        }

        function toggleWireWorksheetSolutions() {
            wireWorksheetSolutionsVisible = !wireWorksheetSolutionsVisible;
            updateWireWorksheetToggleLabel();
            refreshWireWorksheetSolutions();
        }
        
        // Long press and edit variables
        let longPressTimer = null;
        let longPressStartPos = { x: 0, y: 0 };
        let isLongPressing = false;
        let currentEditComponent = null;
        const LONG_PRESS_DURATION = 500; // Reduced for faster response on mobile
        const COMPONENT_DRAG_THRESHOLD = 8;
        const LONG_PRESS_MOVEMENT_THRESHOLD = 15; // Increased for mobile finger wobble tolerance
        let componentContextMenu = null;
        let componentContextTarget = null;
        let componentContextConnectionPoint = null;
        let componentContextMenuCloseSuppressUntil = 0;
        
        // Grid and snapping variables
        const GRID_SIZE = 2; // Grid spacing
        const WIRE_SPLIT_ENDPOINT_TOLERANCE = 0.18;
        const JUNCTION_REUSE_RADIUS = 0.35;
        let gridHelper = null;
        let snapIndicator = null;
        
        // W.I.R.E. Color coding
        const WIRE_COLORS = {
            W: '#4488ff', // Power (Watts) - Blue
            I: '#ff8844', // Current (Amps) - Orange  
            R: '#44ff88', // Resistance (Ohms) - Green
            E: '#ff4444'  // Voltage (Volts) - Red
        };

        const DEFAULT_WIRE_SEGMENT_RESISTANCE = 0.01;
        const FLOW_CONSTANTS = {
            wireResistance: DEFAULT_WIRE_SEGMENT_RESISTANCE,
            shortThreshold: 0.5,
            resistanceReference: 120,
            minSpeedFactor: 0.25,
            maxSpeedFactor: 1.0
        };

        let currentFlowState = null;
        let activeWireProfile = null;

        function applyWireProfileFromBridge(profile) {
            const resistanceCandidate = Number(profile?.resistanceOhmPerMeter);
            const hasValidResistance =
                Number.isFinite(resistanceCandidate) && resistanceCandidate > 0;

            if (hasValidResistance) {
                FLOW_CONSTANTS.wireResistance = resistanceCandidate;
                activeWireProfile = {
                    id: typeof profile?.id === 'string' ? profile.id : null,
                    gaugeLabel: typeof profile?.gaugeLabel === 'string' ? profile.gaugeLabel : 'Custom wire',
                    resistanceOhmPerMeter: resistanceCandidate
                };
                const label = activeWireProfile.gaugeLabel || 'Custom wire';
                setStatus(` Wire profile active: ${label} (${resistanceCandidate.toFixed(4)} /m)`);
            } else {
                FLOW_CONSTANTS.wireResistance = DEFAULT_WIRE_SEGMENT_RESISTANCE;
                activeWireProfile = null;
                setStatus(` Default wire model active (${DEFAULT_WIRE_SEGMENT_RESISTANCE.toFixed(2)} /segment)`);
            }

            if (typeof analyzeCircuit === 'function') {
                try {
                    analyzeCircuit();
                } catch (error) {
                    console.warn('Wire profile apply: circuit re-analysis failed', error);
                }
            }

            notifyParentModeState({
                wireProfile: activeWireProfile
                    ? {
                        id: activeWireProfile.id,
                        gaugeLabel: activeWireProfile.gaugeLabel,
                        resistanceOhmPerMeter: activeWireProfile.resistanceOhmPerMeter
                    }
                    : null,
                wireResistance: FLOW_CONSTANTS.wireResistance
            });
        }
        
        // Component counters for labeling
        let componentCounters = {
            battery: 0,
            resistor: 0,
            led: 0,
            switch: 0,
            capacitor: 0,
            'capacitor-ceramic': 0,
            inductor: 0,
            diode: 0,
            'zener-diode': 0,
            photodiode: 0,
            thermistor: 0,
            crystal: 0,
            bjt: 0,
            'bjt-npn': 0,
            'bjt-pnp': 0,
            darlington: 0,
            mosfet: 0,
            fuse: 0,
            potentiometer: 0,
            lamp: 0,
            ground: 0,
            ac_source: 0,
            motor: 0,
            speaker: 0,
            opamp: 0,
            transformer: 0
        };

        // Track placement offset for staggering components
        let componentPlacementIndex = 0;
        
        // Camera controls
        let cameraDistance = 15;
        let cameraAngleX = 0, cameraAngleY = 0.5;
        let cameraTarget = new THREE.Vector3(0, 0, 0);
        let isRotating = false, isPanning = false;
        let lastTouchPos = { x: 0, y: 0 };
        let lastTwoFingerCenter = { x: 0, y: 0 };
        let lastPinchDistance = 0;

        // Mobile detection
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        const isAndroid = /Android/i.test(navigator.userAgent);

        // Adjust settings for mobile
        if (isMobile) {
            // Reduce particle count for better performance
            const originalParticleCount = 8;
            // Increase touch sensitivity
            const TOUCH_SENSITIVITY = 0.8;
            // Reduce quality for better performance
            const MOBILE_QUALITY_FACTOR = 0.7;
        }

        const worldUpVector = new THREE.Vector3(0, 1, 0);
        const cameraDirectionVec = new THREE.Vector3();
        const cameraRightVec = new THREE.Vector3();
        const cameraUpVec = new THREE.Vector3();
        const PAN_SENSITIVITY_BASE = isMobile ? (isAndroid ? 0.0046 : 0.0048) : 0.0036;
        const TOUCH_ROTATE_SENSITIVITY_X = isMobile ? (isAndroid ? 0.0085 : 0.0072) : 0.0056;
        const TOUCH_ROTATE_SENSITIVITY_Y = isMobile ? (isAndroid ? 0.0065 : 0.0052) : 0.0042;
        const TOUCH_ROTATE_Y_MIN = -1.3;
        const TOUCH_ROTATE_Y_MAX = 1.3;
        const TWO_FINGER_PAN_MULTIPLIER = isMobile ? (isAndroid ? 1.05 : 0.85) : 0.75;
        const ZOOM_SENSITIVITY_BASE = isMobile ? (isAndroid ? 0.012 : 0.015) : 0.02;

        // Junction class
        class Junction {
            constructor(position, options = {}) {
                const { snapToGridPosition = true } = options;
                const initialPosition = position instanceof THREE.Vector3
                    ? position.clone()
                    : new THREE.Vector3(
                        Number(position?.x) || 0,
                        Number(position?.y) || 0,
                        Number(position?.z) || 0
                    );

                if (snapToGridPosition) {
                    this.position = snapToGrid(initialPosition);
                } else {
                    initialPosition.y = 0;
                    this.position = initialPosition;
                }
                this.connections = [];
                this.id = 'junction_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                this.createMesh();
            }

            createMesh() {
                const group = new THREE.Group();
                
                // Main purple sphere
                const bodyGeometry = new THREE.SphereGeometry(0.25, isMobile ? 12 : 16, isMobile ? 8 : 12);
                const bodyMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0x8844ff,
                    emissive: 0x221188,
                    shininess: 100
                });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                group.add(body);
                
                // Selection sphere
                const selectionGeometry = new THREE.SphereGeometry(isMobile ? 1.2 : 0.8, 8, 6);
                const selectionMaterial = new THREE.MeshBasicMaterial({ 
                    transparent: true,
                    opacity: 0.0
                });
                const selectionSphere = new THREE.Mesh(selectionGeometry, selectionMaterial);
                selectionSphere.userData = { junction: this, isSelectionBox: true };
                group.add(selectionSphere);
                
                group.position.copy(this.position);
                group.userData = { junction: this };
                
                this.mesh = group;
                this.selectionSphere = selectionSphere;
                scene.add(group);
                
                this.createConnectionPoint();
            }

            createConnectionPoint() {
                const pointGeometry = new THREE.SphereGeometry(0.28, isMobile ? 12 : 16, isMobile ? 8 : 12);
                const pointMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0xaa66ff,
                    emissive: 0x332288,
                    shininess: 200
                });
                
                const connectionPoint = new THREE.Mesh(pointGeometry, pointMaterial);
                connectionPoint.position.set(0, 0, 0);
                connectionPoint.userData = { 
                    junction: this, 
                    isConnectionPoint: true, 
                    side: 'center',
                    polarity: 'neutral'
                };
                
                this.mesh.add(connectionPoint);
                this.connectionPoint = connectionPoint;
            }

            getWorldConnectionPoint() {
                // Return exact junction position WITHOUT grid snapping to prevent gaps.
                // Wires must connect precisely to junction centers.
                if (this.connectionPoint) {
                    const worldPosition = new THREE.Vector3();
                    this.connectionPoint.getWorldPosition(worldPosition);
                    return worldPosition;
                }
                return this.position.clone();
            }

            addConnection(wire) {
                this.connections.push(wire);
            }

            removeConnection(wire) {
                const index = this.connections.indexOf(wire);
                if (index > -1) {
                    this.connections.splice(index, 1);
                }
            }

            remove() {
                if (this.mesh) {
                    scene.remove(this.mesh);
                }
                const connectedWires = [...this.connections];
                connectedWires.forEach(wire => wire.remove());
                const index = junctions.indexOf(this);
                if (index > -1) {
                    junctions.splice(index, 1);
                }
            }
        }

        // Helper function to convert 3D world position to 2D screen coordinates
        function worldToScreen(worldPosition) {
            const vector = worldPosition.clone();
            vector.project(camera);

            // Use the actual canvas dimensions and position, not window dimensions
            // This fixes polarity markers appearing in wrong positions in embedded mode
            const canvas = renderer?.domElement;
            let width, height, offsetX, offsetY;

            if (canvas) {
                const rect = canvas.getBoundingClientRect();
                width = rect.width;
                height = rect.height;
                offsetX = rect.left;
                offsetY = rect.top;
            } else {
                width = window.innerWidth;
                height = window.innerHeight;
                offsetX = 0;
                offsetY = 0;
            }

            const x = (vector.x * 0.5 + 0.5) * width + offsetX;
            const y = (-vector.y * 0.5 + 0.5) * height + offsetY;

            return { x, y, z: vector.z };
        }

        // Component class
        class Component {
            constructor(type, position) {
                this.type = type;
                this.position = snapToGrid(position);
                this.rotation = 0;
                this.connections = [];
                this.properties = this.getDefaultProperties(type);
                this.runtimeMetrics = null;
                
                // Assign component number
                componentCounters[type]++;
                this.componentNumber = componentCounters[type];
                this.id = type + '_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                
                this.createMesh();
                this.createConnectionPoints();
                this.createComponentLabels();
            }

            getDefaultProperties(type) {
                switch(type) {
                    case 'battery': return { voltage: 9 };
                    case 'resistor': return { resistance: 100 };
                    case 'led': return { resistance: 10 };
                    case 'switch': return { resistance: 0.1, isOn: true };
                    case 'capacitor': return { capacitance: 100 }; // F
                    case 'capacitor-ceramic': return { capacitance: 0.1 }; // F (typical decoupling)
                    case 'inductor': return { inductance: 10 }; // mH
                    case 'diode': return { forwardVoltage: 0.7 };
                    case 'zener-diode': return { forwardVoltage: 0.7, zenerVoltage: 5.1 };
                    case 'photodiode': return { forwardVoltage: 0.7 };
                    case 'thermistor': return { resistance: 10000 }; //  @ 25C (typical NTC)
                    case 'crystal': return { frequency: 16000000 }; // Hz
                    case 'bjt': return { gain: 100 };
                    case 'bjt-npn': return { gain: 100, polarity: 'NPN' };
                    case 'bjt-pnp': return { gain: 100, polarity: 'PNP' };
                    case 'darlington': return { gain: 10000 };
                    case 'mosfet': return { threshold: 2.5 };
                    case 'fuse': return { current: 1 }; // A
                    case 'potentiometer': return { resistance: 10, position: 50 }; // k, %
                    case 'lamp': return { resistance: 10 };
                    case 'ground': return {};
                    case 'ac_source': return { voltage: 120, frequency: 60 }; // V rms, Hz
                    case 'motor': return { power: 10, rpm: 3000 }; // W, RPM
                    case 'speaker': return { impedance: 8, power: 1 }; // , W
                    case 'opamp': return { gain: 100000 };
                    case 'transformer': return { ratio: 1, primaryVoltage: 120 }; // turns ratio, V
                    default: return {};
                }
            }

            createComponentLabels() {
                // Create DOM labels that will float above components
                this.labelDiv = document.createElement('div');
                this.labelDiv.className = 'component-label component-label-floating';
                this.labelDiv.style.fontSize = isMobile ? '16px' : '14px';
                this.labelDiv.style.fontWeight = 'bold';
                this.labelDiv.style.textAlign = 'center';
                this.labelDiv.style.lineHeight = '1.2';
                this.labelDiv.innerHTML = this.renderNameplateMarkup();
                
                document.body.appendChild(this.labelDiv);
                this.updateLabelPosition();
            }

            getComponentIdentifier() {
                switch(this.type) {
                    case 'battery': return `B${this.componentNumber}`;
                    case 'resistor': return `R${this.componentNumber}`;
                    case 'led': return `LED${this.componentNumber}`;
                    case 'switch': return `SW${this.componentNumber}`;
                    case 'capacitor': return `C${this.componentNumber}`;
                    case 'capacitor-ceramic': return `C${this.componentNumber}`;
                    case 'inductor': return `L${this.componentNumber}`;
                    case 'diode': return `D${this.componentNumber}`;
                    case 'zener-diode': return `DZ${this.componentNumber}`;
                    case 'photodiode': return `PD${this.componentNumber}`;
                    case 'thermistor': return `RT${this.componentNumber}`;
                    case 'crystal': return `Y${this.componentNumber}`;
                    case 'bjt': return `Q${this.componentNumber}`;
                    case 'bjt-npn': return `NPN${this.componentNumber}`;
                    case 'bjt-pnp': return `PNP${this.componentNumber}`;
                    case 'darlington': return `DRL${this.componentNumber}`;
                    case 'mosfet': return `M${this.componentNumber}`;
                    case 'fuse': return `F${this.componentNumber}`;
                    case 'potentiometer': return `POT${this.componentNumber}`;
                    case 'lamp': return `LA${this.componentNumber}`;
                    case 'ground': return `GND${this.componentNumber}`;
                    case 'ac_source': return `AC${this.componentNumber}`;
                    case 'motor': return `MTR${this.componentNumber}`;
                    case 'speaker': return `SPK${this.componentNumber}`;
                    case 'opamp': return `OP${this.componentNumber}`;
                    case 'transformer': return `T${this.componentNumber}`;
                    default: return `C${this.componentNumber}`;
                }
            }

            renderNameplateMarkup() {
                const identifier = this.getComponentIdentifier();
                const { text, color } = this.getValueTextAndColor();
                const runtimeMarkup = this.getRuntimeMetricMarkup();

                return `
                    <div style="color: white; font-size: ${isMobile ? '14px' : '12px'};">${identifier}</div>
                    <div style="color: ${color}; font-size: ${isMobile ? '13px' : '11px'}; font-weight: bold;">${text}</div>
                    ${runtimeMarkup}
                `;
            }

            getValueTextAndColor() {
                switch(this.type) {
                    case 'battery':
                        return {
                            text: `${this.properties.voltage}V`,
                            color: WIRE_COLORS.E // Voltage - Red
                        };
                    case 'resistor':
                        return {
                            text: `${this.properties.resistance}`,
                            color: WIRE_COLORS.R // Resistance - Green
                        };
                    case 'led':
                        return {
                            text: `${this.properties.resistance}`,
                            color: WIRE_COLORS.R // Resistance - Green
                        };
                    case 'switch':
                        const state = this.properties.isOn ? 'ON' : 'OFF';
                        return {
                            text: state,
                            color: this.properties.isOn ? '#44ff44' : '#ff4444'
                        };
                    case 'capacitor':
                        return {
                            text: `${this.properties.capacitance}F`,
                            color: '#4488ff' // Blue
                        };
                    case 'capacitor-ceramic':
                        return {
                            text: `${this.properties.capacitance}F`,
                            color: '#66aaff' // Light blue
                        };
                    case 'inductor':
                        return {
                            text: `${this.properties.inductance}mH`,
                            color: '#ff8844' // Orange
                        };
                    case 'diode':
                        return {
                            text: `${this.properties.forwardVoltage}V`,
                            color: '#888888' // Gray
                        };
                    case 'zener-diode':
                        return {
                            text: `Vz=${this.properties.zenerVoltage}V`,
                            color: '#4A90D9' // Blue-gray
                        };
                    case 'photodiode':
                        return {
                            text: `Light`,
                            color: '#aaaaaa' // Gray
                        };
                    case 'thermistor':
                        return {
                            text: `${this.properties.resistance}`,
                            color: '#ff8844' // Orange
                        };
                    case 'crystal':
                        return {
                            text: `${this.properties.frequency}Hz`,
                            color: '#66ccff' // Cyan
                        };
                    case 'bjt':
                        return {
                            text: `=${this.properties.gain}`,
                            color: '#ff44ff' // Magenta
                        };
                    case 'bjt-npn':
                        return {
                            text: `NPN =${this.properties.gain}`,
                            color: '#ff44ff' // Magenta
                        };
                    case 'bjt-pnp':
                        return {
                            text: `PNP =${this.properties.gain}`,
                            color: '#ff88ff' // Light magenta
                        };
                    case 'darlington':
                        return {
                            text: `=${this.properties.gain}`,
                            color: '#cc44cc' // Purple
                        };
                    case 'mosfet':
                        return {
                            text: `Vth=${this.properties.threshold}V`,
                            color: '#44ffff' // Cyan
                        };
                    case 'fuse':
                        return {
                            text: `${this.properties.current}A`,
                            color: '#ffff44' // Yellow
                        };
                    case 'potentiometer':
                        return {
                            text: `${this.properties.resistance}k @${this.properties.position}%`,
                            color: WIRE_COLORS.R // Green
                        };
                    case 'lamp':
                        return {
                            text: `${this.properties.resistance}`,
                            color: '#ffdd44' // Yellow-orange
                        };
                    case 'ground':
                        return {
                            text: 'GND',
                            color: '#666666' // Dark gray
                        };
                    case 'ac_source':
                        return {
                            text: `${this.properties.voltage}V ${this.properties.frequency}Hz`,
                            color: '#ffaa44' // Orange - AC
                        };
                    case 'motor':
                        return {
                            text: `${this.properties.power}W ${this.properties.rpm}RPM`,
                            color: '#44aaff' // Blue
                        };
                    case 'speaker':
                        return {
                            text: `${this.properties.impedance} ${this.properties.power}W`,
                            color: '#aa44ff' // Purple
                        };
                    case 'opamp':
                        return {
                            text: `A=${this.properties.gain}`,
                            color: '#44ff88' // Green-cyan
                        };
                    case 'transformer':
                        return {
                            text: `${this.properties.ratio}:1 ${this.properties.primaryVoltage}V`,
                            color: '#ff8844' // Orange
                        };
                    default:
                        return { text: '', color: '#ffffff' };
                }
            }

            getRuntimeMetricMarkup() {
                const metrics = this.runtimeMetrics;
                if (!metrics || typeof metrics !== 'object') {
                    return '';
                }

                const fontSize = isMobile ? '11px' : '10px';
                const valueColor = '#e8f6ff';
                const separator = '<span style="color: rgba(190, 210, 240, 0.75);"> | </span>';

                if (metrics.state === 'open') {
                    const reason = typeof metrics.reason === 'string' ? metrics.reason : 'open';
                    const reasonText = reason === 'polarity'
                        ? 'polarity block'
                        : reason === 'short'
                            ? 'short path'
                            : reason === 'no-source'
                                ? 'no source'
                                : 'open';
                    return `
                        <div style="font-size: ${fontSize}; font-weight: 600;">
                            <span style="color: ${WIRE_COLORS.I};">I</span>
                            <span style="color: ${valueColor};"> ${formatCurrent(0, { allowZero: true })}</span>
                            <span style="color: #ff8888;"> | ${reasonText}</span>
                        </div>
                    `;
                }

                if (metrics.state === 'idle') {
                    return `
                        <div style="font-size: ${fontSize}; font-weight: 600;">
                            <span style="color: ${WIRE_COLORS.I};">I</span>
                            <span style="color: ${valueColor};"> ${formatCurrent(0, { allowZero: true })}</span>
                            <span style="color: #a0b4c8;"> | idle</span>
                        </div>
                    `;
                }

                const parts = [];

                if (isFinite(metrics.power)) {
                    parts.push(
                        `<span style="color: ${WIRE_COLORS.W};">W</span><span style="color: ${valueColor};"> ${formatPower(metrics.power, { allowZero: true })}</span>`
                    );
                }

                if (isFinite(metrics.current)) {
                    parts.push(
                        `<span style="color: ${WIRE_COLORS.I};">I</span><span style="color: ${valueColor};"> ${formatCurrent(metrics.current, { allowZero: true })}</span>`
                    );
                }

                if (isFinite(metrics.resistance)) {
                    parts.push(
                        `<span style="color: ${WIRE_COLORS.R};">R</span><span style="color: ${valueColor};"> ${formatResistance(metrics.resistance, { allowOpen: true })}</span>`
                    );
                }

                if (isFinite(metrics.voltageDrop)) {
                    parts.push(
                        `<span style="color: ${WIRE_COLORS.E};">E</span><span style="color: ${valueColor};"> ${formatVoltage(metrics.voltageDrop, { allowZero: true })}</span>`
                    );
                }

                if (parts.length === 0) {
                    return '';
                }

                return `<div style="font-size: ${fontSize}; font-weight: 600;">${parts.join(separator)}</div>`;
            }

            updateRuntimeMetrics(runtimeMetrics) {
                this.runtimeMetrics = runtimeMetrics && typeof runtimeMetrics === 'object'
                    ? runtimeMetrics
                    : null;
                this.updateLabels();
            }

            updateLabelPosition() {
                if (!this.labelDiv || !this.mesh) return;
                
                const worldPos = new THREE.Vector3();
                worldPos.setFromMatrixPosition(this.mesh.matrixWorld);
                worldPos.y += 3; // Position above component
                
                const screenPos = worldToScreen(worldPos);
                
                this.labelDiv.style.left = (screenPos.x - (isMobile ? 40 : 30)) + 'px';
                this.labelDiv.style.top = (screenPos.y - (isMobile ? 40 : 30)) + 'px';
                
                // Hide label if component is behind camera
                this.labelDiv.style.display = screenPos.z > 1 ? 'none' : (showLabels ? 'block' : 'none');
            }

            updateLabels() {
                if (!this.labelDiv) return;
                this.labelDiv.innerHTML = this.renderNameplateMarkup();
                
                this.updateLabelPosition();
            }

            createMesh() {
                const group = new THREE.Group();

                switch(this.type) {
                    case 'battery':
                        this.createBatteryMesh(group);
                        break;
                    case 'resistor':
                        this.createResistorMesh(group);
                        break;
                    case 'led':
                        this.createLEDMesh(group);
                        break;
                    case 'switch':
                        this.createSwitchMesh(group);
                        break;
                    case 'capacitor':
                        this.createCapacitorMesh(group);
                        break;
                    case 'capacitor-ceramic':
                        this.createCapacitorMesh(group);
                        break;
                    case 'inductor':
                        this.createInductorMesh(group);
                        break;
                    case 'diode':
                        this.createDiodeMesh(group);
                        break;
                    case 'zener-diode':
                        this.createDiodeMesh(group);
                        break;
                    case 'photodiode':
                        this.createDiodeMesh(group);
                        break;
                    case 'thermistor':
                        this.createResistorMesh(group);
                        break;
                    case 'crystal':
                        this.createFuseMesh(group);
                        break;
                    case 'bjt':
                        this.createBJTMesh(group);
                        break;
                    case 'bjt-npn':
                        this.createBJTNPNMesh(group);
                        break;
                    case 'bjt-pnp':
                        this.createBJTPNPMesh(group);
                        break;
                    case 'darlington':
                        this.createDarlingtonMesh(group);
                        break;
                    case 'mosfet':
                        this.createMOSFETMesh(group);
                        break;
                    case 'fuse':
                        this.createFuseMesh(group);
                        break;
                    case 'potentiometer':
                        this.createPotentiometerMesh(group);
                        break;
                    case 'lamp':
                        this.createLampMesh(group);
                        break;
                    case 'ground':
                        this.createGroundMesh(group);
                        break;
                    case 'ac_source':
                        this.createACSourceMesh(group);
                        break;
                    case 'motor':
                        this.createMotorMesh(group);
                        break;
                    case 'speaker':
                        this.createSpeakerMesh(group);
                        break;
                    case 'opamp':
                        this.createOpAmpMesh(group);
                        break;
                    case 'transformer':
                        this.createTransformerMesh(group);
                        break;
                }

                group.position.copy(this.position);
                group.userData = { component: this };

                this.createSelectionBox(group);
                this.mesh = group;
                scene.add(group);
            }

            createSelectionBox(group) {
                // Adjust selection box size based on component type
                let width, height, depth;

                if (this.type === 'bjt' || this.type === 'mosfet' || this.type === 'bjt-npn' || this.type === 'bjt-pnp') {
                    // Transistors have 3 terminals below, need taller selection box
                    width = isMobile ? 3.5 : 2.8;
                    height = isMobile ? 3.0 : 2.6;
                    depth = isMobile ? 2.5 : 2.2;
                } else if (this.type === 'darlington') {
                    // Darlington is larger TO-220 package
                    width = isMobile ? 3.8 : 3.2;
                    height = isMobile ? 3.5 : 3.0;
                    depth = isMobile ? 2.5 : 2.2;
                } else if (this.type === 'potentiometer') {
                    // Potentiometer has a knob on top and 3 terminals below
                    width = isMobile ? 3.5 : 2.8;
                    height = isMobile ? 3.5 : 3.0;
                    depth = isMobile ? 2.5 : 2.2;
                } else if (this.type === 'ground') {
                    // Ground symbol is smaller and vertical
                    width = isMobile ? 2.5 : 2.0;
                    height = isMobile ? 2.5 : 2.0;
                    depth = isMobile ? 2.0 : 1.8;
                } else if (this.type === 'lamp' || this.type === 'speaker') {
                    // Lamp/Speaker has a bulb/cone shape
                    width = isMobile ? 3.0 : 2.5;
                    height = isMobile ? 3.0 : 2.6;
                    depth = isMobile ? 2.5 : 2.2;
                } else if (this.type === 'motor') {
                    // Motor has shaft extending
                    width = isMobile ? 4.5 : 3.8;
                    height = isMobile ? 3.0 : 2.5;
                    depth = isMobile ? 2.8 : 2.4;
                } else if (this.type === 'opamp') {
                    // Op-amp triangle shape
                    width = isMobile ? 4.0 : 3.4;
                    height = isMobile ? 3.0 : 2.6;
                    depth = isMobile ? 2.5 : 2.2;
                } else if (this.type === 'transformer') {
                    // Transformer with coils
                    width = isMobile ? 3.5 : 3.0;
                    height = isMobile ? 3.5 : 3.0;
                    depth = isMobile ? 2.5 : 2.2;
                } else if (this.type === 'ac_source') {
                    // AC source circle
                    width = isMobile ? 3.5 : 3.0;
                    height = isMobile ? 3.0 : 2.6;
                    depth = isMobile ? 2.5 : 2.2;
                } else {
                    // Default size for 2-terminal components
                    width = isMobile ? 4.0 : 3.2;
                    height = isMobile ? 2.5 : 2.2;
                    depth = isMobile ? 2.5 : 2.2;
                }

                const selectionGeometry = new THREE.BoxGeometry(width, height, depth);
                const selectionMaterial = new THREE.MeshBasicMaterial({
                    transparent: true,
                    opacity: 0.0,
                    depthTest: false
                });

                const selectionBox = new THREE.Mesh(selectionGeometry, selectionMaterial);
                selectionBox.userData = { component: this, isSelectionBox: true };
                selectionBox.renderOrder = 1000; // Ensure high priority for raycasting

                group.add(selectionBox);
                this.selectionBox = selectionBox;
            }

            createBatteryMesh(group) {
                // Battery body
                const segments = isMobile ? 6 : 8;
                const bodyGeometry = new THREE.CylinderGeometry(0.3, 0.3, 1.2, segments);
                const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0x1a1a1a });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.rotation.z = Math.PI / 2;
                group.add(body);

                // Positive terminal
                const posGeometry = new THREE.CylinderGeometry(0.2, 0.2, 0.3, segments);
                const posMaterial = new THREE.MeshPhongMaterial({ color: 0xb87333 });
                const pos = new THREE.Mesh(posGeometry, posMaterial);
                pos.rotation.z = Math.PI / 2;
                pos.position.x = 0.75;
                group.add(pos);

                // Negative terminal
                const negGeometry = new THREE.CylinderGeometry(0.3, 0.3, 0.15, segments);
                const negMaterial = new THREE.MeshLambertMaterial({ color: 0x2a2a2a });
                const neg = new THREE.Mesh(negGeometry, negMaterial);
                neg.rotation.z = Math.PI / 2;
                neg.position.x = -0.7;
                group.add(neg);

                // Labels
                this.addText(group, '+', new THREE.Vector3(1.0, 0.4, 0), 0xff0000);
                this.addText(group, '-', new THREE.Vector3(-1.0, 0.4, 0), 0x000000);
            }

            createResistorMesh(group) {
                const segments = isMobile ? 6 : 8;
                // Resistor body
                const bodyGeometry = new THREE.CylinderGeometry(0.15, 0.15, 1, segments);
                const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0xccaa66 });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.rotation.z = Math.PI / 2;
                group.add(body);

                // Color bands
                for(let i = 0; i < 4; i++) {
                    const bandGeometry = new THREE.CylinderGeometry(0.16, 0.16, 0.1, segments);
                    const colors = [0xff0000, 0x00ff00, 0x0000ff, 0xffd700];
                    const bandMaterial = new THREE.MeshLambertMaterial({ color: colors[i] });
                    const band = new THREE.Mesh(bandGeometry, bandMaterial);
                    band.rotation.z = Math.PI / 2;
                    band.position.x = -0.3 + i * 0.2;
                    group.add(band);
                }

                this.addLeads(group);
            }

            createLEDMesh(group) {
                const segments = isMobile ? 6 : 8;
                // LED dome
                const domeGeometry = new THREE.SphereGeometry(0.25, segments, segments/2, 0, Math.PI * 2, 0, Math.PI / 2);
                const domeMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0xff4444, 
                    transparent: true, 
                    opacity: 0.8 
                });
                const dome = new THREE.Mesh(domeGeometry, domeMaterial);
                dome.position.y = 0.1;
                group.add(dome);

                // LED base
                const baseGeometry = new THREE.CylinderGeometry(0.25, 0.25, 0.2, segments);
                const baseMaterial = new THREE.MeshLambertMaterial({ color: 0x333333 });
                const base = new THREE.Mesh(baseGeometry, baseMaterial);
                base.position.y = -0.1;
                group.add(base);

                this.addLeads(group);
            }

            createSwitchMesh(group) {
                // Switch base
                const baseGeometry = new THREE.BoxGeometry(0.8, 0.2, 0.4);
                const baseMaterial = new THREE.MeshLambertMaterial({ color: 0x666666 });
                const base = new THREE.Mesh(baseGeometry, baseMaterial);
                group.add(base);

                // Switch lever
                const leverGeometry = new THREE.BoxGeometry(0.1, 0.4, 0.1);
                const leverMaterial = new THREE.MeshLambertMaterial({ 
                    color: this.properties.isOn ? 0x00ff00 : 0xff0000 
                });
                const lever = new THREE.Mesh(leverGeometry, leverMaterial);
                lever.position.y = 0.3;
                lever.rotation.z = this.properties.isOn ? 0 : Math.PI / 6;
                group.add(lever);
                this.leverMesh = lever;

                this.addLeads(group);
            }

            addLeads(group) {
                const segments = isMobile ? 4 : 6;
                const leadGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.8, segments);
                const leadMaterial = new THREE.MeshLambertMaterial({ color: 0x888888 });
                
                const leftLead = new THREE.Mesh(leadGeometry, leadMaterial);
                leftLead.rotation.z = Math.PI / 2;
                leftLead.position.x = -0.6;
                group.add(leftLead);

                const rightLead = new THREE.Mesh(leadGeometry, leadMaterial);
                rightLead.rotation.z = Math.PI / 2;
                rightLead.position.x = 0.6;
                group.add(rightLead);
            }

            addText(group, text, position, color) {
                if (text === '+') {
                    const hBarGeometry = new THREE.BoxGeometry(0.2, 0.04, 0.04);
                    const hBarMaterial = new THREE.MeshLambertMaterial({ color: color });
                    const hBar = new THREE.Mesh(hBarGeometry, hBarMaterial);
                    hBar.position.copy(position);
                    group.add(hBar);

                    const vBarGeometry = new THREE.BoxGeometry(0.04, 0.2, 0.04);
                    const vBar = new THREE.Mesh(vBarGeometry, hBarMaterial);
                    vBar.position.copy(position);
                    group.add(vBar);
                } else if (text === '-') {
                    const barGeometry = new THREE.BoxGeometry(0.2, 0.04, 0.04);
                    const barMaterial = new THREE.MeshLambertMaterial({ color: color });
                    const bar = new THREE.Mesh(barGeometry, barMaterial);
                    bar.position.copy(position);
                    group.add(bar);
                }
            }

            createCapacitorMesh(group) {
                const segments = isMobile ? 6 : 8;
                // Capacitor body (cylinder)
                const bodyGeometry = new THREE.CylinderGeometry(0.25, 0.25, 0.7, segments);
                const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0x4488ff });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.rotation.z = Math.PI / 2;
                group.add(body);

                // Stripe (polarity indicator)
                const stripeGeometry = new THREE.CylinderGeometry(0.26, 0.26, 0.08, segments);
                const stripeMaterial = new THREE.MeshLambertMaterial({ color: 0x222222 });
                const stripe = new THREE.Mesh(stripeGeometry, stripeMaterial);
                stripe.rotation.z = Math.PI / 2;
                stripe.position.x = 0.3;
                group.add(stripe);

                this.addLeads(group);
            }

            createInductorMesh(group) {
                const segments = isMobile ? 6 : 8;
                // Inductor coil (multiple rings)
                for (let i = 0; i < 4; i++) {
                    const coilGeometry = new THREE.TorusGeometry(0.15, 0.08, segments, segments);
                    const coilMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                    const coil = new THREE.Mesh(coilGeometry, coilMaterial);
                    coil.rotation.y = Math.PI / 2;
                    coil.position.x = -0.25 + i * 0.15;
                    group.add(coil);
                }

                this.addLeads(group);
            }

            createDiodeMesh(group) {
                const segments = isMobile ? 6 : 8;
                // Diode body
                const bodyGeometry = new THREE.CylinderGeometry(0.15, 0.15, 0.8, segments);
                const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0x1a1a1a });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.rotation.z = Math.PI / 2;
                group.add(body);

                // Cathode band (silver stripe)
                const bandGeometry = new THREE.CylinderGeometry(0.16, 0.16, 0.1, segments);
                const bandMaterial = new THREE.MeshLambertMaterial({ color: 0xc0c0c0 });
                const band = new THREE.Mesh(bandGeometry, bandMaterial);
                band.rotation.z = Math.PI / 2;
                band.position.x = 0.3;
                group.add(band);

                this.addLeads(group);
            }

            createBJTMesh(group) {
                const segments = isMobile ? 6 : 8;
                // BJT body (TO-92 package)
                const bodyGeometry = new THREE.CylinderGeometry(0.3, 0.3, 0.4, segments, 1, false, 0, Math.PI);
                const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0x1a1a1a });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.rotation.x = Math.PI / 2;
                body.position.y = 0.2;
                group.add(body);

                // Three leads (Collector, Base, Emitter)
                const leadGeometry = new THREE.CylinderGeometry(0.03, 0.03, 0.6, 4);
                const leadMaterial = new THREE.MeshLambertMaterial({ color: 0x888888 });

                for (let i = 0; i < 3; i++) {
                    const lead = new THREE.Mesh(leadGeometry, leadMaterial);
                    lead.position.set(-0.2 + i * 0.2, -0.3, 0);
                    group.add(lead);
                }
            }

            createMOSFETMesh(group) {
                // MOSFET body (TO-220 package)
                const bodyGeometry = new THREE.BoxGeometry(0.6, 0.5, 0.2);
                const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0x1a1a1a });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.y = 0.3;
                group.add(body);

                // Heat sink tab
                const tabGeometry = new THREE.BoxGeometry(0.65, 0.2, 0.02);
                const tabMaterial = new THREE.MeshLambertMaterial({ color: 0x8c8c8c });
                const tab = new THREE.Mesh(tabGeometry, tabMaterial);
                tab.position.set(0, 0.6, 0.11);
                group.add(tab);

                // Three leads (Gate, Drain, Source)
                const leadGeometry = new THREE.BoxGeometry(0.05, 0.5, 0.05);
                const leadMaterial = new THREE.MeshLambertMaterial({ color: 0x888888 });

                for (let i = 0; i < 3; i++) {
                    const lead = new THREE.Mesh(leadGeometry, leadMaterial);
                    lead.position.set(-0.2 + i * 0.2, -0.2, 0);
                    group.add(lead);
                }
            }

            createFuseMesh(group) {
                const segments = isMobile ? 6 : 8;
                // Fuse glass body
                const bodyGeometry = new THREE.CylinderGeometry(0.12, 0.12, 0.8, segments);
                const bodyMaterial = new THREE.MeshLambertMaterial({
                    color: 0xcccccc,
                    transparent: true,
                    opacity: 0.6
                });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.rotation.z = Math.PI / 2;
                group.add(body);

                // End caps
                const capGeometry = new THREE.CylinderGeometry(0.12, 0.12, 0.1, segments);
                const capMaterial = new THREE.MeshLambertMaterial({ color: 0x888888 });

                const leftCap = new THREE.Mesh(capGeometry, capMaterial);
                leftCap.rotation.z = Math.PI / 2;
                leftCap.position.x = -0.4;
                group.add(leftCap);

                const rightCap = new THREE.Mesh(capGeometry, capMaterial);
                rightCap.rotation.z = Math.PI / 2;
                rightCap.position.x = 0.4;
                group.add(rightCap);

                this.addLeads(group);
            }

            createPotentiometerMesh(group) {
                const segments = isMobile ? 6 : 8;
                // Potentiometer body
                const bodyGeometry = new THREE.CylinderGeometry(0.3, 0.3, 0.2, segments);
                const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0x4444aa });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                group.add(body);

                // Adjustment knob
                const knobGeometry = new THREE.CylinderGeometry(0.15, 0.15, 0.15, segments);
                const knobMaterial = new THREE.MeshLambertMaterial({ color: 0x222222 });
                const knob = new THREE.Mesh(knobGeometry, knobMaterial);
                knob.position.y = 0.25;
                group.add(knob);

                // Three terminals
                const terminalGeometry = new THREE.CylinderGeometry(0.03, 0.03, 0.4, 4);
                const terminalMaterial = new THREE.MeshLambertMaterial({ color: 0x888888 });

                for (let i = 0; i < 3; i++) {
                    const terminal = new THREE.Mesh(terminalGeometry, terminalMaterial);
                    terminal.position.set(-0.15 + i * 0.15, -0.3, 0);
                    group.add(terminal);
                }
            }

            createLampMesh(group) {
                const segments = isMobile ? 8 : 12;
                // Lamp bulb (sphere)
                const bulbGeometry = new THREE.SphereGeometry(0.3, segments, segments);
                const bulbMaterial = new THREE.MeshLambertMaterial({
                    color: 0xffdd44,
                    transparent: true,
                    opacity: 0.7
                });
                const bulb = new THREE.Mesh(bulbGeometry, bulbMaterial);
                bulb.position.y = 0.2;
                group.add(bulb);

                // Lamp base
                const baseGeometry = new THREE.CylinderGeometry(0.2, 0.15, 0.3, segments);
                const baseMaterial = new THREE.MeshLambertMaterial({ color: 0x888888 });
                const base = new THREE.Mesh(baseGeometry, baseMaterial);
                base.position.y = -0.15;
                group.add(base);

                this.addLeads(group);
            }

            createGroundMesh(group) {
                // Ground symbol - three horizontal lines
                const lineMaterial = new THREE.MeshLambertMaterial({ color: 0x666666 });

                // Top line (longest)
                const line1Geometry = new THREE.BoxGeometry(0.6, 0.05, 0.05);
                const line1 = new THREE.Mesh(line1Geometry, lineMaterial);
                line1.position.y = 0;
                group.add(line1);

                // Middle line
                const line2Geometry = new THREE.BoxGeometry(0.4, 0.05, 0.05);
                const line2 = new THREE.Mesh(line2Geometry, lineMaterial);
                line2.position.y = -0.15;
                group.add(line2);

                // Bottom line (shortest)
                const line3Geometry = new THREE.BoxGeometry(0.2, 0.05, 0.05);
                const line3 = new THREE.Mesh(line3Geometry, lineMaterial);
                line3.position.y = -0.3;
                group.add(line3);

                // Connection point at top
                const connectionGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.3, 6);
                const connection = new THREE.Mesh(connectionGeometry, lineMaterial);
                connection.position.y = 0.15;
                group.add(connection);
            }

            // AC Source - sine wave symbol inside a circle
            createACSourceMesh(group) {
                const segments = isMobile ? 16 : 24;

                // Outer circle (source symbol)
                const ringGeometry = new THREE.TorusGeometry(0.4, 0.05, 8, segments);
                const ringMaterial = new THREE.MeshLambertMaterial({ color: 0xff8844 });
                const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                ring.rotation.x = Math.PI / 2;
                group.add(ring);

                // Sine wave inside - create using a tube along a sine path
                const sinePoints = [];
                for (let i = 0; i <= 20; i++) {
                    const t = (i / 20) * Math.PI * 2;
                    const x = (i / 20 - 0.5) * 0.5;
                    const y = Math.sin(t) * 0.12;
                    sinePoints.push(new THREE.Vector3(x, y, 0));
                }
                const sineCurve = new THREE.CatmullRomCurve3(sinePoints);
                const sineGeometry = new THREE.TubeGeometry(sineCurve, 20, 0.02, 6, false);
                const sineMaterial = new THREE.MeshLambertMaterial({ color: 0xffaa00 });
                const sineWave = new THREE.Mesh(sineGeometry, sineMaterial);
                group.add(sineWave);

                this.addLeads(group);
            }

            // Motor - cylindrical body with shaft
            createMotorMesh(group) {
                const segments = isMobile ? 8 : 12;

                // Motor body (cylinder)
                const bodyGeometry = new THREE.CylinderGeometry(0.35, 0.35, 0.6, segments);
                const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0x4466aa });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.rotation.z = Math.PI / 2;
                group.add(body);

                // Motor end cap
                const capGeometry = new THREE.CylinderGeometry(0.36, 0.36, 0.05, segments);
                const capMaterial = new THREE.MeshLambertMaterial({ color: 0x333333 });
                const cap = new THREE.Mesh(capGeometry, capMaterial);
                cap.rotation.z = Math.PI / 2;
                cap.position.x = 0.32;
                group.add(cap);

                // Motor shaft
                const shaftGeometry = new THREE.CylinderGeometry(0.06, 0.06, 0.4, segments);
                const shaftMaterial = new THREE.MeshLambertMaterial({ color: 0x888888 });
                const shaft = new THREE.Mesh(shaftGeometry, shaftMaterial);
                shaft.rotation.z = Math.PI / 2;
                shaft.position.x = 0.5;
                group.add(shaft);

                // "M" label on body
                const labelGeometry = new THREE.BoxGeometry(0.15, 0.02, 0.2);
                const labelMaterial = new THREE.MeshLambertMaterial({ color: 0xffffff });
                const label = new THREE.Mesh(labelGeometry, labelMaterial);
                label.position.y = 0.36;
                group.add(label);

                this.addLeads(group);
            }

            // Speaker - cone shape with magnet base
            createSpeakerMesh(group) {
                const segments = isMobile ? 8 : 12;

                // Speaker cone (truncated cone)
                const coneGeometry = new THREE.CylinderGeometry(0.15, 0.4, 0.3, segments, 1, true);
                const coneMaterial = new THREE.MeshLambertMaterial({
                    color: 0x666666,
                    side: THREE.DoubleSide
                });
                const cone = new THREE.Mesh(coneGeometry, coneMaterial);
                cone.position.y = 0.15;
                group.add(cone);

                // Magnet base
                const magnetGeometry = new THREE.CylinderGeometry(0.25, 0.25, 0.15, segments);
                const magnetMaterial = new THREE.MeshLambertMaterial({ color: 0x333333 });
                const magnet = new THREE.Mesh(magnetGeometry, magnetMaterial);
                magnet.position.y = -0.08;
                group.add(magnet);

                // Dust cap (center dome)
                const capGeometry = new THREE.SphereGeometry(0.08, segments, segments, 0, Math.PI * 2, 0, Math.PI / 2);
                const capMaterial = new THREE.MeshLambertMaterial({ color: 0x444444 });
                const cap = new THREE.Mesh(capGeometry, capMaterial);
                cap.position.y = 0.3;
                group.add(cap);

                this.addLeads(group);
            }

            // Op-Amp - triangular amplifier symbol
            createOpAmpMesh(group) {
                // Triangle body
                const shape = new THREE.Shape();
                shape.moveTo(-0.4, -0.35);
                shape.lineTo(-0.4, 0.35);
                shape.lineTo(0.5, 0);
                shape.lineTo(-0.4, -0.35);

                const extrudeSettings = { depth: 0.15, bevelEnabled: false };
                const triangleGeometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
                const triangleMaterial = new THREE.MeshLambertMaterial({ color: 0x44aa44 });
                const triangle = new THREE.Mesh(triangleGeometry, triangleMaterial);
                triangle.position.z = -0.075;
                group.add(triangle);

                // + input marker (inverting input at top)
                const plusHGeometry = new THREE.BoxGeometry(0.1, 0.02, 0.02);
                const plusMaterial = new THREE.MeshLambertMaterial({ color: 0xffffff });
                const plusH = new THREE.Mesh(plusHGeometry, plusMaterial);
                plusH.position.set(-0.3, 0.15, 0.08);
                group.add(plusH);

                // - input marker (non-inverting input at bottom)
                const minusGeometry = new THREE.BoxGeometry(0.1, 0.02, 0.02);
                const minus = new THREE.Mesh(minusGeometry, plusMaterial);
                minus.position.set(-0.3, -0.15, 0.08);
                group.add(minus);

                this.addLeads(group);
            }

            // Transformer - two coils with core
            createTransformerMesh(group) {
                const segments = isMobile ? 6 : 8;

                // Core (E-shaped laminations represented as box)
                const coreGeometry = new THREE.BoxGeometry(0.15, 0.8, 0.3);
                const coreMaterial = new THREE.MeshLambertMaterial({ color: 0x444444 });
                const core = new THREE.Mesh(coreGeometry, coreMaterial);
                group.add(core);

                // Primary coil (left side)
                const coilGeometry = new THREE.TorusGeometry(0.2, 0.06, 8, segments);
                const primaryMaterial = new THREE.MeshLambertMaterial({ color: 0xcc6622 });

                for (let i = 0; i < 3; i++) {
                    const coil = new THREE.Mesh(coilGeometry, primaryMaterial);
                    coil.position.set(-0.25, 0.25 - i * 0.25, 0);
                    group.add(coil);
                }

                // Secondary coil (right side)
                const secondaryMaterial = new THREE.MeshLambertMaterial({ color: 0x22cc66 });

                for (let i = 0; i < 3; i++) {
                    const coil = new THREE.Mesh(coilGeometry, secondaryMaterial);
                    coil.position.set(0.25, 0.25 - i * 0.25, 0);
                    group.add(coil);
                }

                this.addLeads(group);
            }

            // BJT NPN - TO-92 package with NPN marking
            createBJTNPNMesh(group) {
                const segments = isMobile ? 6 : 8;
                // BJT body (TO-92 package)
                const bodyGeometry = new THREE.CylinderGeometry(0.3, 0.3, 0.4, segments, 1, false, 0, Math.PI);
                const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0x1a1a1a });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.rotation.x = Math.PI / 2;
                body.position.y = 0.2;
                group.add(body);

                // NPN indicator stripe
                const stripeGeometry = new THREE.BoxGeometry(0.32, 0.05, 0.02);
                const stripeMaterial = new THREE.MeshLambertMaterial({ color: 0xff4444 });
                const stripe = new THREE.Mesh(stripeGeometry, stripeMaterial);
                stripe.position.set(0, 0.35, 0.15);
                group.add(stripe);

                // Three leads (Collector, Base, Emitter)
                const leadGeometry = new THREE.CylinderGeometry(0.03, 0.03, 0.6, 4);
                const leadMaterial = new THREE.MeshLambertMaterial({ color: 0x888888 });

                for (let i = 0; i < 3; i++) {
                    const lead = new THREE.Mesh(leadGeometry, leadMaterial);
                    lead.position.set(-0.2 + i * 0.2, -0.3, 0);
                    group.add(lead);
                }
            }

            // BJT PNP - TO-92 package with PNP marking
            createBJTPNPMesh(group) {
                const segments = isMobile ? 6 : 8;
                // BJT body (TO-92 package)
                const bodyGeometry = new THREE.CylinderGeometry(0.3, 0.3, 0.4, segments, 1, false, 0, Math.PI);
                const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0x1a1a1a });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.rotation.x = Math.PI / 2;
                body.position.y = 0.2;
                group.add(body);

                // PNP indicator stripe (blue)
                const stripeGeometry = new THREE.BoxGeometry(0.32, 0.05, 0.02);
                const stripeMaterial = new THREE.MeshLambertMaterial({ color: 0x4444ff });
                const stripe = new THREE.Mesh(stripeGeometry, stripeMaterial);
                stripe.position.set(0, 0.35, 0.15);
                group.add(stripe);

                // Three leads (Emitter, Base, Collector)
                const leadGeometry = new THREE.CylinderGeometry(0.03, 0.03, 0.6, 4);
                const leadMaterial = new THREE.MeshLambertMaterial({ color: 0x888888 });

                for (let i = 0; i < 3; i++) {
                    const lead = new THREE.Mesh(leadGeometry, leadMaterial);
                    lead.position.set(-0.2 + i * 0.2, -0.3, 0);
                    group.add(lead);
                }
            }

            // Darlington Pair - larger package with two transistors
            createDarlingtonMesh(group) {
                const segments = isMobile ? 6 : 8;

                // Larger TO-220 style package
                const bodyGeometry = new THREE.BoxGeometry(0.7, 0.5, 0.25);
                const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0x1a1a1a });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.y = 0.3;
                group.add(body);

                // Heat sink tab
                const tabGeometry = new THREE.BoxGeometry(0.75, 0.25, 0.03);
                const tabMaterial = new THREE.MeshLambertMaterial({ color: 0x8c8c8c });
                const tab = new THREE.Mesh(tabGeometry, tabMaterial);
                tab.position.set(0, 0.6, 0.14);
                group.add(tab);

                // Mounting hole in tab
                const holeGeometry = new THREE.TorusGeometry(0.06, 0.02, 6, segments);
                const holeMaterial = new THREE.MeshLambertMaterial({ color: 0x666666 });
                const hole = new THREE.Mesh(holeGeometry, holeMaterial);
                hole.position.set(0, 0.6, 0.16);
                group.add(hole);

                // DRL label indicator
                const labelGeometry = new THREE.BoxGeometry(0.25, 0.08, 0.02);
                const labelMaterial = new THREE.MeshLambertMaterial({ color: 0xcc44cc });
                const label = new THREE.Mesh(labelGeometry, labelMaterial);
                label.position.set(0, 0.35, 0.14);
                group.add(label);

                // Three leads
                const leadGeometry = new THREE.BoxGeometry(0.05, 0.5, 0.05);
                const leadMaterial = new THREE.MeshLambertMaterial({ color: 0x888888 });

                for (let i = 0; i < 3; i++) {
                    const lead = new THREE.Mesh(leadGeometry, leadMaterial);
                    lead.position.set(-0.25 + i * 0.25, -0.2, 0);
                    group.add(lead);
                }
            }

            createConnectionPoints() {
                this.connectionPoints = [];

                const pointGeometry = new THREE.SphereGeometry(0.3, isMobile ? 16 : 20, isMobile ? 12 : 16);
                const leftPos = new THREE.Vector3(-1.2, 0, 0);
                const rightPos = new THREE.Vector3(1.2, 0, 0);
                const centerPos = new THREE.Vector3(0, 0, 0);

                if (this.type === 'battery') {
                    // Red positive terminal
                    const positiveMaterial = new THREE.MeshPhongMaterial({
                        color: 0xff0000,
                        emissive: 0x330000,
                        shininess: 200
                    });
                    const positivePoint = new THREE.Mesh(pointGeometry, positiveMaterial);
                    positivePoint.position.copy(rightPos);
                    positivePoint.userData = {
                        component: this,
                        isConnectionPoint: true,
                        side: 'positive',
                        polarity: 'positive'
                    };
                    this.mesh.add(positivePoint);
                    this.connectionPoints.push(positivePoint);

                    // Gray negative terminal
                    const negativeMaterial = new THREE.MeshPhongMaterial({
                        color: 0x333333,
                        emissive: 0x111111,
                        shininess: 200
                    });
                    const negativePoint = new THREE.Mesh(pointGeometry, negativeMaterial);
                    negativePoint.position.copy(leftPos);
                    negativePoint.userData = {
                        component: this,
                        isConnectionPoint: true,
                        side: 'negative',
                        polarity: 'negative'
                    };
                    this.mesh.add(negativePoint);
                    this.connectionPoints.push(negativePoint);

                } else if (this.type === 'bjt') {
                    // BJT has 3 terminals: Collector (left), Base (center), Emitter (right)
                    const neutralMaterial = new THREE.MeshPhongMaterial({
                        color: 0xffffff,
                        emissive: 0x222222,
                        shininess: 200
                    });

                    // Collector (left, -0.2 x offset matching lead positions)
                    const collectorPoint = new THREE.Mesh(pointGeometry, neutralMaterial.clone());
                    collectorPoint.position.set(-0.2, -0.6, 0);
                    collectorPoint.userData = {
                        component: this,
                        isConnectionPoint: true,
                        side: 'collector',
                        polarity: 'neutral'
                    };
                    this.mesh.add(collectorPoint);
                    this.connectionPoints.push(collectorPoint);

                    // Base (center)
                    const basePoint = new THREE.Mesh(pointGeometry, neutralMaterial.clone());
                    basePoint.position.set(0, -0.6, 0);
                    basePoint.userData = {
                        component: this,
                        isConnectionPoint: true,
                        side: 'base',
                        polarity: 'neutral'
                    };
                    this.mesh.add(basePoint);
                    this.connectionPoints.push(basePoint);

                    // Emitter (right)
                    const emitterPoint = new THREE.Mesh(pointGeometry, neutralMaterial.clone());
                    emitterPoint.position.set(0.2, -0.6, 0);
                    emitterPoint.userData = {
                        component: this,
                        isConnectionPoint: true,
                        side: 'emitter',
                        polarity: 'neutral'
                    };
                    this.mesh.add(emitterPoint);
                    this.connectionPoints.push(emitterPoint);

                } else if (this.type === 'mosfet') {
                    // MOSFET has 3 terminals: Gate (left), Drain (center), Source (right)
                    const neutralMaterial = new THREE.MeshPhongMaterial({
                        color: 0xffffff,
                        emissive: 0x222222,
                        shininess: 200
                    });

                    // Gate (left)
                    const gatePoint = new THREE.Mesh(pointGeometry, neutralMaterial.clone());
                    gatePoint.position.set(-0.2, -0.7, 0);
                    gatePoint.userData = {
                        component: this,
                        isConnectionPoint: true,
                        side: 'gate',
                        polarity: 'neutral'
                    };
                    this.mesh.add(gatePoint);
                    this.connectionPoints.push(gatePoint);

                    // Drain (center)
                    const drainPoint = new THREE.Mesh(pointGeometry, neutralMaterial.clone());
                    drainPoint.position.set(0, -0.7, 0);
                    drainPoint.userData = {
                        component: this,
                        isConnectionPoint: true,
                        side: 'drain',
                        polarity: 'neutral'
                    };
                    this.mesh.add(drainPoint);
                    this.connectionPoints.push(drainPoint);

                    // Source (right)
                    const sourcePoint = new THREE.Mesh(pointGeometry, neutralMaterial.clone());
                    sourcePoint.position.set(0.2, -0.7, 0);
                    sourcePoint.userData = {
                        component: this,
                        isConnectionPoint: true,
                        side: 'source',
                        polarity: 'neutral'
                    };
                    this.mesh.add(sourcePoint);
                    this.connectionPoints.push(sourcePoint);

                } else if (this.type === 'potentiometer') {
                    // Potentiometer has 3 terminals: Terminal 1 (left), Wiper (center), Terminal 2 (right)
                    const neutralMaterial = new THREE.MeshPhongMaterial({
                        color: 0xffffff,
                        emissive: 0x222222,
                        shininess: 200
                    });

                    // Terminal 1 (left)
                    const terminal1Point = new THREE.Mesh(pointGeometry, neutralMaterial.clone());
                    terminal1Point.position.set(-0.15, -0.7, 0);
                    terminal1Point.userData = {
                        component: this,
                        isConnectionPoint: true,
                        side: 'terminal1',
                        polarity: 'neutral'
                    };
                    this.mesh.add(terminal1Point);
                    this.connectionPoints.push(terminal1Point);

                    // Wiper (center)
                    const wiperPoint = new THREE.Mesh(pointGeometry, neutralMaterial.clone());
                    wiperPoint.position.set(0, -0.7, 0);
                    wiperPoint.userData = {
                        component: this,
                        isConnectionPoint: true,
                        side: 'wiper',
                        polarity: 'neutral'
                    };
                    this.mesh.add(wiperPoint);
                    this.connectionPoints.push(wiperPoint);

                    // Terminal 2 (right)
                    const terminal2Point = new THREE.Mesh(pointGeometry, neutralMaterial.clone());
                    terminal2Point.position.set(0.15, -0.7, 0);
                    terminal2Point.userData = {
                        component: this,
                        isConnectionPoint: true,
                        side: 'terminal2',
                        polarity: 'neutral'
                    };
                    this.mesh.add(terminal2Point);
                    this.connectionPoints.push(terminal2Point);

                } else if (this.type === 'ground') {
                    // Ground has only 1 connection point at the top
                    const neutralMaterial = new THREE.MeshPhongMaterial({
                        color: 0xffffff,
                        emissive: 0x222222,
                        shininess: 200
                    });

                    const groundPoint = new THREE.Mesh(pointGeometry, neutralMaterial);
                    groundPoint.position.set(0, 0.45, 0); // At the top of the ground symbol
                    groundPoint.userData = {
                        component: this,
                        isConnectionPoint: true,
                        side: 'top',
                        polarity: 'neutral'
                    };
                    this.mesh.add(groundPoint);
                    this.connectionPoints.push(groundPoint);

                } else if (this.type === 'bjt-npn' || this.type === 'bjt-pnp') {
                    // NPN/PNP BJTs have 3 terminals like regular BJT
                    const neutralMaterial = new THREE.MeshPhongMaterial({
                        color: 0xffffff,
                        emissive: 0x222222,
                        shininess: 200
                    });

                    // Collector (left)
                    const collectorPoint = new THREE.Mesh(pointGeometry, neutralMaterial.clone());
                    collectorPoint.position.set(-0.2, -0.6, 0);
                    collectorPoint.userData = {
                        component: this,
                        isConnectionPoint: true,
                        side: 'collector',
                        polarity: 'neutral'
                    };
                    this.mesh.add(collectorPoint);
                    this.connectionPoints.push(collectorPoint);

                    // Base (center)
                    const basePoint = new THREE.Mesh(pointGeometry, neutralMaterial.clone());
                    basePoint.position.set(0, -0.6, 0);
                    basePoint.userData = {
                        component: this,
                        isConnectionPoint: true,
                        side: 'base',
                        polarity: 'neutral'
                    };
                    this.mesh.add(basePoint);
                    this.connectionPoints.push(basePoint);

                    // Emitter (right)
                    const emitterPoint = new THREE.Mesh(pointGeometry, neutralMaterial.clone());
                    emitterPoint.position.set(0.2, -0.6, 0);
                    emitterPoint.userData = {
                        component: this,
                        isConnectionPoint: true,
                        side: 'emitter',
                        polarity: 'neutral'
                    };
                    this.mesh.add(emitterPoint);
                    this.connectionPoints.push(emitterPoint);

                } else if (this.type === 'darlington') {
                    // Darlington has 3 terminals like BJT/MOSFET
                    const neutralMaterial = new THREE.MeshPhongMaterial({
                        color: 0xffffff,
                        emissive: 0x222222,
                        shininess: 200
                    });

                    // Collector (left)
                    const collectorPoint = new THREE.Mesh(pointGeometry, neutralMaterial.clone());
                    collectorPoint.position.set(-0.25, -0.7, 0);
                    collectorPoint.userData = {
                        component: this,
                        isConnectionPoint: true,
                        side: 'collector',
                        polarity: 'neutral'
                    };
                    this.mesh.add(collectorPoint);
                    this.connectionPoints.push(collectorPoint);

                    // Base (center)
                    const basePoint = new THREE.Mesh(pointGeometry, neutralMaterial.clone());
                    basePoint.position.set(0, -0.7, 0);
                    basePoint.userData = {
                        component: this,
                        isConnectionPoint: true,
                        side: 'base',
                        polarity: 'neutral'
                    };
                    this.mesh.add(basePoint);
                    this.connectionPoints.push(basePoint);

                    // Emitter (right)
                    const emitterPoint = new THREE.Mesh(pointGeometry, neutralMaterial.clone());
                    emitterPoint.position.set(0.25, -0.7, 0);
                    emitterPoint.userData = {
                        component: this,
                        isConnectionPoint: true,
                        side: 'emitter',
                        polarity: 'neutral'
                    };
                    this.mesh.add(emitterPoint);
                    this.connectionPoints.push(emitterPoint);

                } else if (this.type === 'ac_source') {
                    // AC Source has + and - terminals like battery
                    const positiveMaterial = new THREE.MeshPhongMaterial({
                        color: 0xff8844,
                        emissive: 0x331100,
                        shininess: 200
                    });
                    const positivePoint = new THREE.Mesh(pointGeometry, positiveMaterial);
                    positivePoint.position.copy(rightPos);
                    positivePoint.userData = {
                        component: this,
                        isConnectionPoint: true,
                        side: 'positive',
                        polarity: 'positive'
                    };
                    this.mesh.add(positivePoint);
                    this.connectionPoints.push(positivePoint);

                    const negativeMaterial = new THREE.MeshPhongMaterial({
                        color: 0x333333,
                        emissive: 0x111111,
                        shininess: 200
                    });
                    const negativePoint = new THREE.Mesh(pointGeometry, negativeMaterial);
                    negativePoint.position.copy(leftPos);
                    negativePoint.userData = {
                        component: this,
                        isConnectionPoint: true,
                        side: 'negative',
                        polarity: 'negative'
                    };
                    this.mesh.add(negativePoint);
                    this.connectionPoints.push(negativePoint);

                } else {
                    // White neutral terminals for 2-terminal components
                    const neutralMaterial = new THREE.MeshPhongMaterial({
                        color: 0xffffff,
                        emissive: 0x222222,
                        shininess: 200
                    });

                    const leftPoint = new THREE.Mesh(pointGeometry, neutralMaterial.clone());
                    leftPoint.position.copy(leftPos);
                    leftPoint.userData = {
                        component: this,
                        isConnectionPoint: true,
                        side: 'left',
                        polarity: 'neutral'
                    };
                    this.mesh.add(leftPoint);
                    this.connectionPoints.push(leftPoint);

                    const rightPoint = new THREE.Mesh(pointGeometry, neutralMaterial.clone());
                    rightPoint.position.copy(rightPos);
                    rightPoint.userData = {
                        component: this,
                        isConnectionPoint: true,
                        side: 'right',
                        polarity: 'neutral'
                    };
                    this.mesh.add(rightPoint);
                    this.connectionPoints.push(rightPoint);
                }

                // Create polarity indicator labels
                this.createPolarityIndicators();
            }
            
            createPolarityIndicators() {
                this.polarityDivs = [];
                
                if (this.type === 'battery') {
                    // Create + indicator for positive terminal
                    const positiveDiv = document.createElement('div');
                    positiveDiv.className = 'polarity-indicator polarity-positive';
                    positiveDiv.textContent = '+';
                    positiveDiv.style.display = showPolarityIndicators ? 'block' : 'none';
                    document.body.appendChild(positiveDiv);
                    this.polarityDivs.push({ div: positiveDiv, side: 'positive' });
                    
                    // Create - indicator for negative terminal
                    const negativeDiv = document.createElement('div');
                    negativeDiv.className = 'polarity-indicator polarity-negative';
                    negativeDiv.textContent = '';
                    negativeDiv.style.display = showPolarityIndicators ? 'block' : 'none';
                    document.body.appendChild(negativeDiv);
                    this.polarityDivs.push({ div: negativeDiv, side: 'negative' });
                }
            }
            
            updatePolarityDisplay(show) {
                if (this.polarityDivs) {
                    this.polarityDivs.forEach(item => {
                        item.div.style.display = show ? 'block' : 'none';
                    });
                }
            }
            
            updatePolarityPositions() {
                // Skip expensive calculations if indicators are hidden
                if (!showPolarityIndicators || !this.polarityDivs || !this.mesh) return;

                this.polarityDivs.forEach(item => {
                    // Find the connection point for this terminal to get its rotated position
                    const connectionPoint = this.connectionPoints?.find(
                        cp => cp.userData?.side === item.side
                    );

                    const worldPos = new THREE.Vector3();

                    if (connectionPoint) {
                        // Get the world position of the actual terminal connection point
                        // This automatically accounts for component rotation
                        connectionPoint.getWorldPosition(worldPos);
                    } else {
                        // Fallback to mesh position with fixed offsets (for backwards compatibility)
                        worldPos.setFromMatrixPosition(this.mesh.matrixWorld);
                        if (item.side === 'positive') {
                            worldPos.x += 1.2;
                        } else if (item.side === 'negative') {
                            worldPos.x -= 1.2;
                        }
                    }

                    // Offset marker slightly above the terminal
                    worldPos.y += 0.8;

                    const screenPos = worldToScreen(worldPos);

                    item.div.style.left = screenPos.x + 'px';
                    item.div.style.top = screenPos.y + 'px';
                });
            }

            getWorldConnectionPoint(side) {
                // Return exact terminal positions WITHOUT grid snapping to prevent gaps.
                // Wires must connect precisely to component terminals.
                const targetPoint = this.connectionPoints?.find(point =>
                    point.userData?.side === side
                );

                if (targetPoint) {
                    const worldPosition = new THREE.Vector3();
                    targetPoint.getWorldPosition(worldPosition);
                    return worldPosition;
                }

                const offset = (side === 'positive' || side === 'right') ? 1.2 : -1.2;
                return new THREE.Vector3(
                    this.position.x + offset,
                    this.position.y,
                    this.position.z
                );
            }

            updateProperties(newProperties) {
                Object.assign(this.properties, newProperties);
                if (this.type === 'switch' && this.leverMesh) {
                    this.leverMesh.material.color.setHex(this.properties.isOn ? 0x00ff00 : 0xff0000);
                    this.leverMesh.rotation.z = this.properties.isOn ? 0 : Math.PI / 6;
                }
                
                // Update the labels with new values
                this.updateLabels();
            }

            remove() {
                if (this.mesh) {
                    scene.remove(this.mesh);
                }
                
                if (this.labelDiv) {
                    document.body.removeChild(this.labelDiv);
                }
                
                // Remove polarity indicators
                if (this.polarityDivs) {
                    this.polarityDivs.forEach(item => {
                        if (item.div && item.div.parentNode) {
                            document.body.removeChild(item.div);
                        }
                    });
                    this.polarityDivs = null; // Clear to prevent memory leaks
                }
                
                const connectedWires = [...this.connections];
                connectedWires.forEach(connection => {
                    if (connection.wire) {
                        connection.wire.remove();
                    }
                });
                
                const index = components.indexOf(this);
                if (index > -1) {
                    components.splice(index, 1);
                }
                
                // Reset component counter if this was the last one
                this.updateComponentCounters();
            }

            updateComponentCounters() {
                // Recalculate component numbers to avoid gaps
                const typeComponents = components.filter(comp => comp.type === this.type);
                typeComponents.forEach((comp, index) => {
                    comp.componentNumber = index + 1;
                    comp.updateLabels();
                });
                componentCounters[this.type] = typeComponents.length;
            }
        }

        // Wire class
        class Wire {
            constructor(startObj, startSide, endObj, endSide) {
                this.startObj = startObj;
                this.startSide = startSide;
                this.endObj = endObj;
                this.endSide = endSide;
                this.id = 'wire_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                this.segments = [];
                
                this.createMesh();
                this.createCurve();
                this.addToConnections();
            }

            createMesh() {
                const startPos = this.getStartPosition();
                const endPos = this.getEndPosition();
                
                const distance = startPos.distanceTo(endPos);
                if (distance < 0.1) {
                    throw new Error('Wire too short');
                }
                
                // Create right-angled wire path
                const path = createRightAngledWirePath(startPos, endPos, this.startSide, this.endSide);
                this.createWireSegments(path);
            }

            createWireSegments(path) {
                this.wireGroup = new THREE.Group();
                this.segments = [];
                
                for (let i = 0; i < path.length - 1; i++) {
                    const segmentStart = path[i];
                    const segmentEnd = path[i + 1];
                    const distance = segmentStart.distanceTo(segmentEnd);
                    
                    if (distance > 0.1) {
                        const wireGeometry = new THREE.CylinderGeometry(0.08, 0.08, distance, isMobile ? 8 : 12);
                        
                        const material = new THREE.MeshPhongMaterial({ 
                            color: 0xd2691e,
                            shininess: 150,
                            transparent: true,
                            opacity: 0.9
                        });
                        
                        const segment = new THREE.Mesh(wireGeometry, material);
                        
                        // Position segment at midpoint
                        const midPoint = new THREE.Vector3().addVectors(segmentStart, segmentEnd).multiplyScalar(0.5);
                        segment.position.copy(midPoint);
                        
                        // Rotate segment to connect the points
                        const direction = new THREE.Vector3().subVectors(segmentEnd, segmentStart).normalize();
                        const up = new THREE.Vector3(0, 1, 0);
                        const quaternion = new THREE.Quaternion().setFromUnitVectors(up, direction);
                        segment.setRotationFromQuaternion(quaternion);
                        
                        this.wireGroup.add(segment);
                        this.segments.push({
                            mesh: segment,
                            start: segmentStart.clone(),
                            end: segmentEnd.clone()
                        });
                    }
                }
                
                this.wireGroup.userData = { wire: this };
                this.mesh = this.wireGroup;
                scene.add(this.wireGroup);
            }

            getStartPosition() {
                // Always use exact terminal positions to prevent gaps between wires and components.
                // Wire endpoints must connect precisely to terminals in all routing modes.
                if (this.startObj.getWorldConnectionPoint) {
                    return this.startObj.getWorldConnectionPoint(this.startSide);
                }
                return this.startObj.position.clone();
            }

            getEndPosition() {
                // Always use exact terminal positions to prevent gaps between wires and components.
                // Wire endpoints must connect precisely to terminals in all routing modes.
                if (this.endObj.getWorldConnectionPoint) {
                    return this.endObj.getWorldConnectionPoint(this.endSide);
                }
                return this.endObj.position.clone();
            }

            createCurve() {
                try {
                    const startPos = this.getStartPosition();
                    const endPos = this.getEndPosition();
                    const path = createRightAngledWirePath(startPos, endPos, this.startSide, this.endSide);
                    
                    this.curve = {
                        getPoint: (t) => {
                            t = Math.max(0, Math.min(1, t));
                            
                            let totalDistance = 0;
                            const distances = [];
                            
                            // Calculate segment distances
                            for (let i = 0; i < path.length - 1; i++) {
                                const segmentDistance = path[i].distanceTo(path[i + 1]);
                                distances.push(segmentDistance);
                                totalDistance += segmentDistance;
                            }
                            
                            // Find which segment we're on
                            const targetDistance = t * totalDistance;
                            let currentDistance = 0;
                            
                            for (let i = 0; i < distances.length; i++) {
                                if (currentDistance + distances[i] >= targetDistance) {
                                    const segmentT = (targetDistance - currentDistance) / distances[i];
                                    return new THREE.Vector3().lerpVectors(path[i], path[i + 1], segmentT);
                                }
                                currentDistance += distances[i];
                            }
                            
                            return path[path.length - 1].clone();
                        }
                    };
                } catch (error) {
                    console.error('Error creating wire curve:', error);
                    this.curve = null;
                }
            }

            updatePath() {
                if (this.wireGroup) {
                    scene.remove(this.wireGroup);
                }
                
                const startPos = this.getStartPosition();
                const endPos = this.getEndPosition();
                const path = createRightAngledWirePath(startPos, endPos, this.startSide, this.endSide);
                
                this.createWireSegments(path);
                this.createCurve();
            }

            addToConnections() {
                if (this.startObj.connections) {
                    this.startObj.connections.push({
                        wire: this,
                        connectedTo: this.endObj,
                        side: this.startSide
                    });
                }
                if (this.startObj.addConnection) {
                    this.startObj.addConnection(this);
                }
                
                if (this.endObj.connections) {
                    this.endObj.connections.push({
                        wire: this,
                        connectedTo: this.startObj,
                        side: this.endSide
                    });
                }
                if (this.endObj.addConnection) {
                    this.endObj.addConnection(this);
                }
            }

            remove() {
                if (this.wireGroup) {
                    scene.remove(this.wireGroup);
                }
                
                if (this.startObj?.connections) {
                    this.startObj.connections = this.startObj.connections.filter(
                        conn => conn.wire !== this
                    );
                }
                if (this.startObj?.removeConnection) {
                    this.startObj.removeConnection(this);
                }
                
                if (this.endObj?.connections) {
                    this.endObj.connections = this.endObj.connections.filter(
                        conn => conn.wire !== this
                    );
                }
                if (this.endObj?.removeConnection) {
                    this.endObj.removeConnection(this);
                }
                
                const index = wires.indexOf(this);
                if (index > -1) {
                    wires.splice(index, 1);
                }
            }
        }

        // Center circuit for optimal viewing
        function centerCircuit() {
            if (components.length === 0 && junctions.length === 0) {
                setStatus(' No components to center');
                return;
            }
            
            saveState(); // Save for undo
            
            // Calculate center of all components
            const allObjects = [...components, ...junctions];
            let centerX = 0, centerZ = 0;
            
            allObjects.forEach(obj => {
                centerX += obj.position.x;
                centerZ += obj.position.z;
            });
            
            centerX /= allObjects.length;
            centerZ /= allObjects.length;
            
            // Move all objects to center the circuit at origin
            const offsetX = -centerX;
            const offsetZ = -centerZ;
            
            allObjects.forEach(obj => {
                obj.position.x += offsetX;
                obj.position.z += offsetZ;
                
                // Snap to grid
                obj.position.copy(snapToGrid(obj.position));
                
                if (obj.mesh) {
                    obj.mesh.position.copy(obj.position);
                }
            });
            
            // Update all wire paths
            wires.forEach(wire => {
                if (wire.updatePath) {
                    wire.updatePath();
                }
            });
            
            // Center camera view
            cameraTarget.set(0, 0, 0);
            updateCameraPosition();
            
            setStatus(' Circuit centered and aligned to grid for professional schematic appearance');
        }

        // Initialize the scene
        function init() {
            try {
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x0a0a1a);
                
                camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                updateCameraPosition();
                
                const canvas = document.getElementById('canvas');
                renderer = new THREE.WebGLRenderer({ 
                    canvas: canvas,
                    antialias: !isMobile, // Disable antialiasing on mobile for performance
                    powerPreference: isMobile ? "low-power" : "high-performance"
                });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, isMobile ? 1.5 : 2));
                renderer.setClearColor(0x0a0a1a, 1);
                
                raycaster = new THREE.Raycaster();
                raycaster.params.Points.threshold = isMobile ? 0.8 : 0.5;
                raycaster.params.Line.threshold = isMobile ? 0.5 : 0.3;
                mouse = new THREE.Vector2();
                
                // Lighting - reduced for mobile performance
                const directionalLight = new THREE.DirectionalLight(0xffffff, isMobile ? 1.0 : 1.2);
                directionalLight.position.set(10, 10, 5);
                scene.add(directionalLight);
                
                if (!isMobile) {
                    const pointLight = new THREE.PointLight(0xffa500, 0.8, 50);
                    pointLight.position.set(5, 8, 5);
                    scene.add(pointLight);
                }
                
                const ambientLight = new THREE.AmbientLight(0x404040, isMobile ? 0.6 : 0.4);
                scene.add(ambientLight);
                
                // Enhanced grid system
                createEnhancedGrid();
                createSnapIndicator();
                
                setupEvents();
                
                // Hide main app initially - landing page shows first
                document.getElementById('loading').style.display = 'none';
                document.getElementById('menu-bar').style.display = 'none';
                document.getElementById('status').style.display = 'none';
                document.getElementById('canvas').style.display = 'none';

                requestAnimationFrame(animate);

                updateCircuitInfo();

                // Prevent context menu on long press
                document.addEventListener('contextmenu', function(e) {
                    e.preventDefault();
                    return false;
                });

                // Prevent zoom on double tap
                let lastTouchEnd = 0;
                document.addEventListener('touchend', function (event) {
                    const now = (new Date()).getTime();
                    if (now - lastTouchEnd <= 300) {
                        event.preventDefault();
                    }
                    lastTouchEnd = now;
                }, false);

                notifyParentReady();
                notifyParentAnalysisState();
                notifyParentToolState('select');

            } catch (error) {
                console.error('Initialization error:', error);
                document.getElementById('loading').textContent = 'Error loading. Please refresh.';
            }
        }

        // Track frame timing for performance optimization
        let lastFrameTime = 0;
        const TARGET_FRAME_INTERVAL = 1000 / 60; // Target 60fps
        let labelUpdateCounter = 0;
        const LABEL_UPDATE_INTERVAL = 3; // Update labels every 3 frames to reduce overhead

        function animate(currentTime) {
            requestAnimationFrame(animate);

            // Handle first call where currentTime might be undefined
            if (!currentTime) currentTime = performance.now();

            // Throttle to target FPS to reduce CPU/GPU load on slower devices
            const elapsed = currentTime - lastFrameTime;
            if (elapsed < TARGET_FRAME_INTERVAL * 0.9) {
                return; // Skip frame if we're running faster than target
            }
            lastFrameTime = currentTime;

            updateFlowParticles();

            // Only update labels every few frames to reduce DOM manipulation overhead
            labelUpdateCounter++;
            if (labelUpdateCounter >= LABEL_UPDATE_INTERVAL) {
                labelUpdateCounter = 0;
                updateComponentLabels();
            }

            if (renderer) {
                renderer.render(scene, camera);
            }
        }

        function updateComponentLabels() {
            // Update all component label positions
            // Cache the length to avoid re-evaluation each iteration
            const componentCount = components.length;
            for (let i = 0; i < componentCount; i++) {
                const component = components[i];
                if (component.updateLabelPosition) {
                    component.updateLabelPosition();
                }
                // Update polarity indicator positions only if indicators are visible
                if (showPolarityIndicators && component.updatePolarityPositions) {
                    component.updatePolarityPositions();
                }
            }
        }

        function updateFlowParticles() {
            // Iterate backwards when removing items to avoid index issues
            for (let i = currentFlowParticles.length - 1; i >= 0; i--) {
                const particle = currentFlowParticles[i];
                try {
                    if (!particle?.userData?.wire || !particle.userData.isFlowing) {
                        scene.remove(particle);
                        currentFlowParticles.splice(i, 1);
                        continue;
                    }

                    const wireData = particle.userData;
                    const wire = wireData.wire;

                    if (!wire || !wire.curve) {
                        scene.remove(particle);
                        currentFlowParticles.splice(i, 1);
                        continue;
                    }

                    const step = (wireData.speed || 0.01) * (wireData.direction || 1);
                    wireData.progress += step;

                    if (wireData.progress > 1) {
                        wireData.progress -= 1;
                    } else if (wireData.progress < 0) {
                        wireData.progress += 1;
                    }

                    const position = wire.curve.getPoint(wireData.progress);
                    if (position && position.isVector3) {
                        particle.position.copy(position);
                    }

                } catch (error) {
                    console.error(`Error updating particle ${i}:`, error);
                    scene.remove(particle);
                    currentFlowParticles.splice(i, 1);
                }
            }
        }

        function updateCameraPosition() {
            const x = cameraDistance * Math.cos(cameraAngleY) * Math.cos(cameraAngleX);
            const y = cameraDistance * Math.sin(cameraAngleY);
            const z = cameraDistance * Math.cos(cameraAngleY) * Math.sin(cameraAngleX);
            
            camera.position.set(
                cameraTarget.x + x, 
                cameraTarget.y + y, 
                cameraTarget.z + z
            );
            camera.lookAt(cameraTarget);
        }

        function applyCameraPan(deltaX, deltaY, multiplier = 1) {
            if ((deltaX === 0 && deltaY === 0) || Number.isNaN(deltaX) || Number.isNaN(deltaY)) {
                return;
            }

            camera.getWorldDirection(cameraDirectionVec);
            cameraRightVec.crossVectors(cameraDirectionVec, worldUpVector).normalize();

            if (cameraRightVec.lengthSq() === 0) {
                cameraRightVec.set(1, 0, 0);
            }

            cameraUpVec.crossVectors(cameraRightVec, cameraDirectionVec).normalize();

            const panFactor = cameraDistance * PAN_SENSITIVITY_BASE * multiplier;
            cameraTarget.addScaledVector(cameraRightVec, -deltaX * panFactor);
            cameraTarget.addScaledVector(cameraUpVec, deltaY * panFactor);

            // Keep camera target near ground plane to avoid drifting above/below grid
            if (cameraTarget.y > 20) {
                cameraTarget.y = 20;
            } else if (cameraTarget.y < -20) {
                cameraTarget.y = -20;
            }

            updateCameraPosition();
        }

        function setupEvents() {
            const canvas = renderer.domElement;
            
            // Touch events with improved handling for Android
            canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
            canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
            canvas.addEventListener('touchend', handleTouchEnd, { passive: false });
            canvas.addEventListener('touchcancel', handleTouchEnd, { passive: false });
            
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseup', handleMouseUp);
            canvas.addEventListener('wheel', handleWheel, { passive: false });
            canvas.addEventListener('contextmenu', e => e.preventDefault());
            
            // Keyboard shortcuts (mainly for desktop)
            if (!isMobile) {
                document.addEventListener('keydown', handleKeyDown);
            }
            
            // Close submenus when clicking outside
            document.addEventListener('click', (e) => {
                if (!e.target.closest('.menu-bar')) {
                    closeAllSubmenus();
                }

                // Close edit popup when clicking outside
                // Don't close if clicking on context menu (may be opening edit popup)
                if (!e.target.closest('.edit-popup') && !e.target.closest('#canvas') && !e.target.closest('#component-context-menu')) {
                    if (currentEditComponent) {
                        hideEditPopup();
                    }
                }

                const contextMenuTarget = e.target.closest('#component-context-menu');
                if (!contextMenuTarget) {
                    const now = Date.now();
                    if (now >= componentContextMenuCloseSuppressUntil) {
                        const isMenuVisible = componentContextMenu?.dataset?.visible === 'true';
                        if (isMenuVisible) {
                            hideComponentContextMenu();
                        }
                    }
                }
            });
            
            window.addEventListener('resize', onResize);
            window.addEventListener('orientationchange', () => {
                setTimeout(onResize, 100); // Delay to ensure orientation change is complete
            });
        }

        function handleKeyDown(e) {
            // Check if user is typing in an input field
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.tagName === 'SELECT') {
                // Handle special keys in edit popup
                if (e.key === 'Enter' && currentEditComponent) {
                    e.preventDefault();
                    saveEdit();
                    return;
                } else if (e.key === 'Escape' && currentEditComponent) {
                    e.preventDefault();
                    cancelEdit();
                    return;
                }
                return;
            }

            if (componentContextMenu?.dataset?.visible === 'true' && e.key === 'Escape') {
                hideComponentContextMenu();
                return;
            }

            const key = e.key.toLowerCase();
            const ctrl = e.ctrlKey || e.metaKey;

            // When circuit is locked, only allow view controls (h, f, g) and escape
            if (isCircuitEditLocked) {
                if (['h', 'f', 'g', 'escape'].includes(key)) {
                    e.preventDefault();
                    switch (key) {
                        case 'h':
                            resetCamera();
                            break;
                        case 'f':
                            fitToScreen();
                            break;
                        case 'g':
                            toggleGrid();
                            break;
                    }
                }
                return;
            }

            // Prevent default for our shortcuts
            if (ctrl || ['b', 'r', 'l', 's', 'j', 'w', 't', 'c', ' ', 'h', 'f', 'g'].includes(key)) {
                e.preventDefault();
            }
            
            if (ctrl) {
                switch (key) {
                    case 'z':
                        if (e.shiftKey) {
                            redo();
                        } else {
                            undo();
                        }
                        break;
                    case 'y':
                        redo();
                        break;
                    case 'c':
                        copySelected();
                        break;
                    case 'v':
                        pasteSelected();
                        break;
                    case 's':
                        saveCircuit();
                        break;
                    case 'o':
                        loadCircuit();
                        break;
                    case 'n':
                        newCircuit();
                        break;
                }
            } else {
                switch (key) {
                    case 'b':
                        addComponent('battery');
                        break;
                    case 'r':
                        addComponent('resistor');
                        break;
                    case 'l':
                        addComponent('led');
                        break;
                    case 's':
                        addComponent('switch');
                        break;
                    case 'j':
                        addJunction();
                        break;
                    case 'w':
                        toggleWireMode();
                        break;
                    case 't':
                        toggleRotateMode();
                        break;
                    case 'c':
                        clearAll();
                        break;
                    case ' ':
                        toggleMenuBar();
                        break;
                    case 'h':
                        resetCamera();
                        break;
                    case 'f':
                        fitToScreen();
                        break;
                    case 'g':
                        toggleGrid();
                        break;
                    case 'delete':
                    case 'backspace':
                        deleteSelected();
                        break;
                    case 'escape':
                        if (currentEditComponent) {
                            cancelEdit();
                            break;
                        }

                        let clearedMode = false;

                        if (isDragging) {
                            handleRelease();
                            clearedMode = true;
                        }

                        if (isWireMode) {
                            disableWireMode({ silent: true, skipNotify: true });
                            clearedMode = true;
                        }

                        if (isRotateMode) {
                            disableRotateMode({ silent: true, skipNotify: true });
                            clearedMode = true;
                        }

                        if (isMeasureMode) {
                            exitMeasureMode({ silent: true, skipNotify: true });
                            clearedMode = true;
                        }

                        hideComponentContextMenu();
                        cancelLongPress();

                        if (clearedMode) {
                            notifyParentToolState('select');
                            setStatus(' Select mode active - tap components to edit');
                        }
                        break;
                }
            }
        }

        function handleTouchStart(e) {
            e.preventDefault();

            // Immediately clear any stale touch state
            if (e.touches.length === 1 && (isPanning || lastPinchDistance > 0)) {
                // Transitioning from multi-touch to single-touch - clear multi-touch state
                isPanning = false;
                lastPinchDistance = 0;
                lastTwoFingerCenter = { x: 0, y: 0 };
            }

            if (e.touches.length === 1) {
                const touch = e.touches[0];
                lastTouchPos = { x: touch.clientX, y: touch.clientY };
                longPressStartPos = { x: touch.clientX, y: touch.clientY };

                // If locked, only allow camera rotation - no component interaction
                if (isCircuitEditLocked) {
                    isRotating = true;
                    isPanning = false;
                    return;
                }

                // Start long press timer when allowed
                if (shouldAllowLongPress()) {
                    startLongPressTimer(touch.clientX, touch.clientY);
                } else {
                    cancelLongPress();
                }

                isRotating = false;
                isPanning = false;

                // Check for component hit but don't block rotation setup
                // This allows camera rotation to start if the user moves before long-press completes
                const hitComponent = checkComponentHit(touch.clientX, touch.clientY);

                // Enable rotation for empty space touches
                // For component touches, rotation will be enabled in touchmove if not dragging
                if (!hitComponent) {
                    isRotating = true;
                }

            } else if (e.touches.length === 2) {
                // Two-finger gesture setup - immediately clear single-touch state
                cancelLongPress();
                isRotating = false;

                const touch1 = e.touches[0];
                const touch2 = e.touches[1];

                // Calculate center point for panning
                lastTwoFingerCenter = {
                    x: (touch1.clientX + touch2.clientX) / 2,
                    y: (touch1.clientY + touch2.clientY) / 2
                };

                // Calculate distance for pinch-to-zoom
                lastPinchDistance = Math.sqrt(
                    Math.pow(touch2.clientX - touch1.clientX, 2) +
                    Math.pow(touch2.clientY - touch1.clientY, 2)
                );

                isPanning = true;
            } else if (e.touches.length > 2) {
                // Three or more fingers - cancel all gestures to avoid confusion
                cancelLongPress();
                isRotating = false;
                isPanning = false;
            }
        }

        function handleTouchMove(e) {
            e.preventDefault();

            if (e.touches.length === 1) {
                const touch = e.touches[0];

                // Check if moved too far for long press - use configurable threshold
                const totalDeltaX = Math.abs(touch.clientX - longPressStartPos.x);
                const totalDeltaY = Math.abs(touch.clientY - longPressStartPos.y);
                if ((totalDeltaX > LONG_PRESS_MOVEMENT_THRESHOLD || totalDeltaY > LONG_PRESS_MOVEMENT_THRESHOLD) && longPressTimer) {
                    cancelLongPress();
                }

                if (selectedComponent && !isDragging) {
                    maybeStartDrag(touch.clientX, touch.clientY);
                }

                if (isDragging && selectedComponent) {
                    handleComponentDrag(touch.clientX, touch.clientY);
                } else {
                    // Enable rotation if not dragging, even if we initially touched a component
                    // This allows camera rotation when touching near components
                    if (!isRotating && !isDragging) {
                        isRotating = true;
                    }

                    if (isRotating && lastTouchPos.x !== 0 && lastTouchPos.y !== 0) {
                        const deltaX = touch.clientX - lastTouchPos.x;
                        const deltaY = touch.clientY - lastTouchPos.y;

                        if (!Number.isNaN(deltaX) && !Number.isNaN(deltaY) && Math.abs(deltaX) < 100 && Math.abs(deltaY) < 100) {
                            cameraAngleX += deltaX * TOUCH_ROTATE_SENSITIVITY_X;
                            const proposedAngleY = cameraAngleY - deltaY * TOUCH_ROTATE_SENSITIVITY_Y;
                            cameraAngleY = Math.max(TOUCH_ROTATE_Y_MIN, Math.min(TOUCH_ROTATE_Y_MAX, proposedAngleY));
                            updateCameraPosition();
                        }
                    }
                }

                lastTouchPos = { x: touch.clientX, y: touch.clientY };

            } else if (e.touches.length === 2) {
                // Ensure we're in panning mode for two-finger gestures
                if (!isPanning) {
                    isPanning = true;
                    isRotating = false;
                }

                const touch1 = e.touches[0];
                const touch2 = e.touches[1];

                // Calculate new center point
                const newCenter = {
                    x: (touch1.clientX + touch2.clientX) / 2,
                    y: (touch1.clientY + touch2.clientY) / 2
                };

                // Calculate new distance
                const newDistance = Math.sqrt(
                    Math.pow(touch2.clientX - touch1.clientX, 2) +
                    Math.pow(touch2.clientY - touch1.clientY, 2)
                );

                // Only pan if we have a valid previous center
                if (isPanning && lastTwoFingerCenter.x !== 0 && lastTwoFingerCenter.y !== 0) {
                    const panDeltaX = newCenter.x - lastTwoFingerCenter.x;
                    const panDeltaY = newCenter.y - lastTwoFingerCenter.y;

                    if (Math.abs(panDeltaX) > 0 || Math.abs(panDeltaY) > 0) {
                        applyCameraPan(panDeltaX, panDeltaY, TWO_FINGER_PAN_MULTIPLIER);
                    }
                }

                // Handle pinch-to-zoom only if we have a valid previous distance
                if (lastPinchDistance > 0 && newDistance > 0) {
                    const pinchDelta = newDistance - lastPinchDistance;
                    // Add threshold to prevent jittery zoom from small movements
                    if (Math.abs(pinchDelta) > 2) {
                        cameraDistance = Math.max(5, Math.min(50, cameraDistance - pinchDelta * ZOOM_SENSITIVITY_BASE));
                        updateCameraPosition();
                    }
                }

                // Update stored values
                lastTwoFingerCenter = newCenter;
                lastPinchDistance = newDistance;
            }
        }

        function handleTouchEnd(e) {
            e.preventDefault();
            cancelLongPress();

            if (isDragging) {
                handleRelease();
            }

            const remainingTouches = e.touches.length;

            if (remainingTouches === 1) {
                // Transitioning from 2+ fingers to 1 finger
                const touch = e.touches[0];
                lastTouchPos = { x: touch.clientX, y: touch.clientY };
                longPressStartPos = { x: touch.clientX, y: touch.clientY };

                // Clear multi-touch state completely
                lastPinchDistance = 0;
                lastTwoFingerCenter = { x: 0, y: 0 };

                // Enable single-finger rotation
                isRotating = true;
                isPanning = false;

            } else if (remainingTouches === 2) {
                // Transitioning from 3+ fingers to 2 fingers - reinitialize two-finger gesture
                const touch1 = e.touches[0];
                const touch2 = e.touches[1];

                lastTwoFingerCenter = {
                    x: (touch1.clientX + touch2.clientX) / 2,
                    y: (touch1.clientY + touch2.clientY) / 2
                };

                lastPinchDistance = Math.sqrt(
                    Math.pow(touch2.clientX - touch1.clientX, 2) +
                    Math.pow(touch2.clientY - touch1.clientY, 2)
                );

                isRotating = false;
                isPanning = true;

            } else {
                // All fingers lifted - completely reset touch state
                isRotating = false;
                isPanning = false;
                lastPinchDistance = 0;
                lastTwoFingerCenter = { x: 0, y: 0 };
                longPressStartPos = { x: 0, y: 0 };
                lastTouchPos = { x: 0, y: 0 };
            }
        }

        function handleMouseDown(e) {
            if (e.button === 0) {
                // Allow camera rotation even when locked, but not component interaction
                if (isCircuitEditLocked) {
                    // Only enable camera rotation when locked - no component interaction
                    isRotating = true;
                    lastTouchPos = { x: e.clientX, y: e.clientY };
                    return;
                }

                longPressStartPos = { x: e.clientX, y: e.clientY };
                if (shouldAllowLongPress()) {
                    startLongPressTimer(e.clientX, e.clientY);
                } else {
                    cancelLongPress();
                }

                // Check if clicking on a component first
                const hitComponent = checkComponentHit(e.clientX, e.clientY);

                // If no component hit and not dragging, enable camera rotation
                if (!hitComponent && !isDragging) {
                    isRotating = true;
                    lastTouchPos = { x: e.clientX, y: e.clientY };
                }
            } else if (e.button === 2) {
                isRotating = true;
                lastTouchPos = { x: e.clientX, y: e.clientY };
            }
        }

        function handleMouseMove(e) {
            // Check if moved too far for long press - use configurable threshold
            const deltaX = Math.abs(e.clientX - longPressStartPos.x);
            const deltaY = Math.abs(e.clientY - longPressStartPos.y);
            if ((deltaX > LONG_PRESS_MOVEMENT_THRESHOLD || deltaY > LONG_PRESS_MOVEMENT_THRESHOLD) && longPressTimer) {
                cancelLongPress();
            }

            if (selectedComponent && !isDragging) {
                maybeStartDrag(e.clientX, e.clientY);
            }

            if (isRotating) {
                const deltaX = e.clientX - lastTouchPos.x;
                const deltaY = e.clientY - lastTouchPos.y;
                
                cameraAngleX += deltaX * 0.01;
                cameraAngleY = Math.max(-1.5, Math.min(1.5, cameraAngleY - deltaY * 0.01));
                updateCameraPosition();
                
                lastTouchPos = { x: e.clientX, y: e.clientY };
            } else if (isDragging && selectedComponent) {
                handleComponentDrag(e.clientX, e.clientY);
            }
        }

        function handleMouseUp(e) {
            isRotating = false;
            cancelLongPress();
            if (isDragging) {
                handleRelease();
            }
        }

        function handleWheel(e) {
            e.preventDefault();
            const sensitivity = isMobile ? 0.005 : 0.01;
            cameraDistance = Math.max(5, Math.min(50, cameraDistance + e.deltaY * sensitivity));
            updateCameraPosition();
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Grid and snapping functions
        function createEnhancedGrid() {
            // Main grid - reduced complexity for mobile
            const gridSize = isMobile ? 20 : 40;
            const gridDivisions = isMobile ? 20 : 40;
            
            gridHelper = new THREE.GridHelper(gridSize, gridDivisions, 0x333366, 0x111122);
            scene.add(gridHelper);
            
            // Fine grid overlay - only on desktop
            if (!isMobile) {
                const fineGrid = new THREE.GridHelper(gridSize, gridDivisions * 2, 0x222244, 0x0a0a1a);
                fineGrid.position.y = 0.01; // Slightly above main grid
                scene.add(fineGrid);
            }
        }

        function createSnapIndicator() {
            const geometry = new THREE.RingGeometry(0.8, 1.0, 8);
            const material = new THREE.MeshBasicMaterial({ 
                color: 0x00ff88, 
                transparent: true, 
                opacity: 0.8 
            });
            snapIndicator = new THREE.Mesh(geometry, material);
            snapIndicator.rotation.x = -Math.PI / 2;
            snapIndicator.visible = false;
            scene.add(snapIndicator);
        }

        function snapToGrid(position) {
            return new THREE.Vector3(
                Math.round(position.x / GRID_SIZE) * GRID_SIZE,
                0,
                Math.round(position.z / GRID_SIZE) * GRID_SIZE
            );
        }

        function showSnapIndicator(position) {
            if (snapIndicator) {
                const snappedPos = snapToGrid(position);
                snapIndicator.position.copy(snappedPos);
                snapIndicator.visible = true;
            }
        }

        function hideSnapIndicator() {
            if (snapIndicator) {
                snapIndicator.visible = false;
            }
        }

        // Helper: get world-space axis-aligned obstacles from components and labels
        function getObstacleRects(clearance = GRID_SIZE * 1.0) {
            const rects = [];
            // Components
            components.forEach(comp => {
                const box = new THREE.Box3().setFromObject(comp.selectionBox || comp.mesh);
                if (box && box.min && box.max) {
                    rects.push({
                        minX: box.min.x - clearance,
                        maxX: box.max.x + clearance,
                        minZ: box.min.z - clearance,
                        maxZ: box.max.z + clearance,
                    });
                }
            });
            // Labels (approximate small rect around projected point)
            components.forEach(comp => {
                if (comp.mesh) {
                    const p = comp.position;
                    rects.push({
                        minX: p.x - GRID_SIZE * 0.8,
                        maxX: p.x + GRID_SIZE * 0.8,
                        minZ: p.z - GRID_SIZE * 0.8,
                        maxZ: p.z + GRID_SIZE * 0.8,
                    });
                }
            });
            return rects;
        }

        // Helper: check if a grid cell center is blocked by any rect
        function cellBlocked(x, z, rects) {
            for (let i = 0; i < rects.length; i++) {
                const r = rects[i];
                if (x >= r.minX && x <= r.maxX && z >= r.minZ && z <= r.maxZ) return true;
            }
            return false;
        }

        // Helper: collect existing wire segments for crossing penalty
        function getExistingWireSegments() {
            const segs = [];
            wires.forEach(w => {
                if (w.segments) {
                    w.segments.forEach(s => {
                        segs.push({ a: s.start.clone(), b: s.end.clone() });
                    });
                }
            });
            return segs;
        }

        function segIntersect(a1, a2, b1, b2) {
            // Axis-aligned only
            const aMinX = Math.min(a1.x, a2.x), aMaxX = Math.max(a1.x, a2.x);
            const aMinZ = Math.min(a1.z, a2.z), aMaxZ = Math.max(a1.z, a2.z);
            const bMinX = Math.min(b1.x, b2.x), bMaxX = Math.max(b1.x, b2.x);
            const bMinZ = Math.min(b1.z, b2.z), bMaxZ = Math.max(b1.z, b2.z);
            if (aMinX === aMaxX && bMinX === bMaxX) {
                // both vertical
                if (aMinX !== bMinX) return false;
                return !(aMaxZ < bMinZ || bMaxZ < aMinZ);
            } else if (aMinZ === aMaxZ && bMinZ === bMaxZ) {
                // both horizontal
                if (aMinZ !== bMinZ) return false;
                return !(aMaxX < bMinX || bMaxX < aMinX);
            } else {
                // one vertical, one horizontal
                if (aMinX === aMaxX) {
                    // a vertical, b horizontal
                    return (bMinX <= aMinX && aMinX <= bMaxX) && (aMinZ <= bMinZ && bMinZ <= aMaxZ);
                } else {
                    // a horizontal, b vertical
                    return (aMinX <= bMinX && bMinX <= aMaxX) && (bMinZ <= aMinZ && aMinZ <= bMaxZ);
                }
            }
        }

        function countCrossings(pathPoints, segs) {
            let crosses = 0;
            for (let i = 0; i < pathPoints.length - 1; i++) {
                const a = pathPoints[i], b = pathPoints[i + 1];
                for (let s of segs) {
                    if (segIntersect(a, b, s.a, s.b)) crosses++;
                }
            }
            return crosses;
        }

        // Router mode selection
        function getRouterMode() {
            // Allow override by query (?router=...), localStorage, or global
            try {
                const qs = new URLSearchParams(location.search);
                const q = qs.get('router');
                if (q) return q;
            } catch {}
            try {
                const ls = localStorage.getItem('routerMode');
                if (ls) return ls;
            } catch {}
            return (window.ROUTER_MODE || 'freeform');
        }
        
        function cycleRoutingMode() {
            const modes = ['freeform', 'manhattan', 'offset', 'arc', 'simple', 'perimeter', 'astar'];
            const current = getRouterMode();
            const currentIndex = modes.indexOf(current);
            const nextIndex = (currentIndex + 1) % modes.length;
            const nextMode = modes[nextIndex];
            
            // Save to localStorage
            try {
                localStorage.setItem('routerMode', nextMode);
                window.ROUTER_MODE = nextMode;
            } catch (e) {
                window.ROUTER_MODE = nextMode;
            }
            
            // Update UI
            const modeLabel = document.getElementById('route-mode');
            if (modeLabel) {
                const modeNames = {
                    'freeform': 'Free-form',
                    'manhattan': 'Manhattan',
                    'offset': 'Offset',
                    'arc': 'Arc',
                    'simple': 'Simple',
                    'perimeter': 'Perimeter',
                    'astar': 'A*'
                };
                modeLabel.textContent = modeNames[nextMode] || nextMode;
            }
            
            // Update existing wires with new routing
            wires.forEach(wire => {
                if (wire.updatePath) {
                    wire.updatePath();
                }
            });
            
            setStatus(` Routing mode: ${nextMode.toUpperCase()} - Wires updated with new routing style`);
            notifyParentModeState({ wireRoutingMode: nextMode });
        }

        function compressPath(points) {
            if (!points || points.length === 0) return points;
            const clean = [points[0]];
            for (let i = 1; i < points.length - 1; i++) {
                const a = clean[clean.length - 1];
                const p = points[i];
                const n = points[i + 1];
                if ((a.x === p.x && p.x === n.x) || (a.z === p.z && p.z === n.z)) continue;
                clean.push(p);
            }
            clean.push(points[points.length - 1]);
            return clean;
        }
        
        // Free-form routing - direct line with minimal bends
        function routeFreeform(A, B, startSide, endSide) {
            // Check if we need any bends at all
            const dx = Math.abs(B.x - A.x);
            const dz = Math.abs(B.z - A.z);
            
            // If points are very close or aligned, just connect directly
            if (dx < 0.1 || dz < 0.1) {
                return [A, B];
            }
            
            // For freeform, choose the most natural bend direction based on terminal sides
            // This reduces visual clutter and makes connections more intuitive
            
            // If components are facing each other (e.g., left-to-right), prefer straight-ish path
            if ((startSide === 'right' || startSide === 'positive') && 
                (endSide === 'left' || endSide === 'negative') && B.x > A.x) {
                // Natural left-to-right connection
                const midX = (A.x + B.x) / 2;
                if (dz < GRID_SIZE * 2) {
                    // Almost aligned - use single midpoint
                    return [A, new THREE.Vector3(midX, 0, A.z), new THREE.Vector3(midX, 0, B.z), B];
                }
            }
            
            if ((startSide === 'left' || startSide === 'negative') && 
                (endSide === 'right' || endSide === 'positive') && B.x < A.x) {
                // Natural right-to-left connection
                const midX = (A.x + B.x) / 2;
                if (dz < GRID_SIZE * 2) {
                    return [A, new THREE.Vector3(midX, 0, A.z), new THREE.Vector3(midX, 0, B.z), B];
                }
            }
            
            // Otherwise use a simple L-shaped corner
            // Choose corner based on which direction has more distance for cleaner look
            if (dx > dz) {
                // More horizontal distance - go horizontal first
                return [A, new THREE.Vector3(B.x, 0, A.z), B];
            } else {
                // More vertical distance - go vertical first
                return [A, new THREE.Vector3(A.x, 0, B.z), B];
            }
        }

        function routeOffset(A, B, startSide, endSide) {
            const GRID = GRID_SIZE;
            const dx = B.x - A.x;
            const dz = B.z - A.z;
            const distance = Math.sqrt(dx * dx + dz * dz);
            if (distance < 0.1) {
                return [A, B];
            }

            const horizontal = Math.abs(dx) >= Math.abs(dz);
            const offset = Math.min(Math.max(distance * 0.25, GRID * 2), GRID * 6);

            if (horizontal) {
                const direction = Math.sign(dz || 1);
                const midZ = (A.z + B.z) / 2 + direction * offset;
                const p1 = snapToGrid(new THREE.Vector3(A.x, 0, midZ));
                const p2 = snapToGrid(new THREE.Vector3(B.x, 0, midZ));
                return compressPath([A, p1, p2, B]);
            }

            const direction = Math.sign(dx || 1);
            const midX = (A.x + B.x) / 2 + direction * offset;
            const p1 = snapToGrid(new THREE.Vector3(midX, 0, A.z));
            const p2 = snapToGrid(new THREE.Vector3(midX, 0, B.z));
            return compressPath([A, p1, p2, B]);
        }

        function routeArc(A, B, startSide, endSide) {
            const GRID = GRID_SIZE;
            const dx = B.x - A.x;
            const dz = B.z - A.z;
            const distance = Math.sqrt(dx * dx + dz * dz);
            if (distance < 0.1) {
                return [A, B];
            }

            const midX = (A.x + B.x) / 2;
            const midZ = (A.z + B.z) / 2;
            const normX = -dz / distance;
            const normZ = dx / distance;
            const bend = Math.min(Math.max(distance * 0.3, GRID * 3), GRID * 8);
            const control = new THREE.Vector3(midX + normX * bend, 0, midZ + normZ * bend);

            const segments = Math.max(5, Math.min(14, Math.round(distance / GRID) + 4));
            const points = [];
            for (let i = 0; i <= segments; i++) {
                const t = i / segments;
                const inv = 1 - t;
                const x = inv * inv * A.x + 2 * inv * t * control.x + t * t * B.x;
                const z = inv * inv * A.z + 2 * inv * t * control.z + t * t * B.z;
                points.push(new THREE.Vector3(x, 0, z));
            }
            return points;
        }

        function routeSimple(A, B, startSide, endSide) {
            const GRID = GRID_SIZE;
            const STUB = GRID * 2;
            function stub(point, side, toward) {
                const dx = toward.x - point.x, dz = toward.z - point.z;
                if (side === 'left' || side === 'negative') return snapToGrid(new THREE.Vector3(point.x - STUB, 0, point.z));
                if (side === 'right' || side === 'positive') return snapToGrid(new THREE.Vector3(point.x + STUB, 0, point.z));
                return Math.abs(dx) >= Math.abs(dz)
                    ? snapToGrid(new THREE.Vector3(point.x + Math.sign(dx||1)*STUB, 0, point.z))
                    : snapToGrid(new THREE.Vector3(point.x, 0, point.z + Math.sign(dz||1)*STUB));
            }
            const Astub = stub(A, startSide, B);
            const Bstub = stub(B, endSide, A);
            if (Math.abs(Astub.x - Bstub.x) < 0.001 || Math.abs(Astub.z - Bstub.z) < 0.001) {
                return compressPath([A, Astub, Bstub, B]);
            }
            // Choose corner that increases distance from A along the first segment (outward)
            const c1 = new THREE.Vector3(Bstub.x, 0, Astub.z);
            const c2 = new THREE.Vector3(Astub.x, 0, Bstub.z);
            const moveXOut = Math.abs(c1.x - A.x) >= Math.abs(Astub.x - A.x);
            const moveZOut = Math.abs(c2.z - A.z) >= Math.abs(Astub.z - A.z);
            const C = moveXOut ? c1 : (moveZOut ? c2 : c1);
            return compressPath([A, Astub, snapToGrid(C), Bstub, B]);
        }

        function routePerimeter(A, B, startSide, endSide) {
            const GRID = GRID_SIZE;
            const STUB = GRID * 2, OUTER = GRID * 4;
            function stub(point, side, toward) {
                const dx = toward.x - point.x, dz = toward.z - point.z;
                if (side === 'left' || side === 'negative') return snapToGrid(new THREE.Vector3(point.x - STUB, 0, point.z));
                if (side === 'right' || side === 'positive') return snapToGrid(new THREE.Vector3(point.x + STUB, 0, point.z));
                return Math.abs(dx) >= Math.abs(dz)
                    ? snapToGrid(new THREE.Vector3(point.x + Math.sign(dx||1)*STUB, 0, point.z))
                    : snapToGrid(new THREE.Vector3(point.x, 0, point.z + Math.sign(dz||1)*STUB));
            }
            const Astub = stub(A, startSide, B);
            const Bstub = stub(B, endSide, A);
            if (Math.abs(Astub.x - Bstub.x) < 0.001 || Math.abs(Astub.z - Bstub.z) < 0.001) {
                return compressPath([A, Astub, Bstub, B]);
            }
            const minX = Math.min(Astub.x, Bstub.x), maxX = Math.max(Astub.x, Bstub.x);
            const minZ = Math.min(Astub.z, Bstub.z), maxZ = Math.max(Astub.z, Bstub.z);
            const dx = Bstub.x - Astub.x, dz = Bstub.z - Astub.z;
            if (Math.abs(dx) >= Math.abs(dz)) {
                const outwardX = dx > 0 ? (maxX + OUTER) : (minX - OUTER);
                return compressPath([A, Astub, snapToGrid(new THREE.Vector3(outwardX,0,Astub.z)), snapToGrid(new THREE.Vector3(outwardX,0,Bstub.z)), Bstub, B]);
            } else {
                const outwardZ = dz > 0 ? (maxZ + OUTER) : (minZ - OUTER);
                return compressPath([A, Astub, snapToGrid(new THREE.Vector3(Astub.x,0,outwardZ)), snapToGrid(new THREE.Vector3(Bstub.x,0,outwardZ)), Bstub, B]);
            }
        }

        function routeAStar(A, B, startSide, endSide) {
            const GRID = GRID_SIZE;
            const obstacles = getObstacleRects(GRID * 0.6);
            function outwardDirForSide(side, axisDelta) {
                if (side === 'left' || side === 'negative') return -1;
                if (side === 'right' || side === 'positive') return 1;
                return Math.sign(axisDelta) || 1;
            }
            function computeStub(point, side, toward) {
                const dx = toward.x - point.x; const dz = toward.z - point.z;
                const useX = Math.abs(dx) >= Math.abs(dz);
                const dir = useX ? outwardDirForSide(side, dx) : outwardDirForSide(side, dz);
                for (let len = 1; len <= 3; len++) {
                    const nx = point.x + (useX ? dir * len * GRID : 0);
                    const nz = point.z + (!useX ? dir * len * GRID : 0);
                    const p = snapToGrid(new THREE.Vector3(nx, 0, nz));
                    if (!cellBlocked(p.x, p.z, obstacles)) return p;
                }
                return snapToGrid(new THREE.Vector3(point.x + (useX ? dir * GRID : 0), 0, point.z + (!useX ? dir * GRID : 0)));
            }
            const Astub = computeStub(A, startSide, B);
            const Bstub = computeStub(B, endSide, A);
            if (Math.abs(Astub.x - Bstub.x) < 0.001 || Math.abs(Astub.z - Bstub.z) < 0.001) {
                return compressPath([A, Astub, Bstub, B]);
            }
            const minX = Math.min(Astub.x, Bstub.x) - GRID * 8, maxX = Math.max(Astub.x, Bstub.x) + GRID * 8;
            const minZ = Math.min(Astub.z, Bstub.z) - GRID * 8, maxZ = Math.max(Astub.z, Bstub.z) + GRID * 8;
            function key(x,z){return x+","+z}
            const start = Astub, goal = Bstub;
            const pq=[]; const came=new Map(); const g=new Map(); const f=new Map(); const dir=new Map();
            function push(n,ff){pq.push({n,ff});pq.sort((a,b)=>a.ff-b.ff)} function pop(){return pq.shift().n}
            const existingSegs = getExistingWireSegments();
            const ELBOW = GRID*5, CROSS = GRID*3;
            function h(p){return Math.abs(p.x-goal.x)+Math.abs(p.z-goal.z)}
            const sK=key(start.x,start.z); g.set(sK,0); f.set(sK,h(start)); push(start,f.get(sK)); dir.set(sK,null);
            const dirs=[[GRID,0,'R'],[0,GRID,'D'],[-GRID,0,'L'],[0,-GRID,'U']];
            while(pq.length){
                const cur=pop(); const cK=key(cur.x,cur.z);
                if(cur.x===goal.x && cur.z===goal.z){
                    const path=[cur]; let ck=cK; while(came.has(ck)){const prev=came.get(ck); path.unshift(prev); ck=key(prev.x,prev.z);} 
                    return compressPath([A].concat(path).concat([B]));
                }
                for(const[dX,dZ,code] of dirs){
                    const nx=cur.x+dX, nz=cur.z+dZ; if(nx<minX||nx>maxX||nz<minZ||nz>maxZ) continue; if(cellBlocked(nx,nz,obstacles)) continue; const nK=key(nx,nz);
                    const step=GRID; const prev=dir.get(cK); const elbow=(prev&&prev!==code)?ELBOW:0; 
                    const a=cur, b=new THREE.Vector3(nx,0,nz); let cross=0; for(let s of existingSegs){ if(segIntersect(a,b,s.a,s.b)) cross+=CROSS; }
                    const tent=(g.get(cK)||Infinity)+step+elbow+cross; if(tent < (g.get(nK)||Infinity)){ came.set(nK,cur); g.set(nK,tent); const ff=tent+h({x:nx,z:nz}); f.set(nK,ff); dir.set(nK,code); push(new THREE.Vector3(nx,0,nz),ff);} 
                }
            }
            return compressPath([A, new THREE.Vector3(Bstub.x,0,Astub.z), B]);
        }

        // Enhanced Manhattan routing with intelligent wire splitting
        function routeManhattan(A, B, startSide, endSide) {
            const GRID = GRID_SIZE;
            const STUB = GRID * 2;
            
            // Create stub segments extending from connection points
            function createStub(point, side, toward) {
                const dx = toward.x - point.x;
                const dz = toward.z - point.z;
                
                // Handle component sides with proper direction
                if (side === 'left' || side === 'negative') {
                    return snapToGrid(new THREE.Vector3(point.x - STUB, 0, point.z));
                }
                if (side === 'right' || side === 'positive') {
                    return snapToGrid(new THREE.Vector3(point.x + STUB, 0, point.z));
                }
                
                // For center/junction connections, choose direction based on target
                return Math.abs(dx) >= Math.abs(dz)
                    ? snapToGrid(new THREE.Vector3(point.x + Math.sign(dx || 1) * STUB, 0, point.z))
                    : snapToGrid(new THREE.Vector3(point.x, 0, point.z + Math.sign(dz || 1) * STUB));
            }
            
            const Astub = createStub(A, startSide, B);
            const Bstub = createStub(B, endSide, A);
            
            // Direct horizontal or vertical connection
            if (Math.abs(Astub.x - Bstub.x) < 0.001) {
                return compressPath([A, Astub, Bstub, B]);
            }
            if (Math.abs(Astub.z - Bstub.z) < 0.001) {
                return compressPath([A, Astub, Bstub, B]);
            }
            
            // Create L-shaped path with intelligent corner selection
            // Prefer corners that create cleaner textbook-style layouts
            const corner1 = snapToGrid(new THREE.Vector3(Bstub.x, 0, Astub.z));
            const corner2 = snapToGrid(new THREE.Vector3(Astub.x, 0, Bstub.z));
            
            // Choose corner based on circuit topology for cleaner routing
            // Prefer horizontal-then-vertical for typical series circuits
            const useCorner1 = shouldUseHorizontalFirst(A, B, startSide, endSide);
            const corner = useCorner1 ? corner1 : corner2;
            
            return compressPath([A, Astub, corner, Bstub, B]);
        }
        
        // Determine if horizontal routing should come first for cleaner layouts
        function shouldUseHorizontalFirst(startPos, endPos, startSide, endSide) {
            // For battery connections, prefer routing away from battery first
            if (startSide === 'positive' || startSide === 'negative') {
                return true;
            }
            
            // For components in series (left-to-right), prefer horizontal
            if ((startSide === 'right' && endSide === 'left') || 
                (startSide === 'left' && endSide === 'right')) {
                return true;
            }
            
            // Default to horizontal-first for cleaner appearance
            return Math.abs(endPos.x - startPos.x) >= Math.abs(endPos.z - startPos.z);
        }
        
        // Detect and create intelligent wire splits for parallel circuits
        function createIntelligentSplit(sourceObj, targetObjs, splitType = 'parallel') {
            if (!sourceObj || !targetObjs || targetObjs.length === 0) return [];
            
            const GRID = GRID_SIZE;
            const SPREAD = GRID * 3; // Spacing between parallel branches
            const createdWires = [];
            const createdJunctions = [];
            
            if (splitType === 'parallel' && targetObjs.length > 1) {
                // Get source connection point
                const sourcePos = sourceObj.getWorldConnectionPoint 
                    ? sourceObj.getWorldConnectionPoint('right') 
                    : sourceObj.position;
                const snappedSource = snapToGrid(sourcePos.clone());
                
                // Create vertical bus for parallel distribution
                const busX = snappedSource.x + GRID * 4;
                const targetCount = targetObjs.length;
                const totalHeight = (targetCount - 1) * SPREAD;
                const busStartZ = snappedSource.z - totalHeight / 2;
                
                // Create junction spine for parallel distribution
                const spineJunctions = [];
                for (let i = 0; i < targetCount; i++) {
                    const jPos = snapToGrid(new THREE.Vector3(busX, 0, busStartZ + i * SPREAD));
                    const junction = new Junction(jPos);
                    junctions.push(junction);
                    spineJunctions.push(junction);
                    createdJunctions.push(junction);
                }
                
                // Connect source to middle junction of spine
                const midIndex = Math.floor(targetCount / 2);
                const midJunction = spineJunctions[midIndex];
                const feedWire = new Wire(sourceObj, 'right', midJunction, 'center');
                wires.push(feedWire);
                createdWires.push(feedWire);
                
                // Connect spine junctions vertically
                for (let i = 0; i < spineJunctions.length - 1; i++) {
                    const spineWire = new Wire(spineJunctions[i], 'center', spineJunctions[i + 1], 'center');
                    wires.push(spineWire);
                    createdWires.push(spineWire);
                }
                
                // Branch out to each target component
                targetObjs.forEach((target, i) => {
                    const branchWire = new Wire(spineJunctions[i], 'center', target, 'left');
                    wires.push(branchWire);
                    createdWires.push(branchWire);
                });
                
                return { wires: createdWires, junctions: createdJunctions };
            }
            
            // Series connection (default)
            for (let i = 0; i < targetObjs.length; i++) {
                const target = targetObjs[i];
                const startSide = i === 0 ? 'right' : 'right';
                const endSide = 'left';
                
                const wire = new Wire(
                    i === 0 ? sourceObj : targetObjs[i - 1],
                    startSide,
                    target,
                    endSide
                );
                wires.push(wire);
                createdWires.push(wire);
            }
            
            return { wires: createdWires, junctions: createdJunctions };
        }
        
        // Analyze circuit topology to detect series/parallel configurations
        function analyzeCircuitTopology() {
            const topology = {
                series: [],
                parallel: [],
                combination: []
            };
            
            // Group components by their connection patterns
            const batteries = components.filter(c => c.type === 'battery');
            const otherComponents = components.filter(c => c.type !== 'battery');
            
            if (batteries.length === 0 || otherComponents.length === 0) {
                return topology;
            }
            
            // Detect series chains (components connected in sequence)
            const visited = new Set();
            otherComponents.forEach(comp => {
                if (!visited.has(comp)) {
                    const chain = findSeriesChain(comp, otherComponents, visited);
                    if (chain.length > 1) {
                        topology.series.push(chain);
                    }
                }
            });
            
            // Detect parallel groups (multiple paths between same two nodes)
            const parallelGroups = findParallelGroups(otherComponents, wires);
            topology.parallel = parallelGroups;
            
            return topology;
        }
        
        // Find components connected in series
        function findSeriesChain(startComp, allComponents, visited) {
            const chain = [startComp];
            visited.add(startComp);
            
            // Look for connected components in sequence
            let current = startComp;
            while (true) {
                const nextComp = findNextInSeries(current, allComponents, visited);
                if (!nextComp) break;
                chain.push(nextComp);
                visited.add(nextComp);
                current = nextComp;
            }
            
            return chain;
        }
        
        // Find next component in a series chain
        function findNextInSeries(component, allComponents, visited) {
            const connectedWires = wires.filter(w => w.startObj === component || w.endObj === component);
            
            for (const wire of connectedWires) {
                const otherEnd = wire.startObj === component ? wire.endObj : wire.startObj;
                if (!visited.has(otherEnd) && allComponents.includes(otherEnd)) {
                    return otherEnd;
                }
            }
            
            return null;
        }
        
        // Find groups of components connected in parallel
        function findParallelGroups(components, wires) {
            const groups = [];
            
            // Implementation for detecting parallel configurations
            // This would analyze wire connections to find multiple paths
            // between the same two junction points
            
            return groups;
        }

        function createRightAngledWirePath(startPos, endPos, startSide, endSide) {
            const mode = getRouterMode();

            // ALWAYS use exact terminal positions for wire endpoints to prevent gaps.
            // Only intermediate waypoints are snapped for visual alignment.
            // This ensures wires connect precisely to component terminals in all routing modes.
            const A = startPos.clone();
            const B = endPos.clone();
            
            // Support free-form routing
            if (mode === 'freeform') {
                return routeFreeform(A, B, startSide, endSide);
            }

            if (mode === 'offset') {
                return routeOffset(A, B, startSide, endSide);
            }

            if (mode === 'arc') {
                return routeArc(A, B, startSide, endSide);
            }
            
            // Use enhanced Manhattan routing for textbook-style circuits
            if (mode === 'manhattan') {
                return routeManhattan(A, B, startSide, endSide);
            }
            if (mode === 'simple') return routeSimple(A, B, startSide, endSide);
            if (mode === 'perimeter') return routePerimeter(A, B, startSide, endSide);
            if (mode === 'astar') return routeAStar(A, B, startSide, endSide);
            
            // Default to Manhattan routing
            return routeManhattan(A, B, startSide, endSide);
        }

        function positionComponent(component, x, z, rotation) {
            const point = snapToGrid(new THREE.Vector3(x, 0, z));
            component.position.copy(point);
            component.mesh.position.copy(component.position);
            component.rotation = normalizeAngle(rotation || 0);
            component.mesh.rotation.y = component.rotation;
        }

        function clearCircuitRouting() {
            wires.forEach(wire => wire.remove());
            wires = [];
            junctions.forEach(junction => {
                if (junction.mesh) {
                    scene.remove(junction.mesh);
                }
            });
            junctions.length = 0;
        }

        function connectTerminals(startObj, startSide, endObj, endSide) {
            const wire = new Wire(startObj, startSide, endObj, endSide);
            wires.push(wire);
            return wire;
        }

        function createSeriesSquareLayout(battery, sideComponents) {
            if (!battery || !Array.isArray(sideComponents) || sideComponents.length === 0) {
                return false;
            }

            const halfWidth = GRID_SIZE * 5;
            const halfHeight = GRID_SIZE * 3;
            const componentCount = sideComponents.length;

            const topCount = componentCount === 1 ? 1 : Math.ceil(componentCount / 3);
            const bottomCount = componentCount === 1 ? 0 : Math.ceil((componentCount - topCount) / 2);
            const rightCount = componentCount - topCount - bottomCount;

            const topComponents = sideComponents.slice(0, topCount);
            const rightComponents = sideComponents.slice(topCount, topCount + rightCount);
            const bottomComponents = sideComponents.slice(topCount + rightCount);

            const placeTopSide = () => {
                const span = halfWidth * 2;
                const step = span / topComponents.length;
                topComponents.forEach((comp, index) => {
                    const x = -halfWidth + step * (index + 0.5);
                    positionComponent(comp, x, halfHeight, 0);
                });
            };

            const placeRightSide = () => {
                if (rightComponents.length === 0) return;
                const span = halfHeight * 2;
                const step = span / rightComponents.length;
                rightComponents.forEach((comp, index) => {
                    const z = halfHeight - step * (index + 0.5);
                    positionComponent(comp, halfWidth, z, Math.PI / 2);
                });
            };

            const placeBottomSide = () => {
                if (bottomComponents.length === 0) return;
                const span = halfWidth * 2;
                const step = span / bottomComponents.length;
                bottomComponents.forEach((comp, index) => {
                    const x = halfWidth - step * (index + 0.5);
                    positionComponent(comp, x, -halfHeight, 0);
                });
            };

            placeTopSide();
            placeRightSide();
            placeBottomSide();

            const topLeft = new Junction(snapToGrid(new THREE.Vector3(-halfWidth, 0, halfHeight)));
            const topRight = new Junction(snapToGrid(new THREE.Vector3(halfWidth, 0, halfHeight)));
            const bottomRight = new Junction(snapToGrid(new THREE.Vector3(halfWidth, 0, -halfHeight)));
            const bottomLeft = new Junction(snapToGrid(new THREE.Vector3(-halfWidth, 0, -halfHeight)));
            junctions.push(topLeft, topRight, bottomRight, bottomLeft);

            const connectSide = (startNode, endNode, laneComponents, entrySide, exitSide) => {
                if (laneComponents.length === 0) {
                    connectTerminals(startNode, 'center', endNode, 'center');
                    return;
                }
                let previous = startNode;
                let previousSide = 'center';
                laneComponents.forEach((comp) => {
                    connectTerminals(previous, previousSide, comp, entrySide);
                    previous = comp;
                    previousSide = exitSide;
                });
                connectTerminals(previous, previousSide, endNode, 'center');
            };

            connectTerminals(battery, 'positive', topLeft, 'center');
            connectSide(topLeft, topRight, topComponents, 'left', 'right');
            connectSide(topRight, bottomRight, rightComponents, 'right', 'left');
            connectSide(bottomRight, bottomLeft, bottomComponents, 'right', 'left');
            connectTerminals(bottomLeft, 'center', battery, 'negative');

            return true;
        }

        function createParallelRailLayout(battery, branchComponents) {
            if (!battery || !Array.isArray(branchComponents) || branchComponents.length === 0) {
                return false;
            }

            const branchCount = branchComponents.length;
            const leftRailX = -GRID_SIZE * 5;
            const railTopZ = GRID_SIZE * 3;
            const railBottomZ = -GRID_SIZE * 3;
            const rightRailX = GRID_SIZE * 5 + Math.max(0, branchCount - 3) * GRID_SIZE * 2;
            const spacing = (rightRailX - leftRailX) / (branchCount + 1);

            const branchNodesTop = [];
            const branchNodesBottom = [];

            branchComponents.forEach((comp, index) => {
                const x = leftRailX + spacing * (index + 1);
                positionComponent(comp, x, 0, Math.PI / 2);
                const topNode = new Junction(snapToGrid(new THREE.Vector3(x, 0, railTopZ)));
                const bottomNode = new Junction(snapToGrid(new THREE.Vector3(x, 0, railBottomZ)));
                branchNodesTop.push(topNode);
                branchNodesBottom.push(bottomNode);
                junctions.push(topNode, bottomNode);
            });

            const sourceTop = new Junction(snapToGrid(new THREE.Vector3(leftRailX, 0, railTopZ)));
            const sourceBottom = new Junction(snapToGrid(new THREE.Vector3(leftRailX, 0, railBottomZ)));
            const returnTop = new Junction(snapToGrid(new THREE.Vector3(rightRailX, 0, railTopZ)));
            const returnBottom = new Junction(snapToGrid(new THREE.Vector3(rightRailX, 0, railBottomZ)));
            junctions.push(sourceTop, sourceBottom, returnTop, returnBottom);

            connectTerminals(battery, 'positive', sourceTop, 'center');
            connectTerminals(sourceBottom, 'center', battery, 'negative');

            const topRail = [sourceTop, ...branchNodesTop, returnTop];
            const bottomRail = [sourceBottom, ...branchNodesBottom, returnBottom];

            for (let i = 0; i < topRail.length - 1; i++) {
                connectTerminals(topRail[i], 'center', topRail[i + 1], 'center');
            }
            for (let i = 0; i < bottomRail.length - 1; i++) {
                connectTerminals(bottomRail[i], 'center', bottomRail[i + 1], 'center');
            }

            connectTerminals(returnTop, 'center', returnBottom, 'center');

            branchComponents.forEach((comp, index) => {
                connectTerminals(branchNodesTop[index], 'center', comp, 'right');
                connectTerminals(comp, 'left', branchNodesBottom[index], 'center');
            });

            return true;
        }

        function createCombinationFallbackLayout(battery, otherComponents) {
            // Canonical screenshot-style fallback:
            // two parallel branches in series (top pair and bottom pair).
            if (otherComponents.length === 4) {
                const centerX = GRID_SIZE * 2;
                const branchDx = GRID_SIZE * 2;
                const leftBranchX = centerX - branchDx;
                const rightBranchX = centerX + branchDx;
                const topNodeZ = GRID_SIZE * 3;
                const midNodeZ = 0;
                const bottomNodeZ = -GRID_SIZE * 3;
                const topCompZ = (topNodeZ + midNodeZ) / 2;
                const bottomCompZ = (midNodeZ + bottomNodeZ) / 2;
                const sourceX = -GRID_SIZE * 5;

                // Top parallel pair
                positionComponent(otherComponents[0], leftBranchX, topCompZ, Math.PI / 2);
                positionComponent(otherComponents[1], rightBranchX, topCompZ, Math.PI / 2);

                // Bottom parallel pair
                positionComponent(otherComponents[2], leftBranchX, bottomCompZ, Math.PI / 2);
                positionComponent(otherComponents[3], rightBranchX, bottomCompZ, Math.PI / 2);

                const topSource = new Junction(snapToGrid(new THREE.Vector3(sourceX, 0, topNodeZ)));
                const topCenter = new Junction(snapToGrid(new THREE.Vector3(centerX, 0, topNodeZ)));
                const midCenter = new Junction(snapToGrid(new THREE.Vector3(centerX, 0, midNodeZ)));
                const bottomCenter = new Junction(snapToGrid(new THREE.Vector3(centerX, 0, bottomNodeZ)));
                const bottomSource = new Junction(snapToGrid(new THREE.Vector3(sourceX, 0, bottomNodeZ)));

                const topLeft = new Junction(snapToGrid(new THREE.Vector3(leftBranchX, 0, topNodeZ)));
                const topRight = new Junction(snapToGrid(new THREE.Vector3(rightBranchX, 0, topNodeZ)));
                const midLeft = new Junction(snapToGrid(new THREE.Vector3(leftBranchX, 0, midNodeZ)));
                const midRight = new Junction(snapToGrid(new THREE.Vector3(rightBranchX, 0, midNodeZ)));
                const bottomLeft = new Junction(snapToGrid(new THREE.Vector3(leftBranchX, 0, bottomNodeZ)));
                const bottomRight = new Junction(snapToGrid(new THREE.Vector3(rightBranchX, 0, bottomNodeZ)));

                junctions.push(
                    topSource, topCenter, midCenter, bottomCenter, bottomSource,
                    topLeft, topRight, midLeft, midRight, bottomLeft, bottomRight
                );

                connectTerminals(battery, 'positive', topSource, 'center');
                connectTerminals(topSource, 'center', topCenter, 'center');
                connectTerminals(bottomCenter, 'center', bottomSource, 'center');
                connectTerminals(bottomSource, 'center', battery, 'negative');

                connectTerminals(topCenter, 'center', topLeft, 'center');
                connectTerminals(topCenter, 'center', topRight, 'center');
                connectTerminals(midCenter, 'center', midLeft, 'center');
                connectTerminals(midCenter, 'center', midRight, 'center');
                connectTerminals(bottomCenter, 'center', bottomLeft, 'center');
                connectTerminals(bottomCenter, 'center', bottomRight, 'center');

                connectTerminals(topLeft, 'center', otherComponents[0], 'right');
                connectTerminals(otherComponents[0], 'left', midLeft, 'center');
                connectTerminals(topRight, 'center', otherComponents[1], 'right');
                connectTerminals(otherComponents[1], 'left', midRight, 'center');

                connectTerminals(midLeft, 'center', otherComponents[2], 'right');
                connectTerminals(otherComponents[2], 'left', bottomLeft, 'center');
                connectTerminals(midRight, 'center', otherComponents[3], 'right');
                connectTerminals(otherComponents[3], 'left', bottomRight, 'center');
                return;
            }

            const spacing = GRID_SIZE * 4;
            const halfCount = Math.max(1, Math.ceil(otherComponents.length / 2));

            otherComponents.forEach((comp, index) => {
                const row = index % halfCount;
                const col = Math.floor(index / halfCount);
                const x = spacing * (2 + col * 2);
                const z = (row - halfCount / 2) * spacing;
                positionComponent(comp, x, z, Math.PI / 2);
            });

            createParallelBus(battery, otherComponents);

            const returnX = spacing * 6;
            const returnJunctions = [];
            otherComponents.forEach((comp) => {
                const z = comp.position.z;
                const junctionPoint = new Junction(snapToGrid(new THREE.Vector3(returnX, 0, z)));
                junctions.push(junctionPoint);
                returnJunctions.push(junctionPoint);
                connectTerminals(comp, 'right', junctionPoint, 'center');
            });

            for (let i = 0; i < returnJunctions.length - 1; i++) {
                connectTerminals(returnJunctions[i], 'center', returnJunctions[i + 1], 'center');
            }

            const middleReturn = returnJunctions[Math.floor(returnJunctions.length / 2)];
            connectTerminals(middleReturn, 'center', battery, 'negative');
        }

            // Auto-arrange circuit for professional schematic layout
        function arrangeCircuitSchematic() {
            if (components.length === 0) return;

            saveState(); // Save for undo

            const batteries = components.filter(c => c.type === 'battery');
            const otherComponents = components.filter(c => c.type !== 'battery');
            if (batteries.length === 0) {
                setStatus(' Add a battery first for schematic arrangement');
                return;
            }
            if (otherComponents.length === 0) {
                fitToScreen();
                setStatus(' Add components to arrange');
                return;
            }

            // Detect branching BEFORE we clear wires/junctions.
            const terminalFanout = new Map();
            const bumpFanout = (key) => {
                if (!key) return;
                terminalFanout.set(key, (terminalFanout.get(key) || 0) + 1);
            };
            wires.forEach((wire) => {
                bumpFanout(getTerminalKey(wire.startObj, wire.startSide || 'center'));
                bumpFanout(getTerminalKey(wire.endObj, wire.endSide || 'center'));
            });
            const hasBranching = (junctions && junctions.length > 0) || Array.from(terminalFanout.values()).some((count) => count > 1);

            const topologyGuess = detectCircuitTopology(otherComponents, wires, junctions);
            let layoutTopology = topologyGuess?.type;
            if (layoutTopology !== 'series' && layoutTopology !== 'parallel' && layoutTopology !== 'combination') {
                layoutTopology = hasBranching ? 'parallel' : 'series';
            }

            clearCircuitRouting();

            const battery = batteries[0];
            positionComponent(battery, -GRID_SIZE * 5, 0, Math.PI / 2);

            let layoutApplied = false;
            if (layoutTopology === 'parallel') {
                layoutApplied = createParallelRailLayout(battery, otherComponents);
            } else if (layoutTopology === 'series') {
                layoutApplied = createSeriesSquareLayout(battery, otherComponents);
            } else {
                createCombinationFallbackLayout(battery, otherComponents);
                layoutApplied = true;
            }

            if (!layoutApplied) {
                fitToScreen();
                setStatus(' Could not apply layout - add valid circuit components');
                return;
            }

            fitToScreen();
            analyzeCircuit();

            if (layoutTopology === 'parallel') {
                setStatus(' Applied standardized parallel layout: horizontal rails, centered vertical branches.');
            } else if (layoutTopology === 'series') {
                setStatus(' Applied standardized series layout: one centered component per side run.');
            } else {
                setStatus(' Applied combination layout with standardized branch routing.');
            }
        }
        
        // Linear/Tree layout with battery at top
        function arrangeLinearLayout() {
            if (components.length === 0) return;
            
            saveState(); // Save for undo
            
            // Find batteries (power sources)
            const batteries = components.filter(c => c.type === 'battery');
            const otherComponents = components.filter(c => c.type !== 'battery');
            
            if (batteries.length === 0) {
                setStatus(' Add a battery first for linear arrangement');
                return;
            }
            
            // Clear existing wires for clean re-routing
            wires.forEach(wire => wire.remove());
            wires = [];
            
            // Clear existing junctions
            junctions.forEach(junction => {
                if (junction.mesh) scene.remove(junction.mesh);
            });
            junctions.length = 0;
            
            const SPACING = GRID_SIZE * 3;
            const battery = batteries[0];
            
            // Position battery at the top center
            battery.position.set(0, 0, -SPACING * 3);
            battery.mesh.position.copy(battery.position);
            
            if (otherComponents.length === 0) {
                setStatus(' Add components to arrange');
                return;
            }
            
            // Arrange components in tree structure below battery
            const levels = Math.ceil(Math.log2(otherComponents.length + 1));
            let componentIndex = 0;
            
            for (let level = 1; level <= levels && componentIndex < otherComponents.length; level++) {
                const componentsInLevel = Math.min(Math.pow(2, level - 1), otherComponents.length - componentIndex);
                const levelZ = -SPACING * 3 + level * SPACING * 2;
                const totalWidth = (componentsInLevel - 1) * SPACING * 2;
                const startX = -totalWidth / 2;
                
                for (let i = 0; i < componentsInLevel; i++) {
                    if (componentIndex >= otherComponents.length) break;
                    
                    const comp = otherComponents[componentIndex];
                    const x = startX + i * SPACING * 2;
                    const p = snapToGrid(new THREE.Vector3(x, 0, levelZ));
                    comp.position.copy(p);
                    comp.mesh.position.copy(comp.position);
                    componentIndex++;
                }
            }
            
            // Wire in series from top to bottom
            let prevComp = battery;
            let prevSide = 'positive';
            
            for (let i = 0; i < otherComponents.length; i++) {
                const comp = otherComponents[i];
                const wire = new Wire(prevComp, prevSide, comp, 'left');
                wires.push(wire);
                prevComp = comp;
                prevSide = 'right';
            }
            
            // Close the circuit back to battery
            if (otherComponents.length > 0) {
                const lastWire = new Wire(prevComp, prevSide, battery, 'negative');
                wires.push(lastWire);
            }
            
            // Center the view on the circuit
            fitToScreen();
            analyzeCircuit();
            setStatus(' Circuit arranged in linear tree layout with battery at top!');
        }
        
        // Arrange circuit based on current layout mode
        function arrangeByLayoutMode() {
            if (layoutMode === 'linear') {
                arrangeLinearLayout();
            } else if (layoutMode === 'square') {
                arrangeCircuitSchematic();
            } else {
                // Free mode - just organize components in a grid
                if (components.length === 0) return;
                
                saveState();
                
                const SPACING = GRID_SIZE * 3;
                const cols = Math.ceil(Math.sqrt(components.length));
                
                components.forEach((comp, index) => {
                    const row = Math.floor(index / cols);
                    const col = index % cols;
                    const x = (col - cols / 2) * SPACING;
                    const z = (row - Math.ceil(components.length / cols) / 2) * SPACING;
                    const p = snapToGrid(new THREE.Vector3(x, 0, z));
                    comp.position.copy(p);
                    comp.mesh.position.copy(comp.position);
                });
                
                fitToScreen();
                setStatus(' Components arranged in free-form grid - wire as you like!');
            }
        }

        // Launch application function
        function launchApplication() {
            const landingPage = document.getElementById('landing-page');
            const launchBtn = document.getElementById('launch-btn');
            const loadingProgress = document.getElementById('loading-progress');
            const loadingText = document.getElementById('loading-text');
            
            // Hide launch button and show loading (button hidden in auto mode)
            loadingProgress.style.display = 'block';
            loadingText.style.display = 'block';
            
            // Launch main app immediately (skip splash delays)
            setTimeout(() => {
                landingPage.classList.add('landing-hidden');
                
                setTimeout(() => {
                    landingPage.style.display = 'none';
                    
                    // Initialize the main application
                    document.getElementById('menu-bar').style.display = 'block';
                    document.getElementById('status').style.display = 'block';
                    document.getElementById('canvas').style.display = 'block';

                    const toggleButton = document.getElementById('menu-toggle');
                    if (toggleButton) {
                        toggleButton.classList.toggle('open', menuVisible);
                        toggleButton.textContent = menuVisible ? 'Close' : 'Menu';
                    }
                    if (document.body && document.body.classList.contains('android-optimized')) {
                        document.body.classList.toggle('menu-visible', menuVisible);
                    }
                    
                    // Set initial status for CircuiTry
                    setStatus('CircuiTry Professional Circuit Design Environment Ready!');
                }, 0);
            }, 0);
        }

        // Auto-launch immediately to avoid getting stuck on splash
        window.addEventListener('load', () => {
            setTimeout(() => {
                launchApplication();
            }, 0);
        });

        // Long press detection functions
        function shouldAllowLongPress() {
            return !isRotateMode;
        }

        function startLongPressTimer(clientX, clientY) {
            cancelLongPress(); // Clear any existing timer
            
            longPressTimer = setTimeout(() => {
                isLongPressing = true;
                handleLongPress(clientX, clientY);
            }, LONG_PRESS_DURATION);
        }

        function cancelLongPress() {
            if (longPressTimer) {
                clearTimeout(longPressTimer);
                longPressTimer = null;
            }
            isLongPressing = false;
        }

        function handleLongPress(clientX, clientY) {
            if (!shouldAllowLongPress()) {
                cancelLongPress();
                return;
            }
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((clientY - rect.top) / rect.height) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            
            // Check for component selection boxes
            const selectionBoxes = [];
            components.forEach(comp => {
                if (comp?.selectionBox) {
                    selectionBoxes.push(comp.selectionBox);
                }
            });
            
            const componentHits = raycaster.intersectObjects(selectionBoxes, false);
            if (componentHits.length > 0) {
                const hitBox = componentHits[0].object;
                if (hitBox.userData?.component) {
                    showComponentContextMenu(hitBox.userData.component, clientX, clientY);
                    
                    // Add haptic feedback for mobile devices
                    if (navigator.vibrate && isMobile) {
                        navigator.vibrate(50);
                    }
                    return;
                }
            }
            
            // Check for junctions
            const selectionSpheres = [];
            junctions.forEach(junction => {
                if (junction?.selectionSphere) {
                    selectionSpheres.push(junction.selectionSphere);
                }
            });
            
            const junctionHits = raycaster.intersectObjects(selectionSpheres, false);
            if (junctionHits.length > 0) {
                const hitSphere = junctionHits[0].object;
                if (hitSphere.userData?.junction) {
                    // Junctions don't have editable properties currently
                    setStatus(' Junctions have no editable properties');
                    return;
                }
            }
            
            // Check for wires
            const wireHit = getWireHitAtScreenPosition(clientX, clientY);
            if (wireHit?.wire) {
                showWireEditPopup(wireHit.wire, clientX, clientY, wireHit.point);
                
                // Add haptic feedback for mobile devices
                if (navigator.vibrate && isMobile) {
                    navigator.vibrate(50);
                }
                return;
            }
        }
        
        function getNearestConnectionPointData(component, clientX, clientY) {
            if (!component?.connectionPoints?.length) {
                return null;
            }

            let closest = null;
            let minDistance = Infinity;

            component.connectionPoints.forEach(point => {
                if (!point?.userData) {
                    return;
                }

                const worldPosition = new THREE.Vector3();
                if (typeof point.getWorldPosition === 'function') {
                    point.getWorldPosition(worldPosition);
                } else if (component?.position) {
                    worldPosition.copy(component.position);
                }

                const screenPosition = worldToScreen(worldPosition);
                if (!screenPosition) {
                    return;
                }

                const dx = screenPosition.x - clientX;
                const dy = screenPosition.y - clientY;
                const distance = dx * dx + dy * dy;

                if (distance < minDistance) {
                    minDistance = distance;
                    closest = {
                        data: point.userData,
                        mesh: point
                    };
                }
            });

            return closest;
        }

        function ensureComponentContextMenu() {
            if (componentContextMenu) {
                return componentContextMenu;
            }

            const menu = document.createElement('div');
            menu.id = 'component-context-menu';
            menu.className = 'component-context-menu';
            menu.setAttribute('role', 'menu');
            menu.innerHTML = `
                <div class="component-menu-header">
                    <div class="component-menu-title"></div>
                    <div class="component-menu-description"></div>
                </div>
                <div class="component-menu-actions">
                    <button type="button" data-action="edit" role="menuitem">Edit Values</button>
                    <button type="button" data-action="wire" role="menuitem">Wire Edit</button>
                    <button type="button" data-action="rotate" role="menuitem">Rotate Component</button>
                </div>
            `;

            // Handle both click and touch events for mobile compatibility
            const handleMenuAction = (event) => {
                const action = event.target.closest('button')?.dataset?.action;
                if (!action) {
                    return;
                }
                event.preventDefault();
                event.stopPropagation(); // Prevent event from bubbling to global handlers
                handleComponentContextAction(action);
            };

            menu.addEventListener('click', handleMenuAction);
            menu.addEventListener('touchend', (event) => {
                // Prevent default to avoid double-firing with click
                const action = event.target.closest('button')?.dataset?.action;
                if (action) {
                    event.preventDefault();
                    event.stopPropagation();
                    handleComponentContextAction(action);
                }
            });

            document.body.appendChild(menu);
            componentContextMenu = menu;
            return menu;
        }

        function showComponentContextMenu(component, clientX, clientY) {
            if (!component) {
                return;
            }

            hideComponentContextMenu();
            const menu = ensureComponentContextMenu();

            componentContextTarget = component;
            selectComponent(component, { startDragging: false, silent: true });
            componentContextConnectionPoint = getNearestConnectionPointData(component, clientX, clientY);
            isLongPressing = false;

            const labelText = getComponentFriendlyName(component).toUpperCase();
            const description = getComponentDescription(component);
            setStatus(` ${labelText} actions - choose edit, wire edit, or rotate`);

            // Update menu header with component info
            const titleElement = menu.querySelector('.component-menu-title');
            const descElement = menu.querySelector('.component-menu-description');
            if (titleElement) {
                titleElement.textContent = labelText;
            }
            if (descElement) {
                descElement.textContent = description;
            }

            menu.dataset.visible = 'true';
            componentContextMenuCloseSuppressUntil = Date.now() + 350;
            menu.style.left = '0px';
            menu.style.top = '0px';

            const { offsetWidth, offsetHeight } = menu;
            const padding = 12;
            let left = clientX - offsetWidth / 2;
            let top = clientY - offsetHeight - 16;

            left = Math.max(padding, Math.min(window.innerWidth - offsetWidth - padding, left));
            top = Math.max(padding, Math.min(window.innerHeight - offsetHeight - padding, top));

            menu.style.left = `${left}px`;
            menu.style.top = `${top}px`;

            requestAnimationFrame(() => {
                const firstButton = menu.querySelector('button');
                if (firstButton) {
                    firstButton.focus({ preventScroll: true });
                }
            });
        }

        function hideComponentContextMenu() {
            if (!componentContextMenu) {
                componentContextTarget = null;
                componentContextConnectionPoint = null;
                return;
            }

            componentContextMenu.dataset.visible = 'false';
            componentContextTarget = null;
            componentContextConnectionPoint = null;
            componentContextMenuCloseSuppressUntil = 0;
        }

        function handleComponentContextAction(action) {
            if (!componentContextTarget) {
                hideComponentContextMenu();
                return;
            }

            const component = componentContextTarget;
            const connectionPoint = componentContextConnectionPoint;
            hideComponentContextMenu();

            switch (action) {
                case 'edit':
                    showEditPopup(component);
                    break;
                case 'rotate':
                    rotateComponent(component, { animate: true, silent: false });
                    break;
                case 'wire':
                    enableWireMode({ silent: true });
                    if (connectionPoint?.data) {
                        handleConnectionPointClick(connectionPoint.data);
                    } else {
                        setStatus(' WIRE MODE! Touch terminals to connect, or tap any wire run to drop a junction branch.');
                    }
                    break;
                default:
                    break;
            }
        }
        
        function projectPointOntoWireSegment(point, segmentStart, segmentEnd) {
            if (!point || !segmentStart || !segmentEnd) {
                return null;
            }

            const segmentVector = new THREE.Vector3().subVectors(segmentEnd, segmentStart);
            const lengthSquared = segmentVector.lengthSq();

            if (lengthSquared < 1e-8) {
                return segmentStart.clone();
            }

            const pointVector = new THREE.Vector3().subVectors(point, segmentStart);
            const t = Math.max(0, Math.min(1, pointVector.dot(segmentVector) / lengthSquared));
            const projected = segmentStart.clone().add(segmentVector.multiplyScalar(t));
            projected.y = 0;
            return projected;
        }

        function findNearestJunctionByPosition(position, maxDistance = JUNCTION_REUSE_RADIUS) {
            if (!position || !Array.isArray(junctions) || junctions.length === 0) {
                return null;
            }

            let nearest = null;
            let nearestDistance = maxDistance;

            junctions.forEach(junction => {
                if (!junction?.position?.distanceTo) {
                    return;
                }

                const candidateDistance = junction.position.distanceTo(position);
                if (candidateDistance <= nearestDistance) {
                    nearest = junction;
                    nearestDistance = candidateDistance;
                }
            });

            return nearest;
        }

        function getWireHitAtScreenPosition(clientX, clientY) {
            if (!renderer?.domElement || !raycaster || !camera) {
                return null;
            }

            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((clientY - rect.top) / rect.height) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);

            const wireMeshes = [];
            const segmentLookup = new Map();
            wires.forEach(wire => {
                if (!wire?.segments?.length) {
                    return;
                }
                wire.segments.forEach(segment => {
                    if (!segment?.mesh) {
                        return;
                    }
                    wireMeshes.push(segment.mesh);
                    segmentLookup.set(segment.mesh, { wire, segment });
                });
            });

            if (wireMeshes.length === 0) {
                return null;
            }

            const hits = raycaster.intersectObjects(wireMeshes, false);
            for (const hit of hits) {
                const mapping = segmentLookup.get(hit.object);
                if (!mapping?.segment) {
                    continue;
                }

                const point = projectPointOntoWireSegment(
                    hit.point,
                    mapping.segment.start,
                    mapping.segment.end
                );

                if (!point) {
                    continue;
                }

                return {
                    wire: mapping.wire,
                    segment: mapping.segment,
                    point
                };
            }

            return null;
        }

        function getWireMidpoint(wire) {
            if (!wire?.segments?.length) {
                return null;
            }

            const segment = wire.segments[Math.floor(wire.segments.length / 2)];
            if (!segment?.start || !segment?.end) {
                return null;
            }

            return new THREE.Vector3()
                .addVectors(segment.start, segment.end)
                .multiplyScalar(0.5);
        }

        function getWireBranchStartPointData(junction) {
            if (!junction) {
                return null;
            }

            if (junction?.connectionPoint?.userData) {
                return junction.connectionPoint.userData;
            }

            return {
                junction,
                isConnectionPoint: true,
                side: 'center',
                polarity: 'neutral'
            };
        }

        // Wire edit popup
        function showWireEditPopup(wire, clientX, clientY, splitPoint) {
            const popup = document.getElementById('wire-edit-popup');
            if (!popup) {
                // Create popup if it doesn't exist
                createWireEditPopup();
                return showWireEditPopup(wire, clientX, clientY, splitPoint);
            }
            
            currentEditWire = wire;
            currentEditWireHitPoint = splitPoint?.clone ? splitPoint.clone() : null;
            popup.style.display = 'block';
            
            setStatus(' Wire selected - Choose action');
        }
        
        function createWireEditPopup() {
            const popup = document.createElement('div');
            popup.id = 'wire-edit-popup';
            popup.className = 'edit-popup';
            popup.style.display = 'none';
            popup.innerHTML = `
                <div class="edit-popup-content">
                    <div class="edit-popup-header">
                        <h3>Edit Wire</h3>
                        <button onclick="closeWireEditPopup()" class="edit-close">X</button>
                    </div>
                    <div class="edit-actions">
                        <button onclick="addJunctionBranchFromPopup()" class="edit-action-btn">Drop Junction Branch</button>
                        <button onclick="changeWireRoutingFromPopup()" class="edit-action-btn">Change Routing</button>
                        <button onclick="deleteWireFromPopup()" class="edit-action-btn delete-btn">Delete Wire</button>
                    </div>
                </div>
            `;
            document.body.appendChild(popup);
        }
        
        function closeWireEditPopup() {
            const popup = document.getElementById('wire-edit-popup');
            if (popup) {
                popup.style.display = 'none';
            }
            currentEditWire = null;
            currentEditWireHitPoint = null;
        }
        
        function deleteWireFromPopup() {
            if (currentEditWire) {
                saveState(); // Save for undo
                currentEditWire.remove();
                const index = wires.indexOf(currentEditWire);
                if (index > -1) {
                    wires.splice(index, 1);
                }
                analyzeCircuit();
                setStatus(' Wire deleted');
            }
            closeWireEditPopup();
        }
        
        function changeWireRoutingFromPopup() {
            if (currentEditWire) {
                saveState(); // Save for undo
                // Cycle to next routing mode and update wire
                cycleRoutingMode();
                currentEditWire.updatePath();
                setStatus(' Wire routing updated');
            }
            closeWireEditPopup();
        }

        function addJunctionBranchFromPopup() {
            const wire = currentEditWire;
            const splitPoint = currentEditWireHitPoint?.clone
                ? currentEditWireHitPoint.clone()
                : getWireMidpoint(wire);
            const hadWireStart = Boolean(wireStart);

            closeWireEditPopup();

            if (!wire || !splitPoint) {
                setStatus(' Unable to locate the selected wire segment.');
                return;
            }

            enableWireMode({ silent: true });

            const junction = splitWireWithJunction(wire, splitPoint, {
                saveSnapshot: true,
                snapToGridPosition: false,
                suppressStatus: true
            });

            if (!junction) {
                setStatus(' Unable to place a junction at that location.');
                return;
            }

            const pointData = getWireBranchStartPointData(junction);
            if (!pointData) {
                setStatus(' Junction created, but branch start failed.');
                return;
            }

            handleConnectionPointClick(pointData);

            if (!hadWireStart && wireStart) {
                setStatus(' Junction added on wire. Click another terminal or junction to finish the branch.');
            }
        }
        
        // Variable to track current wire being edited
        let currentEditWire = null;
        let currentEditWireHitPoint = null;

        // Edit popup functions
        function showEditPopup(component, clientX, clientY) {
            currentEditComponent = component;
            const popup = document.getElementById('edit-popup');
            const title = document.getElementById('edit-title');
            const content = document.getElementById('edit-content');
            
            if (!popup || !title || !content) return;
            
            // Set title
            title.textContent = `Edit ${component.type.charAt(0).toUpperCase() + component.type.slice(1)}`;
            
            // Create edit form based on component type
            content.innerHTML = createEditForm(component);
            
            // Show popup centered on screen for mobile
            popup.style.display = 'block';
            
            // Focus first input with delay for mobile keyboards
            const firstInput = popup.querySelector('input');
            if (firstInput && !isMobile) {
                setTimeout(() => firstInput.focus(), 100);
            }
            
            setStatus(` Editing ${component.type} - Long press to edit components!`);
        }

        function createEditForm(component) {
            let formHTML = '';
            
            switch (component.type) {
                case 'battery':
                    formHTML = `
                        <div class="edit-row">
                            <label>Voltage (V)</label>
                            <input type="number" id="edit-voltage" value="${component.properties.voltage}" min="0" max="24" step="0.1">
                        </div>
                    `;
                    break;
                    
                case 'resistor':
                    formHTML = `
                        <div class="edit-row">
                            <label>? Resistance (?)</label>
                            <input type="number" id="edit-resistance" value="${component.properties.resistance}" min="1" max="10000" step="1">
                        </div>
                    `;
                    break;
                    
                case 'led':
                    formHTML = `
                        <div class="edit-row">
                            <label>? Forward Resistance (?)</label>
                            <input type="number" id="edit-resistance" value="${component.properties.resistance}" min="1" max="1000" step="1">
                        </div>
                    `;
                    break;
                    
                case 'switch':
                    formHTML = `
                        <div class="edit-row">
                            <label> Switch State</label>
                            <select id="edit-switch-state">
                                <option value="true" ${component.properties.isOn ? 'selected' : ''}>ON (Closed)</option>
                                <option value="false" ${!component.properties.isOn ? 'selected' : ''}>OFF (Open)</option>
                            </select>
                        </div>
                        <div class="edit-row">
                            <label>? Contact Resistance (?)</label>
                            <input type="number" id="edit-resistance" value="${component.properties.resistance}" min="0.01" max="10" step="0.01">
                        </div>
                    `;
                    break;
                    
                default:
                    formHTML = '<div class="edit-row">No editable properties</div>';
            }
            
            return formHTML;
        }

        function saveEdit() {
            if (!currentEditComponent) return;
            
            const popup = document.getElementById('edit-popup');
            if (!popup) return;
            
            saveState(); // Save for undo
            
            const newProperties = {};
            
            switch (currentEditComponent.type) {
                case 'battery':
                    const voltageInput = document.getElementById('edit-voltage');
                    if (voltageInput) {
                        newProperties.voltage = parseFloat(voltageInput.value) || 0;
                    }
                    break;
                    
                case 'resistor':
                case 'led':
                    const resistanceInput = document.getElementById('edit-resistance');
                    if (resistanceInput) {
                        newProperties.resistance = parseFloat(resistanceInput.value) || 1;
                    }
                    break;
                    
                case 'switch':
                    const switchStateSelect = document.getElementById('edit-switch-state');
                    const switchResistanceInput = document.getElementById('edit-resistance');
                    if (switchStateSelect) {
                        newProperties.isOn = switchStateSelect.value === 'true';
                    }
                    if (switchResistanceInput) {
                        newProperties.resistance = parseFloat(switchResistanceInput.value) || 0.1;
                    }
                    break;
            }
            
            // Update component properties
            currentEditComponent.updateProperties(newProperties);
            
            // Hide popup
            hideEditPopup();
            
            // Recalculate circuit
            analyzeCircuit();
            
            const componentType = currentEditComponent.type;
            setStatus(`? ${componentType.charAt(0).toUpperCase() + componentType.slice(1)} updated successfully!`);
        }

        function cancelEdit() {
            hideEditPopup();
            setStatus(' Edit cancelled');
        }

        function hideEditPopup() {
            const popup = document.getElementById('edit-popup');
            if (popup) {
                popup.style.display = 'none';
            }
            currentEditComponent = null;
        }

        function checkComponentHit(clientX, clientY) {
            // If we're in the middle of a long press, don't handle regular clicks
            if (isLongPressing) {
                return false;
            }
            
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((clientY - rect.top) / rect.height) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            
            // Check connection points
            const connectionPoints = [];
            components.forEach(comp => {
                if (comp?.connectionPoints) {
                    connectionPoints.push(...comp.connectionPoints);
                }
            });
            junctions.forEach(junction => {
                if (junction?.connectionPoint) {
                    connectionPoints.push(junction.connectionPoint);
                }
            });
            
            const connectionHits = raycaster.intersectObjects(connectionPoints, false);
            if (connectionHits.length > 0) {
                const hitPoint = connectionHits[0].object;
                if (hitPoint.userData?.isConnectionPoint) {
                    if (isMeasureMode) {
                        let worldPos = null;
                        if (typeof hitPoint.getWorldPosition === 'function') {
                            worldPos = new THREE.Vector3();
                            hitPoint.getWorldPosition(worldPos);
                        } else {
                            worldPos = screenToWorld(clientX, clientY);
                        }
                        if (worldPos) {
                            handleMeasurementPoint(worldPos);
                            return true;
                        }
                    } else {
                        handleConnectionPointClick(hitPoint.userData);
                        return true;
                    }
                }
            }

            if (isWireMode) {
                const wireHit = getWireHitAtScreenPosition(clientX, clientY);
                if (wireHit?.wire && wireHit.point) {
                    const hadWireStart = Boolean(wireStart);
                    const junction = splitWireWithJunction(wireHit.wire, wireHit.point, {
                        saveSnapshot: true,
                        snapToGridPosition: false,
                        suppressStatus: true
                    });

                    if (junction) {
                        const pointData = getWireBranchStartPointData(junction);
                        if (pointData) {
                            handleConnectionPointClick(pointData);
                            if (!hadWireStart && wireStart) {
                                setStatus(' Junction dropped on wire. Click another terminal or junction to complete the branch.');
                            }
                            return true;
                        }
                    }
                }
            }
            
            // Check component selection boxes
            if (!isWireMode) {
                const selectionBoxes = [];
                components.forEach(comp => {
                    if (comp?.selectionBox) {
                        selectionBoxes.push(comp.selectionBox);
                    }
                });
                junctions.forEach(junction => {
                    if (junction?.selectionSphere) {
                        selectionBoxes.push(junction.selectionSphere);
                    }
                });
                
                const componentHits = raycaster.intersectObjects(selectionBoxes, false);
                if (componentHits.length > 0) {
                    const hitBox = componentHits[0].object;
                    if (hitBox.userData?.component) {
                        if (isMeasureMode) {
                            const worldPos = screenToWorld(clientX, clientY);
                            if (worldPos) {
                                handleMeasurementPoint(worldPos);
                                return true;
                            }
                        } else {
                            handleComponentClick(hitBox.userData.component);
                            return true;
                        }
                    }
                    if (hitBox.userData?.junction) {
                        if (isMeasureMode) {
                            const worldPos = screenToWorld(clientX, clientY);
                            if (worldPos) {
                                handleMeasurementPoint(worldPos);
                                return true;
                            }
                        } else {
                            handleJunctionClick(hitBox.userData.junction);
                            return true;
                        }
                    }
                }
            }

            if (!isWireMode) {
                const componentMeshes = components
                    .map(comp => comp?.mesh)
                    .filter(mesh => Boolean(mesh));

                if (componentMeshes.length > 0) {
                    const meshHits = raycaster.intersectObjects(componentMeshes, true);
                    for (const hit of meshHits) {
                        let owner = hit.object;
                        while (owner && !owner.userData?.component && !owner.userData?.junction) {
                            owner = owner.parent;
                        }

                        if (!owner) {
                            continue;
                        }

                        if (owner.userData?.component) {
                            if (isMeasureMode) {
                                const worldPos = screenToWorld(clientX, clientY);
                                if (worldPos) {
                                    handleMeasurementPoint(worldPos);
                                    return true;
                                }
                            } else {
                                handleComponentClick(owner.userData.component);
                                return true;
                            }
                        }

                        if (owner.userData?.junction) {
                            if (isMeasureMode) {
                                const worldPos = screenToWorld(clientX, clientY);
                                if (worldPos) {
                                    handleMeasurementPoint(worldPos);
                                    return true;
                                }
                            } else {
                                handleJunctionClick(owner.userData.junction);
                                return true;
                            }
                        }
                    }
                }
            }
            
            if (isMeasureMode) {
                const worldPos = screenToWorld(clientX, clientY);
                if (worldPos) {
                    handleMeasurementPoint(worldPos);
                    return true;
                }
                return false;
            }

            handleGroundClick(clientX, clientY);
            return false;
        }

        function handleConnectionPointClick(pointData) {
            if (!isWireMode && meterArmed) {
                handleMeterProbeClick(pointData);
                return;
            }
            if (!isWireMode) {
                const terminalInfo = getTerminalInfo(pointData);
                const objectType = pointData.component ? pointData.component.type : 'junction';
                setStatus(` ${objectType} ${terminalInfo} - Enable  Wire mode to connect!`);
                return;
            }
            
            if (!wireStart) {
                wireStart = pointData;
                highlightConnectionPoint(pointData, true);
                
                const terminalInfo = getTerminalInfo(pointData);
                const objectType = pointData.component ? pointData.component.type : 'junction';
                setStatus(` FIRST: ${objectType} ${terminalInfo} - Click another terminal!`);
                
            } else {
                const sameObject = (wireStart.component && pointData.component && wireStart.component === pointData.component) ||
                                  (wireStart.junction && pointData.junction && wireStart.junction === pointData.junction);
                
                if (sameObject) {
                    setStatus(' Cannot connect terminal to itself!');
                    return;
                }
                
                createWire(wireStart, pointData);
                highlightConnectionPoint(wireStart, false);
                wireStart = null;
            }
        }

        function createWire(startPoint, endPoint) {
            if (!startPoint || !endPoint) return;
            
            const startObj = startPoint.component || startPoint.junction;
            const endObj = endPoint.component || endPoint.junction;
            
            if (!startObj || !endObj) return;
            
            const existingWire = wires.find(wire => 
                (wire.startObj === startObj && wire.startSide === startPoint.side &&
                 wire.endObj === endObj && wire.endSide === endPoint.side) ||
                (wire.startObj === endObj && wire.startSide === endPoint.side &&
                 wire.endObj === startObj && wire.endSide === startPoint.side)
            );
            
            if (existingWire) {
                setStatus(' Wire already exists between these terminals');
                return;
            }
            
            try {
                saveState(); // Save for undo
                const wire = new Wire(startObj, startPoint.side, endObj, endPoint.side);
                wires.push(wire);
                
                const startType = startObj.type || 'junction';
                const endType = endObj.type || 'junction';
                setStatus(` Wire connected ${startType}  ${endType}!`);
                
                analyzeCircuit();
                
            } catch (error) {
                console.error('Wire creation error:', error);
                setStatus(' Wire creation failed');
            }
        }

        function getTerminalInfo(pointData) {
            if (pointData.junction) return 'JUNCTION (PURPLE)';
            
            switch (pointData.polarity) {
                case 'positive': return 'POSITIVE (RED)';
                case 'negative': return 'NEGATIVE (GRAY)';
                default: return 'NEUTRAL (WHITE)';
            }
        }

        function highlightConnectionPoint(pointData, highlight) {
            let connectionPoint;
            
            if (pointData.component) {
                connectionPoint = pointData.component.connectionPoints?.find(point => 
                    point.userData?.side === pointData.side
                );
            } else if (pointData.junction) {
                connectionPoint = pointData.junction.connectionPoint;
            }
            
            if (!connectionPoint?.material) return;
            
            if (highlight) {
                connectionPoint.material.color.setRGB(1.0, 1.0, 0.0);
                connectionPoint.material.emissive.setRGB(0.8, 0.8, 0.0);
                connectionPoint.scale.setScalar(2.0);
            } else {
                if (pointData.junction) {
                    connectionPoint.material.color.setRGB(0.67, 0.4, 1.0);
                    connectionPoint.material.emissive.setRGB(0.2, 0.1, 0.4);
                } else {
                    const originalColor = getOriginalColor(pointData.polarity);
                    connectionPoint.material.color.copy(originalColor);
                    setOriginalEmissive(connectionPoint, pointData.polarity);
                }
                connectionPoint.scale.setScalar(1.0);
            }
        }

        function getOriginalColor(polarity) {
            switch (polarity) {
                case 'positive': return new THREE.Color(1, 0, 0);
                case 'negative': return new THREE.Color(0.3, 0.3, 0.3);
                default: return new THREE.Color(1, 1, 1);
            }
        }

        function setOriginalEmissive(point, polarity) {
            switch (polarity) {
                case 'positive':
                    point.material.emissive.setRGB(0.3, 0.0, 0.0);
                    break;
                case 'negative':
                    point.material.emissive.setRGB(0.1, 0.1, 0.1);
                    break;
                default:
                    point.material.emissive.setRGB(0.2, 0.2, 0.2);
            }
        }

        function normalizeAngle(angle) {
            if (!Number.isFinite(angle)) {
                return 0;
            }
            const twoPi = Math.PI * 2;
            let normalized = angle % twoPi;
            if (normalized < 0) {
                normalized += twoPi;
            }
            return normalized;
        }

        function rotateComponent(component, options = {}) {
            if (!component || !component.mesh) {
                return;
            }

            const { animate = true, silent = false } = options;
            saveState(); // Save for undo

            const rotationAmount = Math.PI / 2;
            const nextRotation = normalizeAngle((component.rotation || 0) + rotationAmount);

            component.rotation = nextRotation;
            component.mesh.rotation.y = nextRotation;

            if (animate && component.mesh?.scale) {
                component.mesh.scale.setScalar(1.5);
                setTimeout(() => {
                    if (component.mesh?.scale) {
                        component.mesh.scale.setScalar(1.0);
                    }
                }, 400);
            }

            if (component.connections) {
                component.connections.forEach(conn => {
                    if (conn?.wire?.updatePath) {
                        conn.wire.updatePath();
                    }
                });
            }

            analyzeCircuit();

            if (!silent) {
                const rotationDegrees = Math.round((nextRotation * 180) / Math.PI) % 360;
                setStatus(` ${component.type.toUpperCase()} ROTATED 90! Now at ${rotationDegrees}`);
            }
        }

        function handleComponentClick(component) {
            hideComponentContextMenu();

            if (meterArmed && meterMode === 'current' && !isWireMode && !isRotateMode && !isMeasureMode) {
                meterCurrentTarget = component;
                updateMeterUI();
                const label = component?.id ? `${component.type}:${component.id}` : (component?.type || 'component');
                setStatus(` Current probe set to ${label}`);
                return;
            }

            if (isRotateMode) {
                rotateComponent(component);

            } else if (component.type === 'switch' && !isWireMode) {
                saveState(); // Save for undo
                component.properties.isOn = !component.properties.isOn;
                component.updateProperties({ isOn: component.properties.isOn });
                const state = component.properties.isOn ? 'ON' : 'OFF';
                setStatus(`  Switch ${state} - circuit updated`);
                analyzeCircuit();
            } else if (!isWireMode && !isDragging) {
                selectComponent(component, { startDragging: false });
            }
        }

        function handleJunctionClick(junction) {
            hideComponentContextMenu();

            if (!isWireMode && !isDragging) {
                selectJunction(junction, { startDragging: false });
            }
        }

        function selectComponent(component, options = {}) {
            if (!component) {
                return;
            }

            const { startDragging = false, silent = false } = options;
            selectedComponent = component;
            isDragging = Boolean(startDragging);

            if (silent) {
                return;
            }

            const label = getComponentFriendlyName(component);
            if (isDragging) {
                setStatus(`  Dragging ${label} - drag to position and tap to place`);
            } else {
                setStatus(`  ${label} selected - drag to move or long-press for actions`);
            }
        }

        function selectJunction(junction, options = {}) {
            if (!junction) {
                return;
            }

            const { startDragging = false, silent = false } = options;
            selectedComponent = junction;
            isDragging = Boolean(startDragging);

            if (silent) {
                return;
            }

            const label = getComponentFriendlyName(junction);
            if (isDragging) {
                setStatus(`  Dragging ${label} - drag to position and tap to place`);
            } else {
                setStatus(`  ${label} selected - drag to move or long-press for options`);
            }
        }

        function maybeStartDrag(clientX, clientY) {
            if (!selectedComponent || isDragging || isWireMode || isMeasureMode) {
                return;
            }

            const deltaX = Math.abs(clientX - longPressStartPos.x);
            const deltaY = Math.abs(clientY - longPressStartPos.y);
            if (deltaX < COMPONENT_DRAG_THRESHOLD && deltaY < COMPONENT_DRAG_THRESHOLD) {
                return;
            }

            const wasRotateMode = isRotateMode;
            if (wasRotateMode) {
                disableRotateMode({ silent: true, skipNotify: true, skipCloseMenus: true });
            }

            isDragging = true;
            cancelLongPress();
            hideComponentContextMenu();

            const label = getComponentFriendlyName(selectedComponent);
            if (wasRotateMode) {
                setStatus(`  Rotate mode paused - dragging ${label}. Tap Rotate again to resume.`);
                notifyParentToolState('select');
            } else {
                setStatus(`  Dragging ${label} - drag to position and tap to place`);
            }
        }

        function getComponentFriendlyName(entity) {
            if (!entity) {
                return 'component';
            }

            if (entity.type) {
                const type = String(entity.type);
                if (type.length <= 4) {
                    return type.toUpperCase();
                }
                return type.charAt(0).toUpperCase() + type.slice(1);
            }

            if (entity.id && entity.id.startsWith('junction')) {
                return 'junction';
            }

            return 'component';
        }

        function getComponentDescription(entity) {
            if (!entity || !entity.type) {
                return '';
            }

            const descriptions = {
                'battery': 'Provides voltage to power circuits. Energy source that pushes electrons through the circuit.',
                'resistor': 'Limits current flow and reduces voltage. Creates heat to control electrical energy.',
                'led': 'Light Emitting Diode that glows when current flows in the correct direction.',
                'switch': 'Opens or closes the circuit path. Controls when current can flow through.',
                'capacitor': 'Stores electrical energy temporarily. Charges and discharges in AC circuits.',
                'inductor': 'Resists changes in current using magnetic fields. Stores energy magnetically.',
                'diode': 'Allows current to flow in one direction only. Acts as a one-way electrical valve.',
                'bjt': 'Bipolar Junction Transistor. Amplifies or switches current using a small base signal.',
                'mosfet': 'Metal-Oxide-Semiconductor transistor. Controls current with voltage, used in modern circuits.',
                'fuse': 'Safety device that breaks circuit if current is too high. Protects against overload.',
                'potentiometer': 'Variable resistor with adjustable resistance. Used for volume, brightness, and tuning.',
                'lamp': 'Converts electrical energy to light and heat. Visual indicator or light source.',
                'ground': 'Reference point for voltage. Completes the circuit and provides safety path.'
            };

            return descriptions[entity.type] || '';
        }

        function handleGroundClick(clientX, clientY) {
            if (!isWireMode) {
                const worldPos = screenToWorld(clientX, clientY);
                if (worldPos && selectedComponent && isDragging) {
                    const snappedPos = snapToGrid(worldPos);
                    
                    if (selectedComponent.mesh) {
                        selectedComponent.mesh.position.copy(snappedPos);
                        selectedComponent.position.copy(snappedPos);
                    }
                    
                    const placedComponent = selectedComponent;
                    handleRelease();
                    
                    const objType = placedComponent.type || 'junction';
                    setStatus(`  ${objType} placed at grid position!`);
                    
                    if (placedComponent.connections) {
                        placedComponent.connections.forEach(conn => {
                            if (conn.wire && conn.wire.updatePath) {
                                conn.wire.updatePath();
                            }
                        });
                    }
                }
            }
        }

        function screenToWorld(clientX, clientY) {
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((clientY - rect.top) / rect.height) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            
            const groundPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
            const intersection = new THREE.Vector3();
            
            if (raycaster.ray.intersectPlane(groundPlane, intersection)) {
                return intersection;
            }
            return null;
        }

        function handleComponentDrag(clientX, clientY) {
            const worldPos = screenToWorld(clientX, clientY);
            if (worldPos && selectedComponent) {
                const snappedPos = snapToGrid(worldPos);
                showSnapIndicator(snappedPos);
                
                if (selectedComponent.mesh) {
                    selectedComponent.mesh.position.copy(snappedPos);
                    selectedComponent.position.copy(snappedPos);
                }
            }
        }

        function handleRelease() {
            isDragging = false;
            hideSnapIndicator();
            
            if (selectedComponent) {
                // Final snap to grid
                const snappedPos = snapToGrid(selectedComponent.position);
                selectedComponent.position.copy(snappedPos);
                if (selectedComponent.mesh) {
                    selectedComponent.mesh.position.copy(snappedPos);
                }
                
                // Update any connected wires
                if (selectedComponent.connections) {
                    selectedComponent.connections.forEach(conn => {
                        if (conn.wire && conn.wire.updatePath) {
                            conn.wire.updatePath();
                        }
                    });
                }
            }
            
            selectedComponent = null;
        }

        // Menu system functions
        function toggleMenuBar() {
            const menuBar = document.getElementById('menu-bar');
            const toggle = document.getElementById('menu-toggle');
            
            if (!menuBar || !toggle) return;
            
            menuBar.classList.toggle('hidden');
            menuVisible = !menuVisible;
            toggle.classList.toggle('open', menuVisible);
            if (document.body && document.body.classList.contains('android-optimized')) {
                document.body.classList.toggle('menu-visible', menuVisible);
            }
            
            if (menuVisible) {
                toggle.textContent = 'Close';
                setStatus('Menu shown - all tools available');
            } else {
                toggle.textContent = 'Menu';
                setStatus('Menu hidden - tap Menu to open');
                closeAllSubmenus();
            }
        }

        function toggleSubmenu(menuName) {
            const allSubmenus = document.querySelectorAll('.submenu');
            const targetSubmenu = document.getElementById(`submenu-${menuName}`);
            const allTabs = document.querySelectorAll('.menu-tab');
            
            // Close all other submenus
            allSubmenus.forEach(submenu => {
                if (submenu !== targetSubmenu) {
                    submenu.classList.remove('active');
                }
            });
            
            // Remove active class from all tabs
            allTabs.forEach(tab => {
                if (!tab.querySelector(`#submenu-${menuName}`)) {
                    tab.classList.remove('active');
                }
            });
            
            // Toggle target submenu
            if (targetSubmenu) {
                const isActive = targetSubmenu.classList.contains('active');
                targetSubmenu.classList.toggle('active');
                
                // Toggle tab active state
                const parentTab = targetSubmenu.closest('.menu-tab');
                if (parentTab) {
                    parentTab.classList.toggle('active', !isActive);
                }
            }
        }

        function exportArenaPayload() {
            try {
                const currentStateString = getCurrentStateString();
                if (!currentStateString) {
                    return null;
                }

                const state = JSON.parse(currentStateString);
                const summary = state.components.reduce((acc, component) => {
                    const key = component.type || 'unknown';
                    acc.byType[key] = (acc.byType[key] || 0) + 1;
                    return acc;
                }, {
                    totalComponents: state.components.length,
                    totalWires: state.wires.length,
                    totalJunctions: state.junctions.length,
                    byType: {}
                });

                const safeMetric = (value) => (Number.isFinite(value) ? Number(value) : null);

                return {
                    version: '1.0',
                    source: 'builder',
                    generatedAt: Date.now(),
                    metrics: {
                        voltage: safeMetric(lastKnownValues?.voltage),
                        current: safeMetric(lastKnownValues?.current),
                        resistance: safeMetric(lastKnownValues?.resistance),
                        power: safeMetric(lastKnownValues?.power)
                    },
                    summary,
                    state
                };
            } catch (error) {
                console.warn('Arena payload export failed', error);
                return null;
            }
        }

        function openArena() {
            try {
                const summary = exportArenaSession({ openWindow: true });
                const payload = exportArenaPayload();
                let payloadStored = false;

                if (payload && typeof localStorage !== 'undefined') {
                    try {
                        localStorage.setItem(ARENA_STORAGE_KEY, JSON.stringify(payload));
                        payloadStored = true;
                    } catch (storageError) {
                        console.warn('Arena payload storage failed', storageError);
                    }
                }

                if (summary) {
                    const count = summary.componentCount || 0;
                    const message = `?? Component Arena export ready (${count} component${count === 1 ? '' : 's'})`;
                    setStatus(payloadStored ? message : `${message} (quick sync unavailable)`);
                } else if (payloadStored) {
                    setStatus(' Component Arena opened with current build');
                } else {
                    setStatus(' Unable to prepare arena export');
                }
            } catch (error) {
                console.error('Arena export error:', error);
                setStatus(' Unable to open Arena');
            }
        }

        function closeAllSubmenus() {
            document.querySelectorAll('.submenu').forEach(submenu => {
                submenu.classList.remove('active');
            });
            document.querySelectorAll('.menu-tab').forEach(tab => {
                tab.classList.remove('active');
            });
        }

        const subscriptionPricingState = {
            overlay: null,
            backdrop: null,
            activeCycle: 'annual',
            cycleButtons: []
        };

        function setupSubscriptionPricing() {
            if (subscriptionPricingState.overlay && subscriptionPricingState.backdrop) {
                return;
            }

            const overlay = document.getElementById('subscription-pricing-overlay');
            const backdrop = document.getElementById('subscription-pricing-backdrop');

            if (!overlay || !backdrop) {
                return;
            }

            subscriptionPricingState.overlay = overlay;
            subscriptionPricingState.backdrop = backdrop;
            subscriptionPricingState.cycleButtons = Array.from(
                overlay.querySelectorAll('.subscription-cycle-btn')
            );

            backdrop.addEventListener('click', closeSubscriptionPricing);
        }

        function syncSubscriptionCycleButtons(cycle) {
            if (!subscriptionPricingState.cycleButtons.length) {
                return;
            }

            subscriptionPricingState.cycleButtons.forEach(button => {
                const isActive = button.dataset.cycle === cycle;
                button.classList.toggle('active', isActive);
                button.setAttribute('aria-pressed', isActive ? 'true' : 'false');
            });
        }

        function setSubscriptionPricingCycle(cycle) {
            if (cycle !== 'monthly' && cycle !== 'annual') {
                cycle = 'annual';
            }

            if (!subscriptionPricingState.overlay || !subscriptionPricingState.backdrop) {
                setupSubscriptionPricing();
            }

            subscriptionPricingState.activeCycle = cycle;

            const overlay = subscriptionPricingState.overlay;
            if (!overlay) {
                return;
            }

            overlay.setAttribute('data-active-cycle', cycle);
            syncSubscriptionCycleButtons(cycle);
        }

        function openSubscriptionPricing() {
            if (!subscriptionPricingState.overlay || !subscriptionPricingState.backdrop) {
                setupSubscriptionPricing();
            }

            const { overlay, backdrop } = subscriptionPricingState;
            if (!overlay || !backdrop) {
                return;
            }

            closeAllSubmenus();
            overlay.classList.add('visible');
            backdrop.classList.add('visible');
            document.body.classList.add('subscription-pricing-open');
            setSubscriptionPricingCycle(subscriptionPricingState.activeCycle);
            overlay.focus({ preventScroll: true });
        }

        function closeSubscriptionPricing() {
            const { overlay, backdrop } = subscriptionPricingState;
            if (!overlay || !backdrop) {
                return;
            }

            overlay.classList.remove('visible');
            backdrop.classList.remove('visible');
            document.body.classList.remove('subscription-pricing-open');
        }

        function contactSubscriptionTeam() {
            window.location.href = 'mailto:hello@circuitry3d.com?subject=CircuiTry3D%20Subscription%20Planning';
        }

        function startSandboxFromPricing() {
            closeSubscriptionPricing();
            if (!menuVisible) {
                toggleMenuBar();
            }
            setStatus(' Sandbox ready - choose a component to begin building!');
        }

        function launchStripeComingSoon(sku) {
            console.info('Stripe checkout pending integration', { sku });
            alert('Stripe checkout coming soon. Contact us to activate your subscription.');
        }

        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', setupSubscriptionPricing, { once: true });
        } else {
            setupSubscriptionPricing();
        }

        document.addEventListener('keydown', event => {
            if (event.key === 'Escape' && subscriptionPricingState.overlay?.classList.contains('visible')) {
                closeSubscriptionPricing();
            }
        });

        function toggleAnalysis() {
            const panel = document.getElementById('wire-analysis');
            if (!panel) {
                notifyParentAnalysisState();
                return;
            }
            
            panel.classList.toggle('collapsed');
            analysisVisible = !panel.classList.contains('collapsed');
            
            if (analysisVisible) {
                setStatus(' W.I.R.E. Analysis panel expanded');
            } else {
                setStatus(' W.I.R.E. Analysis panel collapsed');
            }

            notifyParentAnalysisState();
        }

        function openMeasurementTools() {
            const panel = document.getElementById('wire-analysis');
            if (panel && panel.classList.contains('collapsed')) {
                panel.classList.remove('collapsed');
            }
            analysisVisible = true;
            notifyParentAnalysisState();
            switchAnalysisTab('meter');
            if (!meterArmed) {
                meterArmed = true;
            }
            updateMeterUI();
            setStatus(' Measurement tools ready - click terminals to probe');
        }

        function setMeterMode(nextMode) {
            const mode = String(nextMode || '').toLowerCase();
            if (mode !== 'voltage' && mode !== 'current' && mode !== 'resistance' && mode !== 'scope') {
                return;
            }
            meterMode = mode;
            meterCurrentTarget = null;
            updateMeterUI();
        }

        function toggleMeterArmed() {
            meterArmed = !meterArmed;
            if (!meterArmed) {
                stopScope();
            } else if (meterMode === 'scope') {
                startScope();
            }
            updateMeterUI();
        }

        function clearMeterSelection() {
            if (meterProbeA) restoreConnectionPointVisual(meterProbeA);
            if (meterProbeB) restoreConnectionPointVisual(meterProbeB);
            meterProbeA = null;
            meterProbeB = null;
            meterCurrentTarget = null;
            scopeBuffer = [];
            updateMeterUI();
        }

        function updateMeterButtonStates() {
            const ids = ['voltage', 'current', 'resistance', 'scope'];
            ids.forEach(id => {
                const btn = document.getElementById(`meter-mode-${id}`);
                if (!btn) return;
                const active = meterMode === id;
                btn.classList.toggle('secondary', !active);
            });
            const armedBtn = document.getElementById('meter-toggle-armed');
            if (armedBtn) {
                armedBtn.textContent = meterArmed ? 'Disable probes' : 'Enable probes';
            }
        }

        function describeTerminal(pointData) {
            if (!pointData) return '';
            const obj = pointData.component || pointData.junction;
            if (!obj) return '';
            const type = pointData.component ? String(pointData.component.type || 'component') : 'junction';
            const id = obj.id || '';
            const side = String(pointData.side || 'center');
            return `${type}:${id}:${side}`;
        }

        function getPointTerminalKey(pointData) {
            const obj = pointData?.component || pointData?.junction;
            const side = pointData?.side || 'center';
            return getTerminalKey(obj, side);
        }

        function applyProbeVisual(pointData, which) {
            let connectionPoint;
            if (pointData?.component) {
                connectionPoint = pointData.component.connectionPoints?.find(point =>
                    point.userData?.side === pointData.side
                );
            } else if (pointData?.junction) {
                connectionPoint = pointData.junction.connectionPoint;
            }
            if (!connectionPoint?.material) return;

            if (which === 'a') {
                connectionPoint.material.color.setRGB(1.0, 0.25, 0.25);
                connectionPoint.material.emissive.setRGB(0.5, 0.05, 0.05);
                connectionPoint.scale.setScalar(2.2);
            } else if (which === 'b') {
                connectionPoint.material.color.setRGB(0.7, 0.7, 0.75);
                connectionPoint.material.emissive.setRGB(0.15, 0.15, 0.18);
                connectionPoint.scale.setScalar(1.9);
            } else {
                connectionPoint.material.color.setRGB(0.5, 0.9, 1.0);
                connectionPoint.material.emissive.setRGB(0.05, 0.22, 0.28);
                connectionPoint.scale.setScalar(2.0);
            }
        }

        function restoreConnectionPointVisual(pointData) {
            if (!pointData) return;
            highlightConnectionPoint(pointData, false);
        }

        function handleMeterProbeClick(pointData) {
            if (!meterArmed) {
                return;
            }
            if (meterMode === 'current') {
                setStatus(' Current mode: click a component (resistor/LED/switch/battery) to read amps');
                return;
            }

            if (meterMode === 'scope') {
                if (meterProbeA) restoreConnectionPointVisual(meterProbeA);
                meterProbeA = pointData;
                applyProbeVisual(meterProbeA, 'scope');
                startScope();
                updateMeterUI();
                return;
            }

            // voltage / resistance: pick two probes
            if (!meterProbeA) {
                meterProbeA = pointData;
                applyProbeVisual(meterProbeA, 'a');
                setStatus(' Red probe set - click a second terminal for the black probe');
                updateMeterUI();
                return;
            }

            if (!meterProbeB) {
                meterProbeB = pointData;
                applyProbeVisual(meterProbeB, 'b');
                updateMeterUI();
                return;
            }

            // If both already set, restart selection from A
            restoreConnectionPointVisual(meterProbeA);
            restoreConnectionPointVisual(meterProbeB);
            meterProbeA = pointData;
            meterProbeB = null;
            applyProbeVisual(meterProbeA, 'a');
            updateMeterUI();
        }

        function startScope() {
            stopScope();
            if (meterMode !== 'scope' || !meterArmed || !meterProbeA) {
                return;
            }
            scopeTimer = window.setInterval(() => {
                updateScopeSample();
            }, 60);
        }

        function stopScope() {
            if (scopeTimer !== null) {
                window.clearInterval(scopeTimer);
                scopeTimer = null;
            }
        }

        function drawScope() {
            const canvas = document.getElementById('scope-canvas');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            if (!ctx) return;

            const w = canvas.width;
            const h = canvas.height;
            ctx.clearRect(0, 0, w, h);

            // background
            ctx.fillStyle = 'rgba(0,0,0,0.55)';
            ctx.fillRect(0, 0, w, h);

            // grid
            ctx.strokeStyle = 'rgba(136, 204, 255, 0.12)';
            ctx.lineWidth = 1;
            for (let i = 1; i < 10; i += 1) {
                const x = (w * i) / 10;
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, h);
                ctx.stroke();
            }
            for (let i = 1; i < 4; i += 1) {
                const y = (h * i) / 4;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(w, y);
                ctx.stroke();
            }

            if (!scopeBuffer.length) {
                return;
            }

            let minV = Math.min(...scopeBuffer);
            let maxV = Math.max(...scopeBuffer);
            if (!Number.isFinite(minV) || !Number.isFinite(maxV)) {
                return;
            }
            if (Math.abs(maxV - minV) < 1e-6) {
                minV -= 1;
                maxV += 1;
            } else {
                const pad = (maxV - minV) * 0.2;
                minV -= pad;
                maxV += pad;
            }

            const toX = (i) => (w * i) / Math.max(scopeBuffer.length - 1, 1);
            const toY = (v) => {
                const t = (v - minV) / (maxV - minV);
                return h - (t * h);
            };

            ctx.strokeStyle = 'rgba(0, 255, 136, 0.95)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            for (let i = 0; i < scopeBuffer.length; i += 1) {
                const x = toX(i);
                const y = toY(scopeBuffer[i]);
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();
        }

        function updateScopeSample() {
            if (meterMode !== 'scope' || !meterArmed || !meterProbeA) {
                return;
            }
            const solution = solveDCCircuitLegacy();
            lastDCSolution = solution;
            if (!solution || solution.status !== 'solved') {
                return;
            }

            const aKey = getPointTerminalKey(meterProbeA);
            const bKey = meterProbeB ? getPointTerminalKey(meterProbeB) : null;
            if (!aKey) return;

            const nodeA = solution.terminalToNode?.get(aKey);
            const nodeB = bKey ? solution.terminalToNode?.get(bKey) : solution.referenceNodeId;
            if (!nodeA || !nodeB) return;

            const vA = solution.nodeVoltages.get(nodeA) ?? 0;
            const vB = solution.nodeVoltages.get(nodeB) ?? 0;
            const dv = vA - vB;
            if (!Number.isFinite(dv)) return;

            scopeBuffer.push(dv);
            while (scopeBuffer.length > SCOPE_BUFFER_SIZE) scopeBuffer.shift();

            const readout = document.getElementById('scope-readout');
            if (readout) {
                readout.textContent = `V = ${dv.toFixed(3)} V`;
            }
            drawScope();
        }

        function updateMeterUI() {
            updateMeterButtonStates();

            const instructions = document.getElementById('meter-instructions');
            const probeAEl = document.getElementById('meter-probe-a');
            const probeBEl = document.getElementById('meter-probe-b');
            const readingEl = document.getElementById('meter-reading');
            const subEl = document.getElementById('meter-subreading');
            const scopePanel = document.getElementById('scope-panel');

            if (probeAEl) probeAEl.textContent = describeTerminal(meterProbeA);
            if (probeBEl) probeBEl.textContent = describeTerminal(meterProbeB);

            if (scopePanel) {
                scopePanel.style.display = meterMode === 'scope' ? 'block' : 'none';
            }

            if (instructions) {
                if (!meterArmed) {
                    instructions.textContent = 'Enable probes to begin measuring.';
                } else if (meterMode === 'voltage') {
                    instructions.textContent = 'Click two terminals to measure voltage (red minus black).';
                } else if (meterMode === 'resistance') {
                    instructions.textContent = 'Click two terminals to estimate equivalent resistance (sources disabled).';
                } else if (meterMode === 'current') {
                    instructions.textContent = 'Click a component to read its DC current.';
                } else if (meterMode === 'scope') {
                    instructions.textContent = 'Click a terminal to probe. Black probe is reference if set; otherwise battery negative.';
                }
            }

            if (readingEl) readingEl.textContent = '';
            if (subEl) subEl.textContent = '';

            if (!meterArmed) {
                stopScope();
                return;
            }

            // Keep a fresh solution for voltage/current/scope readouts
            try {
                lastDCSolution = solveDCCircuitLegacy();
            } catch (error) {
                lastDCSolution = { status: 'unsolved', reason: String(error || 'solve failed') };
            }

            if (meterMode === 'current') {
                if (!meterCurrentTarget) {
                    if (readingEl) readingEl.textContent = 'Click a component';
                    return;
                }
                const amps = getComponentCurrentFromSolution(meterCurrentTarget, lastDCSolution);
                if (readingEl) readingEl.textContent = Number.isFinite(amps) ? `${amps.toFixed(6)} A` : '';
                if (subEl) subEl.textContent = meterCurrentTarget?.id ? `Target: ${meterCurrentTarget.type}:${meterCurrentTarget.id}` : '';
                return;
            }

            if (meterMode === 'scope') {
                if (!meterProbeA) {
                    if (readingEl) readingEl.textContent = 'Pick a terminal';
                    stopScope();
                    return;
                }
                startScope();
                if (readingEl) {
                    const latest = scopeBuffer.length ? scopeBuffer[scopeBuffer.length - 1] : null;
                    readingEl.textContent = Number.isFinite(latest) ? `${latest.toFixed(3)} V` : '';
                }
                return;
            }

            if (!meterProbeA || !meterProbeB) {
                if (readingEl) readingEl.textContent = 'Pick two terminals';
                return;
            }

            if (meterMode === 'voltage') {
                const dv = getVoltageBetweenProbes(meterProbeA, meterProbeB, lastDCSolution);
                if (readingEl) readingEl.textContent = Number.isFinite(dv) ? `${dv.toFixed(3)} V` : '';
                if (subEl && lastDCSolution?.status && lastDCSolution.status !== 'solved') {
                    subEl.textContent = `Solver: ${lastDCSolution.status}${lastDCSolution.reason ? '  ' + lastDCSolution.reason : ''}`;
                }
                return;
            }

            if (meterMode === 'resistance') {
                const ohms = getEquivalentResistanceBetweenProbes(meterProbeA, meterProbeB);
                if (readingEl) {
                    if (ohms === Infinity) readingEl.textContent = ' ';
                    else readingEl.textContent = Number.isFinite(ohms) ? `${ohms.toFixed(2)} ` : '';
                }
                return;
            }
        }

        // State management functions
        function saveState() {
            const state = {
                components: components.map(comp => ({
                    type: comp.type,
                    position: comp.position.toArray(),
                    rotation: comp.rotation,
                    properties: comp.properties,
                    componentNumber: comp.componentNumber,
                    id: comp.id
                })),
                junctions: junctions.map(junction => ({
                    position: junction.position.toArray(),
                    id: junction.id
                })),
                wires: wires.map(wire => ({
                    startId: wire.startObj.id,
                    startSide: wire.startSide,
                    endId: wire.endObj.id,
                    endSide: wire.endSide,
                    id: wire.id
                })),
                componentCounters: { ...componentCounters }
            };
            
            undoStack.push(JSON.stringify(state));
            if (undoStack.length > 50) {
                undoStack.shift(); // Keep only last 50 states
            }
            redoStack = []; // Clear redo stack when new action is performed
            updateUndoRedoButtons();
        }

        function undo() {
            if (undoStack.length === 0) {
                setStatus(' Nothing to undo');
                return;
            }
            
            // Save current state to redo stack
            redoStack.push(getCurrentStateString());
            
            // Restore previous state
            const previousState = undoStack.pop();
            restoreState(JSON.parse(previousState));
            
            updateUndoRedoButtons();
            setStatus(' Undo completed');
        }

        function redo() {
            if (redoStack.length === 0) {
                setStatus(' Nothing to redo');
                return;
            }
            
            // Save current state to undo stack
            undoStack.push(getCurrentStateString());
            
            // Restore redo state
            const redoState = redoStack.pop();
            restoreState(JSON.parse(redoState));
            
            updateUndoRedoButtons();
            setStatus(' Redo completed');
        }

        function getCurrentStateString() {
            const state = {
                components: components.map(comp => ({
                    type: comp.type,
                    position: comp.position.toArray(),
                    rotation: comp.rotation,
                    properties: comp.properties,
                    componentNumber: comp.componentNumber,
                    id: comp.id
                })),
                junctions: junctions.map(junction => ({
                    position: junction.position.toArray(),
                    id: junction.id
                })),
                wires: wires.map(wire => ({
                    startId: wire.startObj.id,
                    startSide: wire.startSide,
                    endId: wire.endObj.id,
                    endSide: wire.endSide,
                    id: wire.id
                })),
                componentCounters: { ...componentCounters }
            };
            return JSON.stringify(state);
        }

        function restoreState(state) {
            // Clear current circuit
            clearAll(false); // Don't save state during clear
            
            // Restore component counters
            if (state.componentCounters) {
                componentCounters = { ...state.componentCounters };
            }
            
            // Restore components
            state.components.forEach(compData => {
                const position = new THREE.Vector3().fromArray(compData.position);
                const component = new Component(compData.type, position);
                component.rotation = normalizeAngle(compData.rotation || 0);
                component.properties = compData.properties;
                component.id = compData.id;
                
                // Restore component numbering if available
                if (compData.componentNumber) {
                    component.componentNumber = compData.componentNumber;
                }
                
                component.mesh.rotation.y = component.rotation;
                component.updateProperties(component.properties);
                components.push(component);
            });
            
            // Restore junctions
            state.junctions.forEach(junctionData => {
                const position = new THREE.Vector3().fromArray(junctionData.position);
                const junction = new Junction(position);
                junction.id = junctionData.id;
                junctions.push(junction);
            });
            
            // Restore wires
            state.wires.forEach(wireData => {
                const startObj = [...components, ...junctions].find(obj => obj.id === wireData.startId);
                const endObj = [...components, ...junctions].find(obj => obj.id === wireData.endId);
                
                if (startObj && endObj) {
                    const wire = new Wire(startObj, wireData.startSide, endObj, wireData.endSide);
                    wire.id = wireData.id;
                    wires.push(wire);
                }
            });
            
            analyzeCircuit();
            updateCircuitInfo();
        }

        function updateUndoRedoButtons() {
            const undoBtn = document.getElementById('undo-btn');
            const redoBtn = document.getElementById('redo-btn');
            
            if (undoBtn) {
                undoBtn.style.opacity = undoStack.length > 0 ? '1.0' : '0.5';
                undoBtn.disabled = undoStack.length === 0;
            }
            
            if (redoBtn) {
                redoBtn.style.opacity = redoStack.length > 0 ? '1.0' : '0.5';
                redoBtn.disabled = redoStack.length === 0;
            }
        }

        // File operations
        function saveCircuit() {
            const state = {
                components: components.map(comp => ({
                    type: comp.type,
                    position: comp.position.toArray(),
                    rotation: comp.rotation,
                    properties: comp.properties,
                    componentNumber: comp.componentNumber,
                    id: comp.id
                })),
                junctions: junctions.map(junction => ({
                    position: junction.position.toArray(),
                    id: junction.id
                })),
                wires: wires.map(wire => ({
                    startId: wire.startObj.id,
                    startSide: wire.startSide,
                    endId: wire.endObj.id,
                    endSide: wire.endSide,
                    id: wire.id
                })),
                componentCounters: { ...componentCounters },
                metadata: {
                    created: new Date().toISOString(),
                    app: 'W.I.R.E. Circuit Builder',
                    version: '2.0'
                }
            };
            
            const dataStr = JSON.stringify(state, null, 2);
            const dataBlob = new Blob([dataStr], {type: 'application/json'});
            
            const link = document.createElement('a');
            link.href = URL.createObjectURL(dataBlob);
            link.download = `circuit_${new Date().toISOString().slice(0,19).replace(/:/g, '-')}.json`;
            link.click();
            
            setStatus(' Circuit saved with W.I.R.E. labels and component numbering!');
        }

        function loadCircuit() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            
            input.onchange = function(event) {
                const file = event.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const state = JSON.parse(e.target.result);
                        restoreState(state);
                        setStatus(' Circuit loaded successfully with W.I.R.E. labels!');
                    } catch (error) {
                        console.error('Load error:', error);
                        setStatus(' Failed to load circuit file');
                    }
                };
                reader.readAsText(file);
            };
            
            input.click();
        }

        function newCircuit() {
            if (components.length > 0 || wires.length > 0 || junctions.length > 0) {
                if (confirm('Create new circuit? This will clear your current work.')) {
                    clearAll();
                    setStatus(' New circuit created');
                }
            } else {
                setStatus(' Circuit is already empty');
            }
        }

        function exportImage() {
            // Temporarily hide UI elements
            const menuBar = document.getElementById('menu-bar');
            const wireAnalysis = document.getElementById('wire-analysis');
            const status = document.getElementById('status');
            const menuToggle = document.getElementById('menu-toggle');
            
            menuBar.style.display = 'none';
            wireAnalysis.style.display = 'none';
            status.style.display = 'none';
            menuToggle.style.display = 'none';
            
            // Render and export
            renderer.render(scene, camera);
            
            const link = document.createElement('a');
            link.download = `circuit_export_${new Date().toISOString().slice(0,19).replace(/:/g, '-')}.png`;
            link.href = renderer.domElement.toDataURL();
            link.click();
            
            // Restore UI elements
            menuBar.style.display = 'block';
            wireAnalysis.style.display = 'block';
            menuToggle.style.display = 'flex';
            
            setStatus(' Circuit image exported!');
        }

        // Selection and clipboard functions
        function selectAll() {
            selectedComponents.clear();
            components.forEach(comp => selectedComponents.add(comp));
            junctions.forEach(junction => selectedComponents.add(junction));
            
            setStatus(`  Selected ${selectedComponents.size} objects`);
        }

        function copySelected() {
            if (selectedComponents.size === 0) {
                setStatus(' No objects selected to copy');
                return;
            }
            
            clipboard = {
                components: [],
                junctions: [],
                wires: []
            };
            
            selectedComponents.forEach(obj => {
                if (obj.type) { // Component
                    clipboard.components.push({
                        type: obj.type,
                        position: obj.position.toArray(),
                        rotation: obj.rotation,
                        properties: obj.properties,
                        originalId: obj.id
                    });
                } else if (obj.id && obj.id.startsWith('junction')) { // Junction
                    clipboard.junctions.push({
                        position: obj.position.toArray(),
                        originalId: obj.id
                    });
                }
            });
            
            setStatus(`  Copied ${selectedComponents.size} objects`);
        }

        function pasteSelected() {
            if (!clipboard || (clipboard.components.length === 0 && clipboard.junctions.length === 0)) {
                setStatus(' Nothing to paste');
                return;
            }
            
            selectedComponents.clear();
            const offset = new THREE.Vector3(2, 0, 2); // Offset for pasted objects
            
            // Paste components
            clipboard.components.forEach(compData => {
                const position = new THREE.Vector3().fromArray(compData.position).add(offset);
                const component = new Component(compData.type, position);
                component.rotation = normalizeAngle(compData.rotation || 0);
                component.properties = { ...compData.properties };
                component.mesh.rotation.y = component.rotation;
                component.updateProperties(component.properties);
                components.push(component);
                selectedComponents.add(component);
            });
            
            // Paste junctions
            clipboard.junctions.forEach(junctionData => {
                const position = new THREE.Vector3().fromArray(junctionData.position).add(offset);
                const junction = new Junction(position);
                junctions.push(junction);
                selectedComponents.add(junction);
            });
            
            updateCircuitInfo();
            setStatus(`  Pasted ${selectedComponents.size} objects`);
        }

        function deleteSelected() {
            if (selectedComponents.size === 0) {
                setStatus(' No objects selected to delete');
                return;
            }
            
            saveState(); // Save for undo
            
            selectedComponents.forEach(obj => {
                if (obj.remove) {
                    obj.remove();
                }
            });
            
            selectedComponents.clear();
            updateCircuitInfo();
            setStatus(' Selected objects deleted');
        }

        // View functions
        function resetCamera() {
            cameraDistance = 15;
            cameraAngleX = 0;
            cameraAngleY = 0.5;
            cameraTarget.set(0, 0, 0);
            updateCameraPosition();
            setStatus(' Camera view reset');
        }

        function fitToScreen() {
            if (components.length === 0 && junctions.length === 0) {
                resetCamera();
                return;
            }
            
            // Calculate bounding box of all objects
            const box = new THREE.Box3();
            components.forEach(comp => {
                if (comp.mesh) box.expandByObject(comp.mesh);
            });
            junctions.forEach(junction => {
                if (junction.mesh) box.expandByObject(junction.mesh);
            });
            
            const center = box.getCenter(new THREE.Vector3());
            const size = box.getSize(new THREE.Vector3());
            const maxDim = Math.max(size.x, size.y, size.z);
            
            cameraTarget.copy(center);
            cameraDistance = Math.max(10, maxDim * 2);
            updateCameraPosition();
            
            setStatus(' View fitted to circuit');
        }

        function toggleGrid() {
            if (gridHelper) {
                gridHelper.visible = !gridHelper.visible;
                showGrid = gridHelper.visible;
                
                // Also toggle the fine grid
                const fineGrid = scene.children.find(child => 
                    child.type === 'GridHelper' && child !== gridHelper
                );
                if (fineGrid) {
                    fineGrid.visible = gridHelper.visible;
                }
                
                notifyParentModeState();

                setStatus(`? Grid ${showGrid ? 'shown' : 'hidden'} - Components snap to grid points`);
            }
        }

        function toggleLabels() {
            showLabels = !showLabels;
            components.forEach(component => {
                if (component.labelDiv) {
                    component.labelDiv.style.display = showLabels ? 'block' : 'none';
                }
            });
            notifyParentModeState();
            setStatus(` ? Component labels ${showLabels ? 'enabled' : 'disabled'}`);
        }
        
        // Toggle current flow visualization style
        function toggleCurrentFlowStyle() {
            currentFlowStyle = currentFlowStyle === 'misty' ? 'solid' : 'misty';
            const styleLabel = document.getElementById('flow-style');
            if (styleLabel) {
                styleLabel.textContent = currentFlowStyle === 'misty' ? 'Electron Flow' : 'Current Flow';
            }
            
            // Re-animate current flow with new style
            const result = performCircuitAnalysis();
            const runtimeFlow = currentFlowState || result.flow;
            if (runtimeFlow) {
                animateCurrentFlow(runtimeFlow);
            }
            
            notifyParentModeState();

            setStatus(`  Flow: ${currentFlowStyle === 'misty' ? 'ELECTRON FLOW - Particles move negative -> positive (opposite conventional current)' : 'CURRENT FLOW - Particles move positive -> negative (conventional current)'}`);
        }
        
        // Toggle polarity indicators
        function togglePolarityIndicators() {
            showPolarityIndicators = !showPolarityIndicators;
            
            // Update all component polarity displays
            components.forEach(component => {
                if (component.updatePolarityDisplay) {
                    component.updatePolarityDisplay(showPolarityIndicators);
                }
            });
            
            notifyParentModeState();

            setStatus(`? Polarity indicators ${showPolarityIndicators ? 'shown' : 'hidden'}`);
        }
        
        // Toggle branding overlay
        function toggleBranding() {
            const brandingEl = document.getElementById('branding-overlay');
            if (brandingEl) {
                if (brandingEl.style.display === 'none') {
                    brandingEl.style.display = 'block';
                    setStatus(' CircuiTry3D branding shown');
                } else {
                    brandingEl.style.display = 'none';
                    setStatus(' CircuiTry3D branding hidden');
                }
            }
        }
        
        // Cycle through layout modes
        function cycleLayoutMode() {
            const modes = ['free', 'square', 'linear'];
            const currentIndex = modes.indexOf(layoutMode);
            const nextIndex = (currentIndex + 1) % modes.length;
            layoutMode = modes[nextIndex];
            
            const layoutLabel = document.getElementById('layout-mode');
            if (layoutLabel) {
                const modeNames = {
                    'free': 'Free',
                    'square': 'Square',
                    'linear': 'Linear'
                };
                layoutLabel.textContent = modeNames[layoutMode];
            }
            
            notifyParentModeState();

            setStatus(`  Layout mode: ${layoutMode.toUpperCase()} - ${getLayoutModeDescription(layoutMode)}`);
        }
        
        function getLayoutModeDescription(mode) {
            const descriptions = {
                'free': 'Place components anywhere',
                'square': 'Textbook-style square circuits',
                'linear': 'Tree layout with battery at top'
            };
            return descriptions[mode] || '';
        }

        // Help functions
        function showTutorial() {
            const tutorial = `
?? CIRCUITRY3D QUICK START GUIDE

???????????????????????????????????????

?? GETTING STARTED:

1?? ADD COMPONENTS (?? Components menu):
   ? Battery (B key) - Power source
   ? Resistor (R key) - Limit current
   ? LED (L key) - Light indicator
   ? Switch (S key) - Control flow
   ? All components show real-time values

2?? CONNECT WITH WIRES (??? Tools menu):
   ? Click "?? Wire" button (or W key)
   ? Touch component terminals to connect
   ? Tap any existing wire run to drop a junction and start a branch
   ? Complete the circuit loop for current flow

3?? VIEW CALCULATIONS (panels on right):
   ? ?? W.I.R.E. - Main electrical values
   ? ?? EIR ? - Ohm's Law triangle
   ? ? Power ? - Power calculations
   ? ?? Worksheet - Step-by-step formulas
   ? ? Solve - Check your answers

???????????????????????????????????????

?? VISUAL LEARNING:

??? COLOR-CODED VALUES:
   ?? Blue = Power (Watts)
   ?? Orange = Current (Amps)
   ?? Green = Resistance (Ohms)
   ?? Red = Voltage (Volts)

?? FLOW VISUALIZATION (View menu):
   ? Electron Flow: Shows actual electron movement
     (negative ? positive, semi-transparent particles)
   ? Current Flow: Shows conventional direction
     (positive ? negative, solid particles)
   ? Toggle: View ? ?? Flow

? POLARITY INDICATORS:
   ? Red (+) and Blue (-) terminals
   ? Prevents incorrect connections
   ? Toggle: View ? ? Polarity

???????????????????????????????????????

?? ADVANCED FEATURES:

?? ROUTING MODES (??? Tools menu):
   ? Free-form: Natural connections
   ? Manhattan: Textbook right-angles
   ? Offset: Parallel detours
   ? Arc: Smooth sweeps
   ? Toggle: Tools ? ?? Route

? JUNCTIONS (critical for parallel + series-parallel circuits):
   ? In Wire Mode, tap/click any wire run to split it and drop a junction
   ? The new junction becomes a live terminal so you can branch immediately
   ? Use junction branches to apply KCL on every current split/recombine node

?? AUTO-ARRANGE:
   ? Tools ? ?? Auto-Arrange
   ? Automatically creates textbook layouts
   ? Perfect for practice problems

?? LAYOUT MODES (View menu):
   ? Free: Place anywhere
   ? Square: Textbook style
   ? Linear: Vertical tree
   ? Toggle: View ? ?? Layout

???????????????????????????????????????

?? CONTROLS:

MOUSE/TOUCH:
   ? Drag: Move components
   ? Long-press: Edit values/properties
   ? Two-finger pinch: Zoom
   ? Two-finger drag: Pan workspace

KEYBOARD SHORTCUTS:
   ? B = Battery, R = Resistor
   ? L = LED, S = Switch, J = Junction
   ? W = Wire Mode, T = Rotate Mode
   ? Space = Toggle Menu

VIEW CONTROLS (??? View menu):
   ? Reset View: Center camera
   ? Fit Screen: Auto-zoom to circuit
   ? Toggle Grid: Show/hide snap grid
   ? Labels: Show/hide component names

???????????????????????????????????????

?? TIPS:
? Complete the circuit loop for current to flow
? Open switches stop current flow
? Use junctions for every parallel branch; that is where current splits/recombines
? Long-press wires to add a branch junction, delete, or reroute
? Try different routing modes for cleaner layouts

Need more help? Check:
? ?? W.I.R.E. Guide - Electrical concepts
? ?? Shortcuts - Full keyboard reference
? ?? About - Version info & features
            `;
            alert(tutorial);
        }

        function showWireGuide() {
            const guide = `
?? W.I.R.E. METHOD EXPLAINED

???????????????????????????????????????

The W.I.R.E. method helps you remember the four key electrical values:

W = WATTS (Power) ?? BLUE
????????????????????????
? Formula: P = V ? I
? What it means: Energy used per second
? In circuits: How much work electricity does
? Example: 60W light bulb uses 60 joules/second
? Higher power = brighter light, more heat

I = CURRENT (Amperes) ?? ORANGE
????????????????????????
? Formula: I = V / R (Ohm's Law)
? What it means: Flow rate of electrons
? In circuits: Like water flow in a pipe
? Visualized: Animated particles in wires
? Measured in Amperes (Amps)

R = RESISTANCE (Ohms) ?? GREEN
????????????????????????
? Formula: R = V / I
? What it means: Opposition to current flow
? In circuits: Like pipe narrowness
? Components: Resistors, LEDs (have resistance)
? Higher resistance = less current

E = EMF/VOLTAGE (Volts) ?? RED
????????????????????????
? Formula: V = I ? R
? What it means: Electrical pressure
? In circuits: Like water pressure in pipes
? Source: Battery provides voltage
? Higher voltage = more current (if R same)

???????????????????????????????????????

?? KEY FORMULAS:

OHM'S LAW TRIANGLE (EIR ?):
   E (Voltage)
      /\
     /  \
    /____\
   I    R
   
? V = I ? R  (Voltage = Current ? Resistance)
? I = V / R  (Current = Voltage / Resistance)
? R = V / I  (Resistance = Voltage / Current)

POWER TRIANGLE (Power ?):
   P (Watts)
      /\
     /  \
    /____\
   V    I
   
? P = V ? I  (Power = Voltage ? Current)
? P = I?R    (Power = Current? ? Resistance)
? P = V?/R   (Power = Voltage? / Resistance)

???????????????????????????????????????

?? PRACTICE TIPS:

1. Build simple circuits to see W.I.R.E. in action
2. Watch how values change when you:
   - Add resistors (R increases)
   - Change battery voltage (E changes)
   - Add parallel paths (total R decreases)
3. Use the panels on right to see calculations
4. Try Practice Mode for guided problems

?? REMEMBER: All values are connected!
   Change one, and others adjust automatically.
            `;
            alert(guide);
        }

        function showShortcuts() {
            const shortcuts = `
?? KEYBOARD & MOUSE CONTROLS

???????????????????????????????????????

?? COMPONENT SHORTCUTS:
   B = Add Battery
   R = Add Resistor
   L = Add LED
   S = Add Switch
   J = Add Junction

??? TOOL SHORTCUTS:
   W = Toggle Wire Mode
   T = Toggle Rotate Mode
   Space = Toggle Menu
   Esc = Close menu/Cancel mode

?? EDIT SHORTCUTS:
   Ctrl+Z = Undo
   Ctrl+Y = Redo
   Ctrl+C = Copy selected
   Ctrl+V = Paste
   Delete = Delete selected
   Backspace = Delete selected

?? FILE SHORTCUTS:
   Ctrl+S = Save Circuit
   Ctrl+O = Load Circuit
   Ctrl+N = New Circuit

??? VIEW SHORTCUTS:
   H = Reset Camera
   F = Fit to Screen
   G = Toggle Grid

???????????????????????????????????????

??? MOUSE CONTROLS:

BASIC ACTIONS:
   Click = Select component
   Drag = Move component
   Scroll = Zoom in/out
   Right-click = Context menu

WIRE MODE:
   Click terminal ? Click terminal = Create wire
   Click/tap wire run = Drop junction + start branch
   Click junction ? Click junction = Wire between junctions
   Esc = Exit wire mode

ROTATE MODE:
   Click component = Rotate 90?
   Esc = Exit rotate mode

EDITING:
   Long-press component = Edit properties
   Long-press wire = Add junction branch, delete, or reroute
   Double-click = Quick edit

???????????????????????????????????????

?? TOUCH CONTROLS (Mobile/Tablet):

ONE FINGER:
   Tap = Select component
   Drag = Move component
   Long-press = Edit properties/values

TWO FINGERS:
   Pinch = Zoom in/out
   Drag = Pan workspace
   Rotate = Rotate view

WIRE CONNECTIONS:
   Tap terminal in wire mode = Connect
   Tap wire run in wire mode = Drop junction + start branch
   Long-press wire = Branch/delete/reroute menu

???????????????????????????????????????

?? PRO TIPS:

? Hold Shift while dragging = Disable grid snap
? Use arrow keys = Fine-tune component position
? Middle-click drag = Pan workspace (desktop)
? Ctrl+Scroll = Zoom faster
? Double-tap = Quick component edit (mobile)

???????????????????????????????????????

?? QUICK WORKFLOW:

1. Press B = Add battery
2. Press R = Add resistor
3. Press W = Enter wire mode
4. Click terminals = Connect
5. Space = Toggle menu to see results

Fast circuit building with keyboard shortcuts!
            `;
            alert(shortcuts);
        }

        function showAbout() {
            const about = `
?? CIRCUITRY3D - W.I.R.E. CIRCUIT BUILDER

???????????????????????????????????????

?? VERSION 2.5 - ENHANCED EDITION

?? Educational 3D Circuit Simulator
   Built with Three.js & W.I.R.E. methodology
   Perfect for visual learners!

???????????????????????????????????????

? CORE FEATURES:

?? CIRCUIT BUILDING:
   ? Interactive 3D environment
   ? Real-time electrical calculations
   ? Color-coded values (W.I.R.E.)
   ? Auto-labeling (B1, R1, LED1, SW1)
   ? Grid snapping (toggle on/off)

?? VISUALIZATION:
   ? Electron Flow mode (semi-transparent)
   ? Current Flow mode (solid particles)
   ? Animated current through wires
   ? Polarity indicators (+/?)
   ? Transparent branding overlay

?? FLEXIBLE WIRING:
   ? Free-form: Natural connections
   ? Manhattan: Textbook right-angles
   ? Offset: Parallel detours
   ? Arc: Smooth sweeps
   ? Simple, Perimeter, A*: Advanced routing
   ? Tap any wire run to drop junction branches instantly
   ? Long-press wire editing

?? LAYOUT OPTIONS:
   ? Free: Place components anywhere
   ? Square: Textbook-style circuits
   ? Linear: Vertical tree layout
   ? Auto-arrange for instant layouts

???????????????????????????????????????

?? EDUCATIONAL TOOLS:

W.I.R.E. PANELS:
   ?? W.I.R.E. - Main electrical values
   ?? EIR ? - Ohm's Law triangle
   ? Power ? - Power calculations
   ?? Worksheet - Step-by-step formulas
   ? Solve - Answer verification

PRACTICE MODE:
   ? Guided circuit problems
   ? Series, Parallel, Combination circuits
   ? Switch circuits
   ? Random problem generator
   ? Step-by-step solutions

???????????????????????????????????????

?? PURPOSE & PEDAGOGY:

CircuiTry3D teaches electrical engineering
fundamentals through hands-on experimentation
with virtual circuits. 

The W.I.R.E. method provides a memorable
framework for understanding:
   ?? Watts (Power) - Blue
   ?? Current (Amperes) - Orange
   ?? Resistance (Ohms) - Green
   ?? EMF/Voltage (Volts) - Red

Visual, interactive learning makes abstract
concepts concrete and accessible!

???????????????????????????????????????

?? PLATFORM SUPPORT:

DESKTOP:
   ? Full keyboard & mouse support
   ? High-performance 3D rendering
   ? All features available

MOBILE/TABLET:
   ? Touch-optimized controls
   ? Two-finger zoom & pan
   ? Long-press editing
   ? Responsive interface

???????????????????????????????????????

?? TECHNICAL DETAILS:

Built with:
   ? Three.js - 3D graphics
   ? JavaScript - Core logic
   ? HTML5 Canvas - Rendering
   ? CSS3 - Interface styling

Features:
   ? Real-time circuit simulation
   ? Graph-based topology detection
   ? Multiple routing algorithms
   ? Persistent local storage
   ? Import/export circuits

???????????????????????????????????????

?? FOR STUDENTS & EDUCATORS:

STUDENTS:
   ? Learn by doing
   ? Instant visual feedback
   ? Practice problems included
   ? Export circuits for homework
   ? Mobile-friendly for anywhere learning

EDUCATORS:
   ? Create example circuits easily
   ? Professional layouts automatically
   ? W.I.R.E. methodology built-in
   ? Free to use in classroom
   ? No installation required

???????????????????????????????????????

?? SUPPORT & FEEDBACK:

Found a bug? Have a suggestion?
Visit: github.com/Mitchelllorin/CircuiTry3D

? 2025 CircuiTry3D
W.I.R.E. Circuit Builder v2.5

Made with ? for visual learners everywhere!
            `;
            alert(about);
        }

        // UI Functions
        function addComponent(type) {
            saveState(); // Save for undo

            if (isDragging || selectedComponent) {
                isDragging = false;
                selectedComponent = null;
                hideSnapIndicator();
            }

            // Calculate center-right position with staggering
            // Components appear in the center-right area of the workspace (visible, not behind menu)
            // Each new component is staggered slightly to avoid overlap
            const staggerOffset = componentPlacementIndex * 2; // 2 units apart for each new component
            const baseX = 2; // Start at X=2 (center-right, away from left menu)
            const baseZ = 0; // Start at center Z

            // Spiral-like stagger pattern for better visibility
            const staggerX = (componentPlacementIndex % 4) * 2 - 3; // -3, -1, 1, 3 pattern
            const staggerZ = Math.floor(componentPlacementIndex / 4) * 2; // Move down every 4 components

            const position = snapToGrid(new THREE.Vector3(
                baseX + staggerX,
                0,
                baseZ + staggerZ
            ));

            componentPlacementIndex++;
            // Reset index after 16 components to reuse positions (components will have been moved by user)
            if (componentPlacementIndex >= 16) {
                componentPlacementIndex = 0;
            }

            const component = new Component(type, position);
            components.push(component);
            selectComponent(component, { startDragging: true, silent: true });

            setStatus(` ${type} added - drag to grid position, tap to place, long press to edit values`);
            updateCircuitInfo();
            closeAllSubmenus();
        }

        function addJunction() {
            saveState(); // Save for undo

            if (isDragging || selectedComponent) {
                isDragging = false;
                selectedComponent = null;
                hideSnapIndicator();
            }

            // Use same staggered center-right placement as components
            const staggerX = (componentPlacementIndex % 4) * 2 - 3;
            const staggerZ = Math.floor(componentPlacementIndex / 4) * 2;

            const position = snapToGrid(new THREE.Vector3(
                2 + staggerX,
                0,
                staggerZ
            ));

            componentPlacementIndex++;
            if (componentPlacementIndex >= 16) {
                componentPlacementIndex = 0;
            }

            const junction = new Junction(position);
            junctions.push(junction);

            selectJunction(junction, { startDragging: true, silent: true });

            setStatus(` Junction node added - drag to grid position and tap to place!`);
            updateCircuitInfo();
            closeAllSubmenus();
        }
        
        // Split a wire by adding a junction at a specific point
        function splitWireWithJunction(wire, position, options = {}) {
            if (!wire || !position) return null;

            const {
                saveSnapshot = true,
                snapToGridPosition = false,
                suppressStatus = false,
                reuseNearbyJunction = true
            } = options;

            const splitPoint = position instanceof THREE.Vector3
                ? position.clone()
                : new THREE.Vector3(
                    Number(position?.x) || 0,
                    Number(position?.y) || 0,
                    Number(position?.z) || 0
                );
            splitPoint.y = 0;

            if (reuseNearbyJunction) {
                const existingJunction = findNearestJunctionByPosition(splitPoint);
                if (existingJunction) {
                    if (!suppressStatus) {
                        setStatus(' Existing junction selected - continue wiring to branch from this node.');
                    }
                    return existingJunction;
                }
            }

            const startPos = typeof wire.getStartPosition === 'function'
                ? wire.getStartPosition()
                : (wire.startObj?.position?.clone ? wire.startObj.position.clone() : null);
            const endPos = typeof wire.getEndPosition === 'function'
                ? wire.getEndPosition()
                : (wire.endObj?.position?.clone ? wire.endObj.position.clone() : null);

            if (startPos && splitPoint.distanceTo(startPos) <= WIRE_SPLIT_ENDPOINT_TOLERANCE) {
                if (wire.startObj instanceof Junction) {
                    return wire.startObj;
                }
                if (!suppressStatus) {
                    setStatus(' Tap the terminal directly to branch from endpoints, or tap farther along the wire to insert a junction.');
                }
                return null;
            }

            if (endPos && splitPoint.distanceTo(endPos) <= WIRE_SPLIT_ENDPOINT_TOLERANCE) {
                if (wire.endObj instanceof Junction) {
                    return wire.endObj;
                }
                if (!suppressStatus) {
                    setStatus(' Tap the terminal directly to branch from endpoints, or tap farther along the wire to insert a junction.');
                }
                return null;
            }

            if (saveSnapshot) {
                saveState();
            }

            const junction = new Junction(splitPoint, { snapToGridPosition });
            junctions.push(junction);

            const startObj = wire.startObj;
            const startSide = wire.startSide;
            const endObj = wire.endObj;
            const endSide = wire.endSide;

            let wire1 = null;
            let wire2 = null;

            try {
                wire1 = new Wire(startObj, startSide, junction, 'center');
                wire2 = new Wire(junction, 'center', endObj, endSide);
            } catch (error) {
                console.error('Wire split failed:', error);
                if (wire1) {
                    wire1.remove();
                }
                if (wire2) {
                    wire2.remove();
                }
                junction.remove();
                if (!suppressStatus) {
                    setStatus(' Unable to split wire at that point. Try tapping farther from terminals.');
                }
                return null;
            }

            wire.remove();
            wires.push(wire1, wire2);

            analyzeCircuit();
            updateCircuitInfo();

            if (!suppressStatus) {
                setStatus(' Wire split with junction - now you can branch from this point!');
            }
            return junction;
        }

        // Create an equal-spaced parallel bus from a source to N targets (intelligent split)
        // This uses the new intelligent splitting logic for textbook-style parallel circuits
        function createParallelBus(sourceObj, targetObjs) {
            if (!sourceObj || !targetObjs || targetObjs.length === 0) return;
            
            // Use the new intelligent split function
            const result = createIntelligentSplit(sourceObj, targetObjs, 'parallel');
            
            // Analyze and update the circuit
            analyzeCircuit();
            updateCircuitInfo();
            
            setStatus(`? Created textbook-style parallel circuit with ${targetObjs.length} branches`);
        }

        function enableWireMode(options = {}) {
            const { silent = false } = options;
            if (isWireMode) {
                if (!silent) {
                    setStatus(' WIRE MODE! Touch terminals to connect, or tap any wire run to drop a junction branch.');
                }
                notifyParentToolState('wire');
                notifyParentModeState();
                return;
            }

            exitMeasureMode({ silent: true, skipNotify: true });
            isWireMode = true;
            isRotateMode = false;

            if (wireStart) {
                highlightConnectionPoint(wireStart, false);
                wireStart = null;
            }

            updateButtonStates();
            notifyParentModeState();
            closeAllSubmenus();

            if (!silent) {
                setStatus(' WIRE MODE! Touch terminals to connect, or tap any wire run to drop a junction branch.');
            }

            notifyParentToolState('wire');
        }

        function disableWireMode(options = {}) {
            const { silent = false, skipNotify = false } = options;
            if (!isWireMode) {
                if (!skipNotify) {
                    const nextTool = isMeasureMode ? 'measure' : (isRotateMode ? 'rotate' : 'select');
                    notifyParentToolState(nextTool);
                }
                return;
            }

            if (wireStart) {
                highlightConnectionPoint(wireStart, false);
                wireStart = null;
            }

            isWireMode = false;
            updateButtonStates();
            notifyParentModeState();
            closeAllSubmenus();

            if (!silent) {
                setStatus(' Wire mode disabled');
            }

            if (!skipNotify) {
                const nextTool = isMeasureMode ? 'measure' : (isRotateMode ? 'rotate' : 'select');
                notifyParentToolState(nextTool);
            }
        }

        function enableRotateMode(options = {}) {
            const { silent = false } = options;
            if (isRotateMode) {
                if (!silent) {
                    setStatus(' ROTATE MODE! Touch any component to rotate it 90');
                }
                notifyParentToolState('rotate');
                notifyParentModeState();
                return;
            }

            disableWireMode({ silent: true, skipNotify: true });
            exitMeasureMode({ silent: true, skipNotify: true });

            isRotateMode = true;
            updateButtonStates();
            notifyParentModeState();
            closeAllSubmenus();

            if (!silent) {
                setStatus(' ROTATE MODE! Touch any component to rotate it 90?');
            }

            notifyParentToolState('rotate');
        }

        function disableRotateMode(options = {}) {
            const { silent = false, skipNotify = false, skipCloseMenus = false } = options;
            if (!isRotateMode) {
                if (!skipNotify) {
                    const nextTool = isWireMode ? 'wire' : (isMeasureMode ? 'measure' : 'select');
                    notifyParentToolState(nextTool);
                }
                return;
            }

            isRotateMode = false;
            updateButtonStates();
            notifyParentModeState();
            if (!skipCloseMenus) {
                closeAllSubmenus();
            }

            if (!silent) {
                setStatus(' Rotate mode disabled');
            }

            if (!skipNotify) {
                const nextTool = isWireMode ? 'wire' : (isMeasureMode ? 'measure' : 'select');
                notifyParentToolState(nextTool);
            }
        }

        function enterMeasureMode(options = {}) {
            const { silent = false } = options;
            if (isMeasureMode) {
                if (!silent) {
                    setStatus(' Measure mode active - select the next point to measure');
                }
                notifyParentToolState('measure');
                notifyParentModeState();
                return;
            }

            disableWireMode({ silent: true, skipNotify: true });
            disableRotateMode({ silent: true, skipNotify: true });

            isMeasureMode = true;
            measureStartPoint = null;
            notifyParentModeState();

            if (!silent) {
                setStatus(' Measure mode active - pick two points to calculate distance');
            }

            notifyParentToolState('measure');
        }

        function exitMeasureMode(options = {}) {
            const { silent = false, skipNotify = false } = options;
            if (!isMeasureMode) {
                return;
            }

            isMeasureMode = false;
            measureStartPoint = null;
            notifyParentModeState();

            if (!silent) {
                setStatus(' Measure mode disabled');
            }

            if (!skipNotify) {
                const nextTool = isWireMode ? 'wire' : (isRotateMode ? 'rotate' : 'select');
                notifyParentToolState(nextTool);
            }
        }

        function setBuilderTool(tool) {
            switch ((tool || '').toLowerCase()) {
                case 'wire':
                    enableWireMode();
                    break;
                case 'measure':
                    enterMeasureMode();
                    break;
                case 'rotate':
                    enableRotateMode();
                    break;
                case 'select':
                case 'default':
                case 'none':
                default:
                    disableWireMode({ silent: true, skipNotify: true });
                    disableRotateMode({ silent: true, skipNotify: true });
                    exitMeasureMode({ silent: true, skipNotify: true });
                    setStatus(' Select mode active - tap components to edit');
                    notifyParentToolState('select');
                    break;
            }
        }

        function handleMeasurementPoint(worldPosition) {
            if (!isMeasureMode || !worldPosition) {
                return;
            }

            const point = (typeof worldPosition.clone === 'function')
                ? worldPosition.clone()
                : new THREE.Vector3(worldPosition.x || 0, worldPosition.y || 0, worldPosition.z || 0);

            if (!measureStartPoint) {
                measureStartPoint = point.clone();
                setStatus(' Measurement started - choose a second point');
                notifyParentMeasurement({ step: 'start', point: measureStartPoint.toArray() });
                return;
            }

            const distance = point.distanceTo(measureStartPoint);
            const rounded = Number.isFinite(distance) ? distance.toFixed(2) : '0.00';
            setStatus(`  Distance measured: ${rounded} units`);

            notifyParentMeasurement({
                step: 'complete',
                distance,
                start: measureStartPoint.toArray(),
                end: point.toArray()
            });

            measureStartPoint = null;
        }

        function runSimulation() {
            try {
                const result = analyzeCircuit();
                notifyParentSimulation({ success: true, result: result || null });
            } catch (error) {
                console.error('Simulation error:', error);
                setStatus(' Simulation failed - see console for details');
                notifyParentSimulation({ success: false, error: error ? String(error) : 'unknown' });
            }
        }

        function toggleWireMode() {
            if (isWireMode) {
                disableWireMode();
            } else {
                enableWireMode();
            }
        }

        function toggleRotateMode() {
            if (isRotateMode) {
                disableRotateMode();
            } else {
                enableRotateMode();
            }
        }

        function updateButtonStates() {
            try {
                const wireBtn = document.getElementById('wire-btn');
                const rotateBtn = document.getElementById('rotate-btn');
                
                if (wireBtn) wireBtn.classList.toggle('active', isWireMode);
                if (rotateBtn) rotateBtn.classList.toggle('active', isRotateMode);
                
                updateUndoRedoButtons();
            } catch (error) {
                console.warn('Button state update error:', error);
            }
        }



        function buildComponentRuntimeNameplateMetrics(analysis, flowState) {
            const result = analysis || {};
            const hasFlow = Boolean(flowState && flowState.hasFlow);
            const circuitCurrent = Number.isFinite(result.current) ? result.current : 0;
            const circuitVoltage = Number.isFinite(result.voltage) ? result.voltage : 0;
            const metricsByComponentId = new Map();
            const resistanceByComponentId = new Map();

            if (flowState && Array.isArray(flowState.componentSegments)) {
                flowState.componentSegments.forEach(segment => {
                    const component = segment?.component;
                    if (!component || !component.id) {
                        return;
                    }

                    const resistance = Number(segment.resistance);
                    if (!isFinite(resistance) || resistance < 0) {
                        return;
                    }

                    const previous = resistanceByComponentId.get(component.id) || 0;
                    resistanceByComponentId.set(component.id, previous + resistance);
                });
            }

            components.forEach(component => {
                if (!component || !component.id) {
                    return;
                }

                if (!hasFlow) {
                    metricsByComponentId.set(component.id, {
                        state: 'open',
                        reason: flowState?.reason || 'open',
                        current: 0
                    });
                    return;
                }

                if (component.type === 'battery' || component.type === 'ac_source') {
                    const sourceVoltage = Number(component.properties?.voltage);
                    const resolvedVoltage = isFinite(sourceVoltage) ? sourceVoltage : circuitVoltage;
                    metricsByComponentId.set(component.id, {
                        state: 'live',
                        role: 'source',
                        current: circuitCurrent,
                        voltageDrop: isFinite(sourceVoltage) ? sourceVoltage : null,
                        power: isFinite(resolvedVoltage) ? resolvedVoltage * circuitCurrent : null
                    });
                    return;
                }

                const pathResistance = resistanceByComponentId.get(component.id);
                if (isFinite(pathResistance) && pathResistance >= 0) {
                    metricsByComponentId.set(component.id, {
                        state: 'live',
                        role: 'load',
                        current: circuitCurrent,
                        resistance: pathResistance,
                        voltageDrop: circuitCurrent * pathResistance,
                        power: circuitCurrent * circuitCurrent * pathResistance
                    });
                    return;
                }

                if (component.type === 'switch' && component.properties?.isOn) {
                    metricsByComponentId.set(component.id, {
                        state: 'live',
                        role: 'control',
                        current: circuitCurrent
                    });
                    return;
                }

                metricsByComponentId.set(component.id, {
                    state: 'idle',
                    current: 0
                });
            });

            return metricsByComponentId;
        }

        function applyComponentRuntimeNameplateMetrics(analysis, flowState) {
            const metricsByComponentId = buildComponentRuntimeNameplateMetrics(analysis, flowState);
            components.forEach(component => {
                if (!component || typeof component.updateRuntimeMetrics !== 'function') {
                    return;
                }
                component.updateRuntimeMetrics(metricsByComponentId.get(component.id) || null);
            });
        }

        // Circuit analysis
        function analyzeCircuit() {
            const batteries = components.filter(c => c.type === 'battery');
            
            if (batteries.length === 0) {
                updateCircuitDisplay(0, 0, Infinity, 0);
                animateCurrentFlow({ hasFlow: false, currentValue: 0 });
                applyComponentRuntimeNameplateMetrics(
                    { current: 0, voltage: 0 },
                    { hasFlow: false, reason: 'no-battery' }
                );
                setStatus(' ADD A BATTERY to start W.I.R.E. analysis!');
                const snapshot = {
                    updatedAt: new Date().toISOString(),
                    counts: {
                        components: components.length,
                        wires: wires.length,
                        junctions: junctions.length,
                        byType: components.reduce((acc, c) => {
                            const key = (c && c.type) ? String(c.type) : 'unknown';
                            acc[key] = (acc[key] || 0) + 1;
                            return acc;
                        }, {})
                    },
                    metrics: {
                        voltage: 0,
                        current: 0,
                        resistance: null,
                        power: 0,
                        isComplete: false,
                        reason: 'no-battery',
                        flow: { hasFlow: false, reason: 'no-battery' }
                    }
                };
                notifyParentCircuitState(snapshot);
                return {
                    voltage: 0,
                    current: 0,
                    resistance: Infinity,
                    power: 0,
                    isComplete: false,
                    reason: 'no-battery'
                };
            }
            
            if (wires.length === 0) {
                const totalVoltage = batteries.reduce((sum, bat) => sum + bat.properties.voltage, 0);
                updateCircuitDisplay(totalVoltage, 0, Infinity, 0);
                animateCurrentFlow({ hasFlow: false, currentValue: 0 });
                applyComponentRuntimeNameplateMetrics(
                    { current: 0, voltage: totalVoltage },
                    { hasFlow: false, reason: 'no-wires' }
                );
                setStatus(' ADD WIRES to complete the circuit for W.I.R.E. calculations!');
                const snapshot = {
                    updatedAt: new Date().toISOString(),
                    counts: {
                        components: components.length,
                        wires: wires.length,
                        junctions: junctions.length,
                        byType: components.reduce((acc, c) => {
                            const key = (c && c.type) ? String(c.type) : 'unknown';
                            acc[key] = (acc[key] || 0) + 1;
                            return acc;
                        }, {})
                    },
                    metrics: {
                        voltage: totalVoltage,
                        current: 0,
                        resistance: null,
                        power: 0,
                        isComplete: false,
                        reason: 'no-wires',
                        flow: { hasFlow: false, reason: 'no-wires' }
                    }
                };
                notifyParentCircuitState(snapshot);
                return {
                    voltage: totalVoltage,
                    current: 0,
                    resistance: Infinity,
                    power: 0,
                    isComplete: false,
                    reason: 'no-wires'
                };
            }
            
            const result = performCircuitAnalysis();
            updateCircuitDisplay(result.voltage, result.current, result.resistance, result.power);

            // Keep measurement tools synced with latest DC solve
            try {
                lastDCSolution = solveDCCircuitLegacy();
            } catch (error) {
                lastDCSolution = { status: 'unsolved', reason: String(error || 'solve failed') };
            }
            if (meterArmed || currentAnalysisTab === 'meter') {
                updateMeterUI();
            }

            const runtimeFlow = currentFlowState || result.flow || { hasFlow: false, currentValue: result.current || 0 };
            animateCurrentFlow(runtimeFlow);

            const flowMeta = result.flow || sanitizeFlowState(runtimeFlow);

            if (!flowMeta.hasFlow) {
                if (flowMeta.reason === 'polarity') {
                    setStatus('POLARITY MISMATCH: Reverse components so current can travel positive -> negative.');
                } else if (flowMeta.reason === 'short') {
                    setStatus(' SHORT CIRCUIT: Separate the terminals or add resistance to protect the build.');
                } else if (flowMeta.reason === 'no-source') {
                    setStatus(' Add a battery to power the circuit and start current flow.');
                }
            } else if (flowMeta.warning === 'short') {
                setStatus(' SHORT CIRCUIT PATH: Current is racing from positive -> negative. Add resistance now!');
            }

            const nameplateFlow = (currentFlowState && typeof currentFlowState === 'object')
                ? currentFlowState
                : flowMeta;
            applyComponentRuntimeNameplateMetrics(
                { current: result.current, voltage: result.voltage },
                nameplateFlow
            );

            const circuitResult = {
                voltage: result.voltage,
                current: result.current,
                resistance: result.resistance,
                power: result.power,
                flow: flowMeta,
                isComplete: Boolean(flowMeta?.hasFlow),
                analysis: result
            };
            const snapshot = {
                updatedAt: new Date().toISOString(),
                counts: {
                    components: components.length,
                    wires: wires.length,
                    junctions: junctions.length,
                    byType: components.reduce((acc, c) => {
                        const key = (c && c.type) ? String(c.type) : 'unknown';
                        acc[key] = (acc[key] || 0) + 1;
                        return acc;
                    }, {})
                },
                metrics: {
                    voltage: Number.isFinite(result.voltage) ? result.voltage : 0,
                    current: Number.isFinite(result.current) ? result.current : 0,
                    resistance: Number.isFinite(result.resistance) ? result.resistance : null,
                    power: Number.isFinite(result.power) ? result.power : 0,
                    isComplete: Boolean(flowMeta?.hasFlow),
                    reason: flowMeta?.reason,
                    flow: flowMeta
                }
            };
            notifyParentCircuitState(snapshot);
            return circuitResult;
        }

        function getTerminalKey(entity, side) {
            if (!entity) return null;
            if (entity.type) {
                return `${entity.id}:${side}`;
            }
            if (entity.id) {
                return `${entity.id}:${side || 'center'}`;
            }
            return null;
        }

        function getComponentTerminals(component) {
            switch(component?.type) {
                case 'battery':
                    return ['negative', 'positive'];
                case 'resistor':
                case 'led':
                case 'switch':
                case 'capacitor':
                case 'capacitor-ceramic':
                case 'inductor':
                case 'diode':
                case 'zener-diode':
                case 'photodiode':
                case 'thermistor':
                case 'crystal':
                case 'fuse':
                case 'lamp':
                case 'ac_source':
                case 'motor':
                case 'speaker':
                    return ['left', 'right'];
                default:
                    return [];
            }
        }

        function getDirectionalComponentConfig(component) {
            if (!component) return null;
            if (component.type === 'led' || component.type === 'diode' || component.type === 'zener-diode' || component.type === 'photodiode') {
                return { directional: true, forwardFrom: 'left', forwardTo: 'right' };
            }
            return null;
        }

        function getComponentResistance(component) {
            if (!component) {
                return Infinity;
            }

            if (component.type === 'resistor') {
                // Ensure resistors always have some resistance - default to 100 ohms if not set
                const r = Number(component.properties?.resistance);
                return isFinite(r) && r > 0 ? r : 100;
            }

            if (component.type === 'led') {
                // LEDs have internal resistance, default to 10 ohms for current limiting
                const r = Number(component.properties?.resistance);
                return isFinite(r) && r > 0 ? r : 10;
            }

            if (component.type === 'switch') {
                if (!component.properties?.isOn) {
                    return Infinity;
                }
                return Number(component.properties?.resistance) || Number(component.properties?.onResistance) || 0.05;
            }

            if (component.type === 'thermistor') {
                const r = Number(component.properties?.resistance);
                return isFinite(r) && r > 0 ? r : 10000;
            }

            if (component.type === 'battery') {
                return Number(component.properties?.internalResistance) || FLOW_CONSTANTS.wireResistance;
            }

            if (component.type === 'diode' || component.type === 'zener-diode' || component.type === 'photodiode') {
                return Number(component.properties?.forwardResistance) || 0.2;
            }

            if (component.type === 'lamp') {
                const r = Number(component.properties?.resistance);
                return isFinite(r) && r > 0 ? r : 10;
            }

            if (component.type === 'motor' || component.type === 'speaker') {
                const r = Number(component.properties?.resistance);
                return isFinite(r) && r > 0 ? r : 10;
            }

            if (component.type === 'inductor') {
                // Inductors have very low DC resistance
                return Number(component.properties?.dcResistance) || 0.1;
            }

            if (component.type === 'fuse') {
                return Number(component.properties?.resistance) || 0.05;
            }

            return FLOW_CONSTANTS.wireResistance;
        }

        function computeSpeedFactor(resistance) {
            if (!isFinite(resistance) || resistance <= 0) {
                return FLOW_CONSTANTS.maxSpeedFactor;
            }

            const normalized = resistance / FLOW_CONSTANTS.resistanceReference;
            const speed = FLOW_CONSTANTS.maxSpeedFactor / (1 + normalized);
            return Math.max(FLOW_CONSTANTS.minSpeedFactor, Math.min(FLOW_CONSTANTS.maxSpeedFactor, speed));
        }

        function buildFlowGraph(components, wires, junctions) {
            const adjacency = new Map();

            function ensureNode(key) {
                if (!key) return;
                if (!adjacency.has(key)) {
                    adjacency.set(key, []);
                }
            }

            function addEdge(fromKey, edge) {
                if (!fromKey || !edge?.to) return;
                ensureNode(fromKey);
                adjacency.get(fromKey).push(edge);
            }

            components.forEach(component => {
                const sides = getComponentTerminals(component);
                sides.forEach(side => ensureNode(getTerminalKey(component, side)));
            });

            junctions.forEach(junction => {
                ensureNode(getTerminalKey(junction, 'center'));
            });

            wires.forEach(wire => {
                const startKey = getTerminalKey(wire.startObj, wire.startSide || 'center');
                const endKey = getTerminalKey(wire.endObj, wire.endSide || 'center');
                if (!startKey || !endKey) return;

                addEdge(startKey, {
                    to: endKey,
                    type: 'wire',
                    wire,
                    resistance: FLOW_CONSTANTS.wireResistance,
                    direction: 1,
                    fromSide: wire.startSide || 'center',
                    toSide: wire.endSide || 'center'
                });

                addEdge(endKey, {
                    to: startKey,
                    type: 'wire',
                    wire,
                    resistance: FLOW_CONSTANTS.wireResistance,
                    direction: -1,
                    fromSide: wire.endSide || 'center',
                    toSide: wire.startSide || 'center'
                });
            });

            components.forEach(component => {
                const sides = getComponentTerminals(component);
                if (component.type === 'battery' || sides.length !== 2) {
                    return;
                }

                const [sideA, sideB] = sides;
                const keyA = getTerminalKey(component, sideA);
                const keyB = getTerminalKey(component, sideB);
                if (!keyA || !keyB) return;

                const resistance = getComponentResistance(component);
                if (!isFinite(resistance)) {
                    return;
                }

                const directionalConfig = getDirectionalComponentConfig(component);
                if (directionalConfig?.directional) {
                    const fromKey = getTerminalKey(component, directionalConfig.forwardFrom);
                    const toKey = getTerminalKey(component, directionalConfig.forwardTo);
                    if (fromKey && toKey) {
                        addEdge(fromKey, {
                            to: toKey,
                            type: 'component',
                            component,
                            resistance,
                            directional: true,
                            direction: 1,
                            fromSide: directionalConfig.forwardFrom,
                            toSide: directionalConfig.forwardTo
                        });
                    }
                } else {
                    addEdge(keyA, {
                        to: keyB,
                        type: 'component',
                        component,
                        resistance,
                        directional: false,
                        direction: 1,
                        fromSide: sideA,
                        toSide: sideB
                    });

                    addEdge(keyB, {
                        to: keyA,
                        type: 'component',
                        component,
                        resistance,
                        directional: false,
                        direction: -1,
                        fromSide: sideB,
                        toSide: sideA
                    });
                }
            });

            return adjacency;
        }

        // --- DC nodal analysis for measurement tools (multimeter/scope) ---
        function gaussianSolve(A, b) {
            const n = b.length;
            const M = A.map(row => row.slice());
            const x = b.slice();
            const EPS = 1e-12;

            for (let col = 0; col < n; col += 1) {
                let pivotRow = col;
                let pivotAbs = Math.abs(M[col][col]);
                for (let r = col + 1; r < n; r += 1) {
                    const v = Math.abs(M[r][col]);
                    if (v > pivotAbs) {
                        pivotAbs = v;
                        pivotRow = r;
                    }
                }
                if (pivotAbs < EPS) return null;

                if (pivotRow !== col) {
                    const tmpRow = M[col];
                    M[col] = M[pivotRow];
                    M[pivotRow] = tmpRow;
                    const tmpB = x[col];
                    x[col] = x[pivotRow];
                    x[pivotRow] = tmpB;
                }

                const pivot = M[col][col];
                for (let c = col; c < n; c += 1) M[col][c] /= pivot;
                x[col] /= pivot;

                for (let r = 0; r < n; r += 1) {
                    if (r === col) continue;
                    const factor = M[r][col];
                    if (Math.abs(factor) < EPS) continue;
                    for (let c = col; c < n; c += 1) {
                        M[r][c] -= factor * M[col][c];
                    }
                    x[r] -= factor * x[col];
                }
            }
            return x;
        }

        function buildUnionFind() {
            const parent = new Map();
            const ensure = (k) => {
                const key = String(k || '');
                if (!key) return null;
                if (!parent.has(key)) parent.set(key, key);
                return key;
            };
            const find = (k) => {
                const key = ensure(k);
                if (!key) return null;
                let x = key;
                while (parent.get(x) !== x) {
                    parent.set(x, parent.get(parent.get(x)));
                    x = parent.get(x);
                }
                return x;
            };
            const union = (a, b) => {
                const ra = find(a);
                const rb = find(b);
                if (!ra || !rb) return;
                if (ra !== rb) parent.set(rb, ra);
            };
            return { parent, ensure, find, union };
        }

        function getBatteryTerminals(component) {
            return { neg: getTerminalKey(component, 'negative'), pos: getTerminalKey(component, 'positive') };
        }

        function buildElectricalNodesLegacy(options = {}) {
            const includeBatteryShorts = Boolean(options.includeBatteryShorts);
            const uf = buildUnionFind();

            // Ensure terminals exist
            components.forEach(comp => {
                if (!comp) return;
                const sides = getComponentTerminals(comp);
                sides.forEach(side => uf.ensure(getTerminalKey(comp, side)));
            });
            junctions.forEach(j => uf.ensure(getTerminalKey(j, 'center')));
            wires.forEach(w => {
                uf.ensure(getTerminalKey(w.startObj, w.startSide || 'center'));
                uf.ensure(getTerminalKey(w.endObj, w.endSide || 'center'));
            });

            // Wires are ideal shorts
            wires.forEach(wire => {
                const a = getTerminalKey(wire.startObj, wire.startSide || 'center');
                const b = getTerminalKey(wire.endObj, wire.endSide || 'center');
                if (a && b) uf.union(a, b);
            });

            // For resistance measurements we "deactivate" sources (short ideal voltage sources)
            if (includeBatteryShorts) {
                components.filter(c => c?.type === 'battery').forEach(bat => {
                    const { neg, pos } = getBatteryTerminals(bat);
                    if (neg && pos) uf.union(neg, pos);
                });
            }

            const terminalToNode = new Map();
            for (const key of uf.parent.keys()) {
                const root = uf.find(key);
                if (root) terminalToNode.set(key, root);
            }

            const nodeIds = new Set(Array.from(terminalToNode.values()));
            return { terminalToNode, nodeIds };
        }

        function buildNetlistLegacy(terminalToNode) {
            const resistors = [];
            const sources = [];

            const nodeOf = (terminalKey) => terminalToNode.get(terminalKey) || null;

            components.forEach(comp => {
                if (!comp) return;
                if (comp.type === 'battery') {
                    const { neg, pos } = getBatteryTerminals(comp);
                    const nNeg = neg ? nodeOf(neg) : null;
                    const nPos = pos ? nodeOf(pos) : null;
                    if (!nNeg || !nPos || nNeg === nPos) return;
                    const volts = Number.isFinite(comp.properties?.voltage) ? Number(comp.properties.voltage) : 9;
                    sources.push({
                        id: `vs:${comp.id}`,
                        elementId: comp.id,
                        positiveNode: nPos,
                        negativeNode: nNeg,
                        volts
                    });
                    return;
                }

                const sides = getComponentTerminals(comp);
                if (!Array.isArray(sides) || sides.length !== 2) return;
                if (comp.type === 'switch' && comp.properties?.isOn === false) {
                    return; // open circuit
                }

                const aKey = getTerminalKey(comp, sides[0]);
                const bKey = getTerminalKey(comp, sides[1]);
                const a = aKey ? nodeOf(aKey) : null;
                const b = bKey ? nodeOf(bKey) : null;
                if (!a || !b || a === b) return;

                const ohms = getComponentResistance(comp);
                if (!Number.isFinite(ohms) || ohms <= 0) return;

                resistors.push({
                    elementId: comp.id,
                    kind: comp.type,
                    a,
                    b,
                    ohms
                });
            });

            return { resistors, sources };
        }

        function pickReferenceNodeLegacy(terminalToNode, nodeIds) {
            const firstBattery = components.find(c => c?.type === 'battery');
            if (firstBattery) {
                const { neg } = getBatteryTerminals(firstBattery);
                const node = neg ? terminalToNode.get(neg) : null;
                if (node) return node;
            }
            const first = nodeIds.values().next();
            return first.done ? null : first.value;
        }

        function solveDCCircuitLegacy() {
            const { terminalToNode, nodeIds } = buildElectricalNodesLegacy();
            const { resistors, sources } = buildNetlistLegacy(terminalToNode);

            const globalRef = pickReferenceNodeLegacy(terminalToNode, nodeIds);
            if (!globalRef) {
                return {
                    status: 'no_reference',
                    reason: 'No terminals available for a reference node.',
                    nodeVoltages: new Map(),
                    elementCurrents: new Map(),
                    referenceNodeId: null,
                    terminalToNode
                };
            }

            // Default all nodes to 0 V (covers unsolved floating components)
            const nodeVoltages = new Map();
            nodeIds.forEach(id => nodeVoltages.set(id, 0));
            const elementCurrents = new Map();

            // Partition into connected components (prevents singular matrices for floating subcircuits)
            const nodes = Array.from(nodeIds);
            const nodeToIdx = new Map(nodes.map((id, idx) => [id, idx]));
            const parent = nodes.map((_, idx) => idx);
            const find = (i) => {
                let x = i;
                while (parent[x] !== x) {
                    parent[x] = parent[parent[x]];
                    x = parent[x];
                }
                return x;
            };
            const union = (a, b) => {
                const ia = nodeToIdx.get(a);
                const ib = nodeToIdx.get(b);
                if (ia === undefined || ib === undefined) return;
                const ra = find(ia);
                const rb = find(ib);
                if (ra !== rb) parent[rb] = ra;
            };
            resistors.forEach(r => union(r.a, r.b));
            sources.forEach(s => union(s.positiveNode, s.negativeNode));

            const componentMap = new Map();
            nodes.forEach(id => {
                const root = find(nodeToIdx.get(id));
                if (!componentMap.has(root)) componentMap.set(root, new Set());
                componentMap.get(root).add(id);
            });

            let primaryReferenceNodeId = globalRef;
            const componentRoots = Array.from(componentMap.keys());
            for (const root of componentRoots) {
                const compNodes = componentMap.get(root);
                const compSources = sources.filter(s => compNodes.has(s.positiveNode) && compNodes.has(s.negativeNode));
                const compResistors = resistors.filter(r => compNodes.has(r.a) && compNodes.has(r.b));

                if (!compSources.length) {
                    compResistors.forEach(r => {
                        elementCurrents.set(r.elementId, { elementId: r.elementId, amps: 0 });
                    });
                    continue;
                }

                const referenceNodeId = compNodes.has(primaryReferenceNodeId)
                    ? primaryReferenceNodeId
                    : compNodes.values().next().value;
                primaryReferenceNodeId = primaryReferenceNodeId || referenceNodeId;

                const unknownNodes = Array.from(compNodes).filter(n => n !== referenceNodeId);
                const nodeIndex = new Map(unknownNodes.map((id, idx) => [id, idx]));
                const n = unknownNodes.length;
                const m = compSources.length;
                const dim = n + m;

                if (dim === 0) {
                    nodeVoltages.set(referenceNodeId, 0);
                    continue;
                }

                const A = Array.from({ length: dim }, () => Array.from({ length: dim }, () => 0));
                const bVec = Array.from({ length: dim }, () => 0);
                const EPS = 1e-12;

                const idxV = (nodeId) => (nodeId === referenceNodeId ? null : (nodeIndex.get(nodeId) ?? null));
                const idxI = (k) => n + k;

                for (const r of compResistors) {
                    const g = r.ohms > EPS ? 1 / r.ohms : 1 / EPS;
                    const ia = idxV(r.a);
                    const ib = idxV(r.b);
                    if (ia !== null) A[ia][ia] += g;
                    if (ib !== null) A[ib][ib] += g;
                    if (ia !== null && ib !== null) {
                        A[ia][ib] -= g;
                        A[ib][ia] -= g;
                    }
                }

                for (let k = 0; k < compSources.length; k += 1) {
                    const src = compSources[k];
                    const ip = idxV(src.positiveNode);
                    const ineg = idxV(src.negativeNode);
                    const colI = idxI(k);
                    if (ip !== null) A[ip][colI] += 1;
                    if (ineg !== null) A[ineg][colI] -= 1;
                    const row = idxI(k);
                    if (ip !== null) A[row][ip] += 1;
                    if (ineg !== null) A[row][ineg] -= 1;
                    bVec[row] = src.volts;
                }

                const solved = gaussianSolve(A, bVec);
                if (!solved) {
                    return {
                        status: 'singular',
                        reason: 'Circuit matrix is singular (floating network or ideal-only loop).',
                        nodeVoltages,
                        elementCurrents,
                        referenceNodeId: globalRef,
                        terminalToNode
                    };
                }

                nodeVoltages.set(referenceNodeId, 0);
                unknownNodes.forEach(nodeId => {
                    nodeVoltages.set(nodeId, solved[nodeIndex.get(nodeId)]);
                });

                const V = (nodeId) => nodeVoltages.get(nodeId) ?? 0;

                // Currents through resistor-like elements
                for (const r of compResistors) {
                    const amps = (V(r.a) - V(r.b)) / r.ohms;
                    elementCurrents.set(r.elementId, { elementId: r.elementId, amps });
                }

                // Currents through sources (positive-to-negative)
                for (let k = 0; k < compSources.length; k += 1) {
                    const src = compSources[k];
                    const amps = solved[idxI(k)];
                    elementCurrents.set(src.elementId, { elementId: src.elementId, amps });
                }
            }

            return {
                status: 'solved',
                nodeVoltages,
                elementCurrents,
                referenceNodeId: primaryReferenceNodeId,
                terminalToNode
            };
        }

        function getVoltageBetweenProbes(probeA, probeB, solution) {
            if (!probeA || !probeB || !solution || solution.status !== 'solved') return NaN;
            const aKey = getPointTerminalKey(probeA);
            const bKey = getPointTerminalKey(probeB);
            if (!aKey || !bKey) return NaN;
            const nodeA = solution.terminalToNode?.get(aKey);
            const nodeB = solution.terminalToNode?.get(bKey);
            if (!nodeA || !nodeB) return NaN;
            const vA = solution.nodeVoltages.get(nodeA) ?? 0;
            const vB = solution.nodeVoltages.get(nodeB) ?? 0;
            return vA - vB;
        }

        function getComponentCurrentFromSolution(component, solution) {
            if (!component || !solution || solution.status !== 'solved') return NaN;
            const entry = solution.elementCurrents?.get(component.id);
            if (entry && typeof entry.amps === 'number') {
                return entry.amps;
            }
            // Fallback: compute for resistor-like components
            const sides = getComponentTerminals(component);
            if (!Array.isArray(sides) || sides.length !== 2) return NaN;
            const aKey = getTerminalKey(component, sides[0]);
            const bKey = getTerminalKey(component, sides[1]);
            const nodeA = aKey ? solution.terminalToNode?.get(aKey) : null;
            const nodeB = bKey ? solution.terminalToNode?.get(bKey) : null;
            if (!nodeA || !nodeB) return NaN;
            const ohms = getComponentResistance(component);
            if (!Number.isFinite(ohms) || ohms <= 0) return NaN;
            const vA = solution.nodeVoltages.get(nodeA) ?? 0;
            const vB = solution.nodeVoltages.get(nodeB) ?? 0;
            return (vA - vB) / ohms;
        }

        function getEquivalentResistanceBetweenProbes(probeA, probeB) {
            if (!probeA || !probeB) return NaN;
            const aKey = getPointTerminalKey(probeA);
            const bKey = getPointTerminalKey(probeB);
            if (!aKey || !bKey) return NaN;
            if (aKey === bKey) return 0;

            // Build nodes with wires + (deactivated) battery shorts merged
            const { terminalToNode, nodeIds } = buildElectricalNodesLegacy({ includeBatteryShorts: true });

            const nodeA = terminalToNode.get(aKey);
            const nodeB = terminalToNode.get(bKey);
            if (!nodeA || !nodeB) return Infinity;
            if (nodeA === nodeB) return 0;

            // Collect resistive elements only (no active sources)
            const { resistors } = buildNetlistLegacy(terminalToNode);

            // Connectivity check: if nodes aren't connected through resistors, it's open
            const nodeList = Array.from(nodeIds);
            const nodeToIdx = new Map(nodeList.map((id, idx) => [id, idx]));
            const uf = nodeList.map((_, idx) => idx);
            const find = (i) => {
                let x = i;
                while (uf[x] !== x) {
                    uf[x] = uf[uf[x]];
                    x = uf[x];
                }
                return x;
            };
            const union = (u, v) => {
                const iu = nodeToIdx.get(u);
                const iv = nodeToIdx.get(v);
                if (iu === undefined || iv === undefined) return;
                const ru = find(iu);
                const rv = find(iv);
                if (ru !== rv) uf[rv] = ru;
            };
            resistors.forEach(r => union(r.a, r.b));
            if (find(nodeToIdx.get(nodeA)) !== find(nodeToIdx.get(nodeB))) {
                return Infinity;
            }

            // Nodal solve with nodeB as reference, inject +1A at nodeA and return to nodeB
            const referenceNodeId = nodeB;
            const unknownNodes = nodeList.filter(n => n !== referenceNodeId);
            const n = unknownNodes.length;
            if (n === 0) return 0;

            const idx = new Map(unknownNodes.map((id, i) => [id, i]));
            const G = Array.from({ length: n }, () => Array.from({ length: n }, () => 0));
            const I = Array.from({ length: n }, () => 0);
            const EPS = 1e-12;

            const stampG = (a, b, g) => {
                const ia = a === referenceNodeId ? null : (idx.get(a) ?? null);
                const ib = b === referenceNodeId ? null : (idx.get(b) ?? null);
                if (ia !== null) G[ia][ia] += g;
                if (ib !== null) G[ib][ib] += g;
                if (ia !== null && ib !== null) {
                    G[ia][ib] -= g;
                    G[ib][ia] -= g;
                }
            };

            resistors.forEach(r => {
                const g = r.ohms > EPS ? 1 / r.ohms : 1 / EPS;
                stampG(r.a, r.b, g);
            });

            if (nodeA !== referenceNodeId) {
                I[idx.get(nodeA)] += 1;
            }

            const solved = gaussianSolve(G, I);
            if (!solved) return Infinity;

            const vA = nodeA === referenceNodeId ? 0 : solved[idx.get(nodeA)];
            return Number.isFinite(vA) ? Math.abs(vA) : Infinity;
        }

        function findLowestResistancePath(adjacency, startKey, endKey) {
            if (!startKey || !endKey || !adjacency.has(startKey) || !adjacency.has(endKey)) {
                return null;
            }

            const distances = new Map();
            const previous = new Map();
            const queue = [];

            distances.set(startKey, 0);
            queue.push({ key: startKey, distance: 0 });

            while (queue.length > 0) {
                queue.sort((a, b) => a.distance - b.distance);
                const current = queue.shift();
                if (!current) break;

                if (current.key === endKey) {
                    break;
                }

                if (current.distance > (distances.get(current.key) ?? Infinity)) {
                    continue;
                }

                const edges = adjacency.get(current.key) || [];
                edges.forEach(edge => {
                    if (!edge || !edge.to || !isFinite(edge.resistance)) {
                        return;
                    }

                    const nextDistance = current.distance + (edge.resistance ?? FLOW_CONSTANTS.wireResistance);
                    if (nextDistance < (distances.get(edge.to) ?? Infinity)) {
                        distances.set(edge.to, nextDistance);
                        previous.set(edge.to, { from: current.key, via: edge });
                        queue.push({ key: edge.to, distance: nextDistance });
                    }
                });
            }

            if (!distances.has(endKey)) {
                return null;
            }

            const segments = [];
            let cursor = endKey;
            while (cursor !== startKey) {
                const step = previous.get(cursor);
                if (!step) {
                    return null;
                }
                segments.unshift({ from: step.from, to: cursor, edge: step.via });
                cursor = step.from;
            }

            return {
                segments,
                totalResistance: distances.get(endKey) ?? Infinity
            };
        }

        function computeFlowState(batteries, components, wires, junctions) {
            if (!batteries || batteries.length === 0) {
                return { hasPath: false, reason: 'no-source' };
            }

            const sourceBattery = batteries[0];
            const startKey = getTerminalKey(sourceBattery, 'negative');
            const endKey = getTerminalKey(sourceBattery, 'positive');

            const adjacency = buildFlowGraph(components, wires, junctions);
            const path = findLowestResistancePath(adjacency, startKey, endKey);

            if (!path) {
                const polarityBlocked = hasClosedCircuitPath(sourceBattery, wires, components);
                return { hasPath: false, reason: polarityBlocked ? 'polarity' : 'open' };
            }

            const flowSegments = path.segments;
            const wireSegments = [];
            const componentSegments = [];

            flowSegments.forEach((segment, index) => {
                const edge = segment.edge;
                if (!edge) return;

                if (edge.type === 'wire' && edge.wire) {
                    wireSegments.push({
                        wire: edge.wire,
                        direction: edge.direction >= 0 ? 1 : -1,
                        resistance: edge.resistance ?? FLOW_CONSTANTS.wireResistance,
                        fromSide: edge.fromSide,
                        toSide: edge.toSide,
                        pathIndex: index
                    });
                } else if (edge.type === 'component' && edge.component) {
                    componentSegments.push({
                        component: edge.component,
                        direction: edge.direction >= 0 ? 1 : -1,
                        resistance: edge.resistance,
                        fromSide: edge.fromSide,
                        toSide: edge.toSide,
                        pathIndex: index
                    });
                }
            });

            const resistanceLookup = new Map();
            componentSegments.forEach(segment => {
                if (isFinite(segment.resistance)) {
                    resistanceLookup.set(segment.pathIndex, segment.resistance);
                }
            });

            const descriptiveWireSegments = wireSegments.map(segment => {
                const prevSeg = flowSegments[segment.pathIndex - 1];
                const nextSeg = flowSegments[segment.pathIndex + 1];

                const prevResistance = resistanceLookup.get(segment.pathIndex - 1);
                const nextResistance = resistanceLookup.get(segment.pathIndex + 1);

                const candidates = [];
                if (isFinite(prevResistance)) candidates.push(prevResistance);
                if (isFinite(nextResistance)) candidates.push(nextResistance);

                let adjacentResistance = segment.resistance;
                if (candidates.length === 1) {
                    adjacentResistance = candidates[0];
                } else if (candidates.length === 2) {
                    adjacentResistance = (candidates[0] + candidates[1]) / 2;
                }

                return {
                    wire: segment.wire,
                    direction: segment.direction,
                    speedFactor: computeSpeedFactor(adjacentResistance),
                    fromSide: segment.fromSide,
                    toSide: segment.toSide
                };
            });

            const totalPathResistance = flowSegments.reduce((sum, segment) => {
                const res = segment.edge?.resistance;
                if (!isFinite(res)) {
                    return sum;
                }
                return sum + (res ?? 0);
            }, 0);

            const hasResistiveElement = componentSegments.some(segment => {
                return isFinite(segment.resistance) && segment.resistance > FLOW_CONSTANTS.wireResistance * 2;
            });

            const isShortCircuit = totalPathResistance <= FLOW_CONSTANTS.shortThreshold && !hasResistiveElement;

            return {
                hasPath: true,
                wireSegments: descriptiveWireSegments,
                componentSegments,
                pathResistance: totalPathResistance,
                shortCircuit: isShortCircuit,
                hasResistiveElement
            };
        }

        function sanitizeFlowState(flowState) {
            if (!flowState) {
                return null;
            }

            return {
                hasPath: Boolean(flowState.hasPath),
                hasFlow: Boolean(flowState.hasFlow),
                reason: flowState.reason || null,
                warning: flowState.warning || null,
                shortCircuit: Boolean(flowState.shortCircuit),
                pathResistance: typeof flowState.pathResistance === 'number' ? flowState.pathResistance : null,
                hasResistiveElement: Boolean(flowState.hasResistiveElement),
                currentValue: typeof flowState.currentValue === 'number' ? flowState.currentValue : 0,
                totalVoltage: typeof flowState.totalVoltage === 'number' ? flowState.totalVoltage : null,
                wireSegments: Array.isArray(flowState.wireSegments)
                    ? flowState.wireSegments.map(segment => ({
                        wireId: segment.wire?.id || null,
                        direction: segment.direction,
                        speedFactor: segment.speedFactor
                    }))
                    : []
            };
        }

        function performCircuitAnalysis() {
            const batteries = components.filter(c => c.type === 'battery');
            const resistors = components.filter(c => c.type === 'resistor' || c.type === 'led');
            const switches = components.filter(c => c.type === 'switch');
            
            const openSwitches = switches.filter(sw => !sw.properties.isOn);
            if (openSwitches.length > 0) {
                const totalVoltage = batteries.reduce((sum, bat) => sum + bat.properties.voltage, 0);
                updateTopologyDisplay('Open Circuit');
                const flowResult = {
                    hasPath: false,
                    hasFlow: false,
                    reason: 'open',
                    warning: null,
                    shortCircuit: false,
                    pathResistance: Infinity,
                    hasResistiveElement: false,
                    currentValue: 0,
                    totalVoltage
                };
                currentFlowState = flowResult;
                return {
                    voltage: totalVoltage,
                    current: 0,
                    resistance: Infinity,
                    power: 0,
                    isComplete: false,
                    topology: 'open',
                    flow: sanitizeFlowState(flowResult)
                };
            }
            
            const connectedComponents = new Set();
            wires.forEach(wire => {
                connectedComponents.add(wire.startObj);
                connectedComponents.add(wire.endObj);
            });
            
            const connectedBatteries = batteries.filter(battery => connectedComponents.has(battery));
            
            // Check if we have batteries and they form a closed circuit
            if (connectedBatteries.length > 0 && connectedComponents.size >= 2) {
                // Verify the circuit is actually closed (has a complete path)
                const hasClosedPath = connectedBatteries.some(battery => 
                    hasClosedCircuitPath(battery, wires, components)
                );
                
                if (!hasClosedPath) {
                    // Circuit has components but no closed loop
                    const totalVoltage = batteries.reduce((sum, bat) => sum + bat.properties.voltage, 0);
                    updateTopologyDisplay('Incomplete');
                    const flowResult = {
                        hasPath: false,
                        hasFlow: false,
                        reason: 'open',
                        warning: null,
                        shortCircuit: false,
                        pathResistance: Infinity,
                        hasResistiveElement: false,
                        currentValue: 0,
                        totalVoltage
                    };
                    currentFlowState = flowResult;
                    return {
                        voltage: totalVoltage,
                        current: 0,
                        resistance: Infinity,
                        power: 0,
                        isComplete: false,
                        topology: 'incomplete',
                        flow: sanitizeFlowState(flowResult)
                    };
                }
                
                let totalVoltage = 0;
                batteries.forEach(battery => totalVoltage += battery.properties.voltage);
                
                // Detect circuit topology
                const topology = detectCircuitTopology(resistors, wires, junctions);
                const flowState = computeFlowState(batteries, components, wires, junctions);

                if (!flowState.hasPath) {
                    // Directed path finding failed. Only enable fallback flow animation if:
                    // 1. The reason is specifically 'polarity' (not 'open' circuit)
                    // 2. AND there's a verified physical closed loop
                    // This prevents current from flowing in genuinely open circuits.
                    const isPolarityIssue = flowState.reason === 'polarity';
                    const hasPhysicalLoop = isPolarityIssue && hasClosedCircuitPath(batteries[0], wires, components);

                    if (hasPhysicalLoop && wires.length > 0) {
                        // There's a closed loop but directed path finding failed due to polarity.
                        // Show flow animation to indicate circuit completion with polarity issue.
                        let approxResistance = FLOW_CONSTANTS.wireResistance;
                        resistors.forEach(r => {
                            approxResistance += r.properties?.resistance || 100;
                        });
                        switches.forEach(sw => {
                            if (sw.properties?.isOn) {
                                approxResistance += sw.properties?.resistance || 0.1;
                            }
                        });
                        const approxCurrent = totalVoltage / Math.max(approxResistance, FLOW_CONSTANTS.wireResistance, 0.001);

                        updateTopologyDisplay('Polarity');
                        const flowResult = {
                            ...flowState,
                            hasFlow: true,
                            currentValue: approxCurrent,
                            wireSegments: wires.map(wire => ({
                                wire,
                                direction: 1,
                                speedFactor: 1
                            })),
                            totalVoltage,
                            shortCircuit: false
                        };
                        currentFlowState = flowResult;
                        return {
                            voltage: totalVoltage,
                            current: approxCurrent,
                            resistance: approxResistance,
                            power: totalVoltage * approxCurrent,
                            isComplete: true,
                            topology: topology?.type || 'simple',
                            flow: sanitizeFlowState(flowResult)
                        };
                    }

                    // Open circuit or other non-polarity issue - no current flow
                    updateTopologyDisplay(flowState.reason === 'open' ? 'Open Circuit' : 'Polarity');
                    const flowResult = {
                        ...flowState,
                        hasFlow: false,
                        currentValue: 0,
                        shortCircuit: flowState.shortCircuit || false
                    };
                    currentFlowState = flowResult;
                    return {
                        voltage: totalVoltage,
                        current: 0,
                        resistance: Infinity,
                        power: 0,
                        isComplete: false,
                        topology: topology?.type || 'blocked',
                        flow: sanitizeFlowState(flowResult)
                    };
                }
                
                // Calculate resistance based on topology
                let totalResistance = FLOW_CONSTANTS.wireResistance; // Wire resistance baseline
                
                if (topology.type === 'series') {
                    // Series: R_total = R1 + R2 + ... + Rn
                    resistors.forEach(resistor => {
                        totalResistance += resistor.properties.resistance || 100;
                    });
                } else if (topology.type === 'parallel') {
                    // Parallel: 1/R_total = 1/R1 + 1/R2 + ... + 1/Rn
                    let reciprocalSum = 0;
                    resistors.forEach(resistor => {
                        const r = resistor.properties.resistance || 100;
                        reciprocalSum += 1 / r;
                    });
                    totalResistance += (reciprocalSum > 0) ? (1 / reciprocalSum) : 100;
                } else if (topology.type === 'combination') {
                    // For combination circuits, calculate series and parallel groups separately
                    totalResistance += calculateCombinationResistance(topology);
                } else {
                    // Unknown or simple circuit - use basic addition
                    resistors.forEach(resistor => {
                        totalResistance += resistor.properties.resistance || 100;
                    });
                }
                
                // Add switch resistance
                switches.forEach(sw => {
                    if (sw.properties.isOn) {
                        totalResistance += sw.properties.resistance || 0.1;
                    }
                });

                if (flowState.shortCircuit) {
                    totalResistance = Math.max(totalResistance, flowState.pathResistance || FLOW_CONSTANTS.shortThreshold, FLOW_CONSTANTS.shortThreshold);
                } else if (isFinite(flowState.pathResistance)) {
                    totalResistance = Math.max(totalResistance, flowState.pathResistance);
                }
                
                const current = totalVoltage / totalResistance;
                const power = totalVoltage * current;
                
                updateTopologyDisplay(topology.type);
                const flowResult = {
                    ...flowState,
                    hasFlow: true,
                    currentValue: current,
                    totalVoltage,
                    warning: flowState.shortCircuit ? 'short' : null
                };
                currentFlowState = flowResult;
                
                return {
                    voltage: totalVoltage,
                    current: current,
                    resistance: totalResistance,
                    power: power,
                    isComplete: true,
                    topology: topology?.type || 'unknown',
                    flow: sanitizeFlowState(flowResult)
                };
            } else {
                const totalVoltage = batteries.reduce((sum, bat) => sum + bat.properties.voltage, 0);
                updateTopologyDisplay(connectedComponents.size === 0 ? 'No Circuit' : 'Incomplete');
                const flowResult = {
                    hasPath: false,
                    hasFlow: false,
                    reason: connectedComponents.size === 0 ? 'no-source' : 'open',
                    warning: null,
                    shortCircuit: false,
                    pathResistance: Infinity,
                    hasResistiveElement: false,
                    currentValue: 0,
                    totalVoltage
                };
                currentFlowState = flowResult;
                return {
                    voltage: totalVoltage,
                    current: 0,
                    resistance: Infinity,
                    power: 0,
                    isComplete: false,
                    topology: connectedComponents.size === 0 ? 'none' : 'incomplete',
                    flow: sanitizeFlowState(flowResult)
                };
            }
        }
        
        const ARENA_COMPONENT_PROFILES = {
            battery: {
                defaultProperties: {
                    voltage: 9,
                    internalResistance: 0.2,
                    capacityMah: 1500,
                    tempCoeff: 0.0004,
                    thermalResistance: 35,
                    maxDischargeCurrent: 2.0
                },
                classification: 'energy-source'
            },
            resistor: {
                defaultProperties: {
                    resistance: 100,
                    tempCoeff: 0.0005,
                    tolerance: 0.05,
                    thermalResistance: 75,
                    maxPower: 0.25
                },
                classification: 'passive'
            },
            led: {
                defaultProperties: {
                    forwardVoltage: 2.0,
                    seriesResistance: 120,
                    efficiency: 0.35,
                    thermalResistance: 120,
                    luminousFlux: 8
                },
                classification: 'optoelectronic'
            },
            switch: {
                defaultProperties: {
                    onResistance: 0.05,
                    offResistance: 1000000,
                    transitionTimeMs: 2,
                    insulationResistance: 5000000
                },
                classification: 'control'
            }
        };

        function cloneJsonSafe(input) {
            try {
                return JSON.parse(JSON.stringify(input));
            } catch (error) {
                console.warn('Arena export: unable to clone data', error);
                return null;
            }
        }

        function serializeComponentForArena(component) {
            if (!component) {
                return null;
            }

            const profile = ARENA_COMPONENT_PROFILES[component.type] || { defaultProperties: {}, classification: 'unspecified' };
            const baseProperties = cloneJsonSafe(component.properties) || {};
            const enrichedProperties = Object.assign({}, profile.defaultProperties || {}, baseProperties);

            const connections = (component.connections || []).map(connection => ({
                wireId: connection?.wire?.id || null,
                targetId: connection?.connectedTo?.id || null,
                side: connection?.side || null
            })).filter(Boolean);

            return {
                id: component.id,
                type: component.type,
                identifier: typeof component.getComponentIdentifier === 'function'
                    ? component.getComponentIdentifier()
                    : (component.type + '_' + component.componentNumber),
                componentNumber: component.componentNumber || null,
                rotation: component.rotation || 0,
                position: {
                    x: component.position?.x || 0,
                    y: component.position?.y || 0,
                    z: component.position?.z || 0
                },
                properties: enrichedProperties,
                metadata: {
                    classification: profile.classification,
                    displayName: typeof component.getComponentIdentifier === 'function'
                        ? component.getComponentIdentifier()
                        : component.type,
                    createdAt: new Date().toISOString(),
                    vendor: enrichedProperties.manufacturer || 'CircuiTry Virtual Builder',
                    partNumber: enrichedProperties.partNumber || (component.type.toUpperCase() + '-' + (component.componentNumber || 'X')),
                    tolerance: enrichedProperties.tolerance || null
                },
                connections
            };
        }

        function serializeWireForArena(wire) {
            if (!wire) {
                return null;
            }

            return {
                id: wire.id,
                startComponentId: wire.startObj?.id || null,
                startSide: wire.startSide || null,
                endComponentId: wire.endObj?.id || null,
                endSide: wire.endSide || null,
                segments: (wire.segments || []).map(segment => ({
                    start: {
                        x: segment?.start?.x || 0,
                        y: segment?.start?.y || 0,
                        z: segment?.start?.z || 0
                    },
                    end: {
                        x: segment?.end?.x || 0,
                        y: segment?.end?.y || 0,
                        z: segment?.end?.z || 0
                    }
                }))
            };
        }

        function serializeJunctionForArena(junction) {
            if (!junction) {
                return null;
            }

            return {
                id: junction.id,
                position: {
                    x: junction.position?.x || 0,
                    y: junction.position?.y || 0,
                    z: junction.position?.z || 0
                }
            };
        }

        function computeAdvancedCircuitMetrics(basicResult, componentList, options) {
            const defaults = options || {};
            const frequencyHz = typeof defaults.frequencyHz === 'number' ? defaults.frequencyHz : 0;
            const temperatureC = typeof defaults.temperatureC === 'number' ? defaults.temperatureC : 25;
            const durationSeconds = typeof defaults.durationSeconds === 'number' ? defaults.durationSeconds : 60;

            let totalResistance = 0;
            let totalCapacitance = 0;
            let totalInductance = 0;
            let thermalMass = 0;

            componentList.forEach(component => {
                if (!component) return;

                const profile = ARENA_COMPONENT_PROFILES[component.type] || {};
                const props = component.properties || {};

                if (typeof props.resistance === 'number') {
                    totalResistance += Math.max(props.resistance, 0);
                }

                if (typeof props.seriesResistance === 'number') {
                    totalResistance += Math.max(props.seriesResistance, 0);
                }

                if (typeof props.onResistance === 'number' && props.isOn !== false) {
                    totalResistance += Math.max(props.onResistance, 0);
                }

                if (typeof props.capacitance === 'number') {
                    totalCapacitance += Math.max(props.capacitance, 0);
                }

                if (typeof props.inductance === 'number') {
                    totalInductance += Math.max(props.inductance, 0);
                }

                if (typeof props.thermalResistance === 'number') {
                    thermalMass += Math.max(props.thermalResistance, 0);
                } else if (profile.defaultProperties?.thermalResistance) {
                    thermalMass += profile.defaultProperties.thermalResistance;
                }
            });

            const omega = 2 * Math.PI * Math.max(frequencyHz, 0);
            const reactanceC = totalCapacitance > 0 && omega > 0 ? -1 / (omega * totalCapacitance) : 0;
            const reactanceL = totalInductance > 0 && omega > 0 ? omega * totalInductance : 0;
            const netReactance = reactanceL + reactanceC; // capacitor already negative
            const resistivePart = Number.isFinite(basicResult?.resistance) ? basicResult.resistance : totalResistance;
            const impedance = Math.sqrt(Math.pow(Math.max(resistivePart, 0), 2) + Math.pow(netReactance, 2));
            const phaseAngle = Math.atan2(netReactance, Math.max(resistivePart, 0));

            const voltage = Math.max(basicResult?.voltage || 0, 0);
            const current = Math.max(basicResult?.current || 0, 0);
            const power = Math.max(basicResult?.power || voltage * current, 0);

            const storedEnergyCap = totalCapacitance > 0 ? 0.5 * totalCapacitance * Math.pow(voltage, 2) : 0;
            const storedEnergyInd = totalInductance > 0 ? 0.5 * totalInductance * Math.pow(current, 2) : 0;
            const totalEnergy = storedEnergyCap + storedEnergyInd;

            const thermalRise = thermalMass > 0 ? power * (thermalMass / 1000) : 0;
            const energyDelivered = power * durationSeconds;

            return {
                totalResistance,
                totalCapacitance,
                totalInductance,
                impedance,
                netReactance,
                phaseAngleRadians: phaseAngle,
                phaseAngleDegrees: phaseAngle * (180 / Math.PI),
                storedEnergy: totalEnergy,
                energyDelivered,
                estimatedThermalRise: thermalRise,
                temperatureC,
                frequencyHz,
                durationSeconds,
                topology: basicResult?.topology || 'unknown'
            };
        }

        function buildArenaExportPayload(options) {
            const now = new Date();
            const basicAnalysis = performCircuitAnalysis();
            const componentPayload = components.map(serializeComponentForArena).filter(Boolean);
            const advancedMetrics = computeAdvancedCircuitMetrics(basicAnalysis, componentPayload, options?.testVariables);
            const wirePayload = wires.map(serializeWireForArena).filter(Boolean);
            const junctionPayload = junctions.map(serializeJunctionForArena).filter(Boolean);

            const testVariables = Object.assign({
                voltage: basicAnalysis?.voltage || 5,
                frequencyHz: options?.testVariables?.frequencyHz ?? 0,
                temperatureC: options?.testVariables?.temperatureC ?? 25,
                ambientHumidityPercent: options?.testVariables?.ambientHumidityPercent ?? 50,
                dutyCyclePercent: options?.testVariables?.dutyCyclePercent ?? 100,
                loadImpedanceOhms: advancedMetrics.impedance || basicAnalysis?.resistance || null,
                durationSeconds: options?.testVariables?.durationSeconds ?? 60
            }, options?.testVariables || {});

            return {
                version: '2025.11.02',
                sessionName: options?.sessionName || 'Legacy Builder Export',
                exportedAt: now.toISOString(),
                source: {
                    name: 'CircuiTry3D Builder',
                    type: 'virtual-workspace',
                    environment: 'legacy',
                    bridgeVersion: 'arena-export-v1'
                },
                components: componentPayload,
                wires: wirePayload,
                junctions: junctionPayload,
                analysis: {
                    basic: basicAnalysis,
                    advanced: advancedMetrics
                },
                testVariables,
                metadata: {
                    units: 'SI',
                    componentCount: componentPayload.length,
                    wireCount: wirePayload.length,
                    junctionCount: junctionPayload.length
                }
            };
        }

        function persistArenaSession(sessionId, envelope) {
            try {
                const serialized = JSON.stringify(envelope);
                if (typeof window !== 'undefined' && window.localStorage) {
                    window.localStorage.setItem('circuitry:arena-session:' + sessionId, serialized);
                    window.localStorage.setItem('circuitry:arena-session:last', sessionId);
                    return true;
                }
            } catch (error) {
                console.warn('Arena export: localStorage unavailable', error);
            }

            try {
                const serialized = JSON.stringify(envelope);
                if (typeof window !== 'undefined' && window.sessionStorage) {
                    window.sessionStorage.setItem('circuitry:arena-session:' + sessionId, serialized);
                    window.sessionStorage.setItem('circuitry:arena-session:last', sessionId);
                    return true;
                }
            } catch (error) {
                console.warn('Arena export: sessionStorage fallback unavailable', error);
            }

            return false;
        }

        function exportArenaSession(options) {
            const config = options || {};
            const requestId = config.requestId || null;
            const openWindow = Boolean(config.openWindow);

            try {
                const sessionId = config.sessionId || ('arena-' + Date.now() + '-' + Math.random().toString(36).substr(2, 6));
                const payload = buildArenaExportPayload(config);
                const envelope = {
                    sessionId,
                    exportedAt: payload.exportedAt,
                    version: payload.version,
                    payload
                };

                const persisted = persistArenaSession(sessionId, envelope);

                const summary = {
                    sessionId,
                    exportedAt: payload.exportedAt,
                    componentCount: payload.components.length,
                    wireCount: payload.wires.length,
                    junctionCount: payload.junctions.length,
                    analysis: payload.analysis,
                    testVariables: payload.testVariables,
                    storage: persisted ? 'localStorage' : 'volatile',
                    requestId
                };

                if (typeof window !== 'undefined' && window.parent && window.parent !== window) {
                    try {
                        window.parent.postMessage({ type: 'legacy:arena-export', payload: summary }, '*');
                    } catch (postError) {
                        console.warn('Arena export: unable to notify parent', postError);
                    }
                }

                if (openWindow && (!window.parent || window.parent === window)) {
                    try {
                        window.open('/arena?session=' + encodeURIComponent(sessionId), '_blank');
                    } catch (openError) {
                        console.warn('Arena export: unable to open arena window', openError);
                    }
                }

                return summary;
            } catch (error) {
                console.error('Arena export failed:', error);
                if (typeof window !== 'undefined' && window.parent && window.parent !== window) {
                    try {
                        window.parent.postMessage({
                            type: 'legacy:arena-export:error',
                            payload: {
                                message: error?.message || String(error),
                                requestId
                            }
                        }, '*');
                    } catch (postError) {
                        console.warn('Arena export: unable to notify parent about failure', postError);
                    }
                }
                return null;
            }
        }
        
        // Detect whether circuit is series, parallel, or combination
        function detectCircuitTopology(resistors, wires, junctions) {
            if (resistors.length === 0) {
                return { type: 'none', groups: [] };
            }
            
            // If there are junctions, likely parallel or combination
            if (junctions.length > 0) {
                // Check if junctions create parallel paths
                const hasParallelPaths = checkForParallelPaths(resistors, wires, junctions);
                if (hasParallelPaths) {
                    return { type: 'parallel', groups: [] };
                }
                return { type: 'combination', groups: [] };
            }
            
            // No junctions - check connection pattern
            // If all resistors are in a single chain, it's series
            if (resistors.length === 1) {
                return { type: 'series', groups: [resistors] };
            }
            
            // Check if all resistors are connected in sequence
            const isSeriesChain = checkSeriesConnection(resistors, wires);
            if (isSeriesChain) {
                return { type: 'series', groups: [resistors] };
            }
            
            return { type: 'simple', groups: [] };
        }
        
        // Check if resistors are connected in series (one after another)
        function checkSeriesConnection(resistors, wires) {
            if (resistors.length < 2) return true;
            
            // Build connection map
            const connectionMap = new Map();
            resistors.forEach(r => connectionMap.set(r, []));
            
            wires.forEach(wire => {
                if (resistors.includes(wire.startObj) && resistors.includes(wire.endObj)) {
                    connectionMap.get(wire.startObj).push(wire.endObj);
                    connectionMap.get(wire.endObj).push(wire.startObj);
                }
            });
            
            // In series, each resistor should connect to at most 2 other resistors
            // and they should form a single chain
            for (const [resistor, connections] of connectionMap) {
                if (connections.length > 2) return false; // Branching indicates not pure series
            }
            
            return true;
        }
        
        // Check if there are parallel current paths
        function checkForParallelPaths(resistors, wires, junctions) {
            // If there are junctions and multiple resistors, likely parallel
            if (junctions.length > 1 && resistors.length > 1) {
                // Count paths between junction pairs
                for (let i = 0; i < junctions.length; i++) {
                    for (let j = i + 1; j < junctions.length; j++) {
                        const paths = findPathsBetween(junctions[i], junctions[j], wires, resistors);
                        if (paths.length > 1) {
                            return true; // Multiple paths = parallel
                        }
                    }
                }
            }
            return false;
        }
        
        // Find all paths between two nodes
        function findPathsBetween(start, end, wires, throughComponents) {
            const paths = [];
            const visited = new Set();
            
            function dfs(current, path) {
                if (current === end) {
                    paths.push([...path]);
                    return;
                }
                
                visited.add(current);
                
                const connectedWires = wires.filter(w => 
                    w.startObj === current || w.endObj === current
                );
                
                for (const wire of connectedWires) {
                    const next = wire.startObj === current ? wire.endObj : wire.startObj;
                    if (!visited.has(next)) {
                        path.push(next);
                        dfs(next, path);
                        path.pop();
                    }
                }
                
                visited.delete(current);
            }
            
            dfs(start, [start]);
            return paths;
        }
        
        // Check if there's a complete circuit path from battery positive to negative
        // C3D-001: Open Circuit = Zero Current - A closed loop is required for current to flow
        // This function uses terminal-level checking: each connection point (component+side)
        // is a separate node in the graph to ensure BOTH terminals must be connected
        function hasClosedCircuitPath(battery, wires, allComponents) {
            if (!battery || wires.length === 0) return false;

            // Build adjacency graph using TERMINAL-LEVEL nodes (component+side combinations)
            // This ensures we check that BOTH terminals of components are connected,
            // not just that the component object itself appears in some wire
            const graph = new Map();

            // Helper to create unique terminal key
            const terminalKey = (obj, side) => {
                const objId = obj?.id || (obj === battery ? 'battery_main' : String(obj));
                return `${objId}:${side || 'any'}`;
            };

            // Helper to add bidirectional edge in the graph
            const addEdge = (key1, key2) => {
                if (!graph.has(key1)) graph.set(key1, []);
                if (!graph.has(key2)) graph.set(key2, []);
                graph.get(key1).push(key2);
                graph.get(key2).push(key1);
            };

            // Build connections from wires - each wire connects two specific terminals
            wires.forEach(wire => {
                const startKey = terminalKey(wire.startObj, wire.startSide);
                const endKey = terminalKey(wire.endObj, wire.endSide);
                addEdge(startKey, endKey);
            });

            // For two-terminal components, their internal connection allows current flow from one terminal to the other.
            // Components may be wired using different terminal naming conventions:
            // - 'positive'/'negative' (polarity-based)
            // - 'left'/'right' (position-based)
            // We create internal paths for ALL terminal pairs to handle both conventions.
            const conductingTypes = ['resistor', 'led', 'switch', 'lamp', 'inductor', 'capacitor', 'capacitor-ceramic', 'fuse', 'thermistor', 'diode', 'zener-diode', 'photodiode', 'motor', 'speaker'];
            allComponents.forEach(comp => {
                if (conductingTypes.includes(comp.type)) {
                    // Only conduct if switch is ON
                    if (comp.type === 'switch' && !comp.properties?.isOn) return;

                    // Get all terminal keys that exist in the graph for this component
                    const compId = comp?.id || String(comp);
                    const terminalSides = ['positive', 'negative', 'left', 'right'];
                    const existingTerminals = [];

                    terminalSides.forEach(side => {
                        const key = `${compId}:${side}`;
                        if (graph.has(key)) {
                            existingTerminals.push(key);
                        }
                    });

                    // Connect all terminals of this component internally
                    // This handles cases where wires use 'left'/'right' naming
                    for (let i = 0; i < existingTerminals.length; i++) {
                        for (let j = i + 1; j < existingTerminals.length; j++) {
                            addEdge(existingTerminals[i], existingTerminals[j]);
                        }
                    }

                    // Also add explicit positive/negative internal path if they exist
                    const posKey = terminalKey(comp, 'positive');
                    const negKey = terminalKey(comp, 'negative');
                    if (graph.has(posKey) && graph.has(negKey)) {
                        addEdge(posKey, negKey);
                    }

                    // And left/right internal path if they exist
                    const leftKey = terminalKey(comp, 'left');
                    const rightKey = terminalKey(comp, 'right');
                    if (graph.has(leftKey) && graph.has(rightKey)) {
                        addEdge(leftKey, rightKey);
                    }
                }
            });

            // Junctions connect all wires attached to them
            junctions.forEach(junction => {
                const junctionKey = terminalKey(junction, 'junction');
                // Junction terminals are already connected via wires in the graph
            });

            // Check if there's a path from battery negative to battery positive
            // This represents current flowing out of negative, through the circuit, back to positive
            const batteryNegKey = terminalKey(battery, 'negative');
            const batteryPosKey = terminalKey(battery, 'positive');

            // Both terminals must exist in the graph (be connected to something)
            if (!graph.has(batteryNegKey) || !graph.has(batteryPosKey)) {
                return false;
            }

            // BFS to find path from negative terminal to positive terminal
            const visited = new Set();
            const queue = [batteryNegKey];
            visited.add(batteryNegKey);

            while (queue.length > 0) {
                const current = queue.shift();

                if (current === batteryPosKey) {
                    return true; // Found closed loop from negative to positive
                }

                const neighbors = graph.get(current) || [];
                for (const neighbor of neighbors) {
                    if (!visited.has(neighbor)) {
                        visited.add(neighbor);
                        queue.push(neighbor);
                    }
                }
            }

            return false;
        }

        // Helper function to check if we can reach the battery (legacy - kept for compatibility)
        function canReachBattery(current, target, graph, visited) {
            if (current === target) return true;
            if (visited.has(current)) return false;

            visited.add(current);
            const neighbors = graph.get(current) || [];
            
            for (const neighbor of neighbors) {
                if (canReachBattery(neighbor, target, graph, visited)) {
                    return true;
                }
            }
            
            return false;
        }
        
        // Calculate resistance for combination circuits
        function calculateCombinationResistance(topology) {
            // Simplified calculation - just use series sum for now
            // A full implementation would require complex graph analysis
            return 100;
        }
        
        // Update topology display in UI
        function updateTopologyDisplay(type) {
            const topologyEl = document.getElementById('topology-type');
            if (topologyEl) {
                let displayText = type;
                let color = '#88ccff';
                
                switch(type) {
                    case 'series':
                        displayText = '? Series';
                        color = '#ffaa44';
                        break;
                    case 'parallel':
                        displayText = '?? Parallel';
                        color = '#44ff88';
                        break;
                    case 'combination':
                        displayText = '??? Combination';
                        color = '#ff88ff';
                        break;
                    case 'simple':
                        displayText = '? Simple';
                        color = '#88ccff';
                        break;
                    case 'Polarity':
                        displayText = '? Polarity';
                        color = WIRE_COLORS.I;
                        break;
                    case 'blocked':
                        displayText = '? Blocked';
                        color = '#ff8844';
                        break;
                    case 'Open Circuit':
                        displayText = '? Open';
                        color = '#ff4444';
                        break;
                    case 'Incomplete':
                        displayText = '?? Incomplete';
                        color = '#ffaa44';
                        break;
                    case 'No Circuit':
                        displayText = '? None';
                        color = '#888888';
                        break;
                    default:
                        displayText = '? Unknown';
                        color = '#888888';
                }
                
                topologyEl.textContent = displayText;
                topologyEl.style.color = color;
            }
        }

        function updateCircuitDisplay(voltage, current, resistance, power) {
            // Store values for educational modes
            lastKnownValues = { voltage, current, resistance, power };
            const resistanceDigits = activeWireProfile ? 3 : 1;
            const currentDigits = activeWireProfile ? 4 : 3;
            const powerDigits = activeWireProfile ? 3 : 2;
            
            // Update W.I.R.E. analysis display
            const voltageEl = document.getElementById('voltage');
            const currentEl = document.getElementById('current');
            const resistanceEl = document.getElementById('resistance');
            const powerEl = document.getElementById('power');
            
            if (voltageEl) voltageEl.textContent = voltage.toFixed(1) + 'V';
            if (currentEl) currentEl.textContent = current.toFixed(currentDigits) + 'A';
            if (resistanceEl) resistanceEl.textContent = 
                resistance === Infinity ? '' : resistance.toFixed(resistanceDigits) + '';
            if (powerEl) powerEl.textContent = power.toFixed(powerDigits) + 'W';
            
            const countEl = document.getElementById('count');
            const wireCountEl = document.getElementById('wire-count');
            const junctionCountEl = document.getElementById('junction-count');
            
            if (countEl) countEl.textContent = components.length;
            if (wireCountEl) wireCountEl.textContent = wires.length;
            if (junctionCountEl) junctionCountEl.textContent = junctions.length;
            
            // Update worksheet mode if active
            if (currentAnalysisTab === 'worksheet') {
                updateCalculationFormulas();
            }
            
            // Update practice status if in practice mode
            if (currentAnalysisTab === 'practice' && currentPracticeCircuit) {
                updatePracticeStatus();
            }

            refreshWireWorksheetSolutions();
            
            if (current > 0 && resistance !== Infinity) {
                setStatus(` W.I.R.E. COMPLETE! W=${power.toFixed(powerDigits)}W, I=${current.toFixed(currentDigits)}A, R=${resistance.toFixed(resistanceDigits)}, E=${voltage.toFixed(1)}V`);
            } else if (resistance === Infinity) {
                const switches = components.filter(c => c.type === 'switch');
                const openSwitch = switches.find(sw => !sw.properties.isOn);
                
                if (openSwitch) {
                    setStatus(`  OPEN CIRCUIT: Switch is OFF - touch it to complete W.I.R.E. analysis!`);
                } else {
                    setStatus(`  INCOMPLETE CIRCUIT: Connect components to enable W.I.R.E. calculations`);
                }
            } else {
                setStatus(' W.I.R.E. Circuit Builder - Learn with visual methodology!');
            }
        }

        // Pre-built color constants for the current-flow speed spectrum (parsed once, cloned per call).
        const FLOW_SPECTRUM_COLORS = {
            dullRed:   new THREE.Color('#8b0000'),
            orange:    new THREE.Color('#ff6600'),
            yellow:    new THREE.Color('#ffff00'),
            cyan:      new THREE.Color('#00ddff'),
            blueWhite: new THREE.Color('#aaddff'),
            white:     new THREE.Color('#ffffff')
        };

        function animateCurrentFlow(flowState) {
            currentFlowParticles.forEach(particle => {
                if (particle && scene) {
                    scene.remove(particle);
                }
            });
            currentFlowParticles = [];

            currentFlowState = flowState || null;

            const hasFlow = Boolean(flowState?.hasFlow);
            const currentValue = flowState?.currentValue ?? 0;

            if (!hasFlow || currentValue <= 0) {
                return;
            }

            const segments = (flowState.wireSegments && flowState.wireSegments.length > 0)
                ? flowState.wireSegments
                : wires.map(wire => ({ wire, direction: 1, speedFactor: 1 }));

            if (!segments.length) {
                return;
            }

            const baseSpeed = calculateFlowSpeed(currentValue);
            const baseParticleCount = isMobile ? 3 : 4;
            const maxParticles = isMobile ? 8 : 12;

            segments.forEach((segment, segmentIndex) => {
                const wire = segment.wire;
                if (!wire || !wire.wireGroup) {
                    return;
                }

                // Always recreate the curve to ensure it uses current terminal positions.
                // This is necessary because terminal positions may have changed since the wire was created.
                try {
                    wire.createCurve();
                } catch (e) {
                    console.warn('Could not create wire curve:', e);
                }
                if (!wire.curve) {
                    return;
                }

                const segmentSpeed = Math.max(0.002, baseSpeed * (segment.speedFactor || 1));
                // Compute per-segment color so particles near resistors appear dull red and
                // particles on free wires appear blue-white, following the speed spectrum.
                const flowColor = calculateCurrentColor(flowState, segment.speedFactor);
                const directionMultiplier = ((segment.direction >= 0 ? 1 : -1) * (currentFlowStyle === 'misty' ? -1 : 1));

                let dynamicCount = Math.floor((currentValue * (isMobile ? 14 : 18)) * (segment.speedFactor || 1));
                dynamicCount = Math.max(baseParticleCount, Math.min(maxParticles, dynamicCount));

                const particleCount = dynamicCount;
                const intensity = Math.min(1, currentValue / 0.5);

                for (let i = 0; i < particleCount; i++) {
                    try {
                        const particleSize = 0.08 + (intensity * 0.06);
                        const particleGeometry = new THREE.SphereGeometry(particleSize, isMobile ? 8 : 10, isMobile ? 6 : 8);

                        const baseMaterialProps = {
                            color: flowColor.hex,
                            emissive: flowColor.emissive,
                            shininess: 160,
                            transparent: true
                        };

                        if (currentFlowStyle === 'misty') {
                            baseMaterialProps.opacity = 0.35 + (intensity * 0.25);
                            baseMaterialProps.emissiveIntensity = 0.7;
                        } else {
                            baseMaterialProps.opacity = 0.85 + (intensity * 0.1);
                            baseMaterialProps.emissiveIntensity = 1.05;
                        }

                        const particleMaterial = new THREE.MeshPhongMaterial(baseMaterialProps);
                        const particle = new THREE.Mesh(particleGeometry, particleMaterial);

                        const initialProgress = (i / particleCount) + (segmentIndex * 0.17);
                        const clampedProgress = ((initialProgress % 1) + 1) % 1;

                        const initialPosition = wire.curve.getPoint(clampedProgress);
                        particle.position.copy(initialPosition);

                        particle.userData = {
                            wire,
                            progress: clampedProgress,
                            speed: segmentSpeed,
                            direction: directionMultiplier,
                            flowColor,
                            isFlowing: true,
                            flowStyle: currentFlowStyle
                        };

                        scene.add(particle);
                        currentFlowParticles.push(particle);
                    } catch (error) {
                        console.error(`Error creating particle ${i}:`, error);
                    }
                }
            });
        }

        function calculateCurrentColor(flowState, speedFactor) {
            if (flowState?.warning === 'short') {
                return { hex: 0xff4444, emissive: 0x330000 };
            }

            // Map the segment's speedFactor ([minSpeedFactor..maxSpeedFactor]) to [0..1].
            // speedFactor is low near high-resistance components and high on free wires.
            const sf = speedFactor ?? FLOW_CONSTANTS.maxSpeedFactor;
            const minSF = FLOW_CONSTANTS.minSpeedFactor;
            const maxSF = FLOW_CONSTANTS.maxSpeedFactor;
            const t = Math.min(1, Math.max(0, (sf - minSF) / (maxSF - minSF)));

            // Color spectrum: dull red (slow, t=0) -> orange -> yellow -> cyan -> blue-white (fast, t=1)
            let displayColor;
            if (t < 0.25) {
                displayColor = FLOW_SPECTRUM_COLORS.dullRed.clone().lerp(FLOW_SPECTRUM_COLORS.orange, t / 0.25);
            } else if (t < 0.5) {
                displayColor = FLOW_SPECTRUM_COLORS.orange.clone().lerp(FLOW_SPECTRUM_COLORS.yellow, (t - 0.25) / 0.25);
            } else if (t < 0.75) {
                displayColor = FLOW_SPECTRUM_COLORS.yellow.clone().lerp(FLOW_SPECTRUM_COLORS.cyan, (t - 0.5) / 0.25);
            } else {
                displayColor = FLOW_SPECTRUM_COLORS.cyan.clone().lerp(FLOW_SPECTRUM_COLORS.blueWhite, (t - 0.75) / 0.25);
            }

            if (currentFlowStyle === 'misty') {
                displayColor.lerp(FLOW_SPECTRUM_COLORS.white, 0.15);
            }

            const emissiveColor = displayColor.clone().multiplyScalar(0.4);
            return {
                hex: displayColor.getHex(),
                emissive: emissiveColor.getHex()
            };
        }

        function calculateFlowSpeed(current) {
            const baseSpeed = isMobile ? 0.008 : 0.01;
            const speedMultiplier = 1 + (current * 8);
            return Math.min(baseSpeed * speedMultiplier, isMobile ? 0.06 : 0.08);
        }

        function updateCircuitInfo() {
            updateCircuitDisplay(0, 0, Infinity, 0);
            analyzeCircuit();
        }

        // Educational Analysis Functions
        function switchAnalysisTab(tabName) {
            // Update tab buttons
            document.querySelectorAll('.analysis-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            document.getElementById(`tab-${tabName}`).classList.add('active');
            
            // Show/hide content panels
            document.querySelectorAll('.analysis-content').forEach(content => {
                content.style.display = 'none';
            });
            document.getElementById(`content-${tabName}`).style.display = 'block';
            
            currentAnalysisTab = tabName;
            
            // Update content based on tab
            switch(tabName) {
                case 'worksheet':
                    updateWorksheetDisplay();
                    break;
                case 'eir':
                    updateCircuitSchematic();
                    break;
                case 'power':
                    // Power triangle is static, no need to update
                    break;
                case 'problem':
                    updateProblemMode();
                    break;
                case 'practice':
                    updatePracticeStatus();
                    break;
                case 'meter':
                    updateMeterUI();
                    break;
            }
            
            setStatus(`  Switched to ${tabName.toUpperCase()} analysis mode`);
        }

        function explainOhmsLaw(variable) {
            const formulaEl = document.getElementById('eir-formula');
            
            switch(variable) {
                case 'E':
                    formulaEl.textContent = 'E = I ? R (EMF/Voltage = Current ? Resistance)';
                    formulaEl.style.color = '#ff4444';
                    setStatus(' EMF/VOLTAGE: E = I  R | Measured in Volts (V)');
                    break;
                case 'I':
                    formulaEl.textContent = 'I = E ? R (Current = EMF/Voltage ? Resistance)';
                    formulaEl.style.color = '#ff8844';
                    setStatus(' CURRENT: I = E  R | Measured in Amperes (A)');
                    break;
                case 'R':
                    formulaEl.textContent = 'R = E ? I (Resistance = EMF/Voltage ? Current)';
                    formulaEl.style.color = '#44ff88';
                    setStatus(' RESISTANCE: R = E  I | Measured in Ohms ()');
                    break;
            }
            
            // Add visual feedback
            const triangleEl = document.querySelector(`.triangle-${variable.toLowerCase()}`);
            if (triangleEl) {
                triangleEl.style.textShadow = '0 0 20px currentColor';
                setTimeout(() => {
                    triangleEl.style.textShadow = '0 0 10px currentColor';
                }, 1000);
            }
        }

        function explainPowerLaw(variable) {
            const formulaEl = document.getElementById('power-formula');
            
            switch(variable) {
                case 'W':
                    formulaEl.textContent = 'W = I ? E (Power = Current ? EMF/Voltage)';
                    formulaEl.style.color = '#4488ff';
                    setStatus(' POWER: W = I  E | Also W = IR or W = ER | Measured in Watts (W)');
                    break;
                case 'I':
                    formulaEl.textContent = 'I = W ? E (Current = Power ? EMF/Voltage)';
                    formulaEl.style.color = '#ff8844';
                    setStatus(' CURRENT: I = W  E | From power triangle | Measured in Amperes (A)');
                    break;
                case 'E':
                    formulaEl.textContent = 'E = W ? I (EMF/Voltage = Power ? Current)';
                    formulaEl.style.color = '#ff4444';
                    setStatus(' EMF/VOLTAGE: E = W  I | From power triangle | Measured in Volts (V)');
                    break;
            }
            
            // Add visual feedback
            let triangleSelector;
            if (variable === 'W') triangleSelector = '.triangle-v'; // W is in top position
            else if (variable === 'I') triangleSelector = '.triangle-i'; // I is in bottom left
            else if (variable === 'E') triangleSelector = '.triangle-r'; // E is in bottom right position
            
            const triangleEl = document.querySelector(`#content-power ${triangleSelector}`);
            if (triangleEl) {
                triangleEl.style.textShadow = '0 0 20px currentColor';
                setTimeout(() => {
                    triangleEl.style.textShadow = '0 0 10px currentColor';
                }, 1000);
            }
        }

        function updateWorksheetDisplay() {
            const componentList = document.getElementById('component-list');
            if (!componentList) return;
            
            // Clear existing list
            componentList.innerHTML = '';
            
            // Add batteries
            components.filter(c => c.type === 'battery').forEach(battery => {
                const item = document.createElement('div');
                item.className = 'component-item';
                item.style.borderColor = '#ff4444';
                item.innerHTML = `
                    <div class="component-label">Battery ${battery.componentNumber}</div>
                    <div class="component-value" style="color: #ff4444;">${battery.properties.voltage}V</div>
                `;
                componentList.appendChild(item);
            });
            
            // Add resistors
            components.filter(c => c.type === 'resistor').forEach(resistor => {
                const item = document.createElement('div');
                item.className = 'component-item';
                item.style.borderColor = '#44ff88';
                item.innerHTML = `
                    <div class="component-label">R${resistor.componentNumber}</div>
                    <div class="component-value" style="color: #44ff88;">${resistor.properties.resistance}?</div>
                `;
                componentList.appendChild(item);
            });
            
            // Add LEDs
            components.filter(c => c.type === 'led').forEach(led => {
                const item = document.createElement('div');
                item.className = 'component-item';
                item.style.borderColor = '#44ff88';
                item.innerHTML = `
                    <div class="component-label">LED${led.componentNumber}</div>
                    <div class="component-value" style="color: #44ff88;">${led.properties.resistance}?</div>
                `;
                componentList.appendChild(item);
            });
            
            // Add switches
            components.filter(c => c.type === 'switch').forEach(sw => {
                const item = document.createElement('div');
                item.className = 'component-item';
                item.style.borderColor = sw.properties.isOn ? '#44ff88' : '#ff4444';
                item.innerHTML = `
                    <div class="component-label">SW${sw.componentNumber}</div>
                    <div class="component-value" style="color: ${sw.properties.isOn ? '#44ff88' : '#ff4444'};">
                        ${sw.properties.isOn ? sw.properties.resistance + '?' : 'OPEN'}
                    </div>
                `;
                componentList.appendChild(item);
            });
            
            // Update calculation formulas
            updateCalculationFormulas();
        }

        function updateCalculationFormulas() {
            const resistors = components.filter(c => c.type === 'resistor' || c.type === 'led');
            const batteries = components.filter(c => c.type === 'battery');
            const switches = components.filter(c => c.type === 'switch' && c.properties.isOn);
            
            // Update resistance formula
            const resistanceFormula = document.getElementById('resistance-formula');
            if (resistanceFormula) {
                let formula = 'R_total = ';
                const allResistors = [...resistors, ...switches];
                if (allResistors.length > 0) {
                    formula += allResistors.map(r => {
                        if (r.type === 'resistor') return `R${r.componentNumber}`;
                        if (r.type === 'led') return `LED${r.componentNumber}`;
                        if (r.type === 'switch') return `SW${r.componentNumber}`;
                        return 'X';
                    }).join(' + ');
                } else {
                    formula += '? (no resistors)';
                }
                resistanceFormula.textContent = formula;
            }
            
            // Update voltage formula
            const voltageFormula = document.getElementById('voltage-formula');
            if (voltageFormula) {
                let formula = 'V_total = ';
                if (batteries.length > 0) {
                    formula += batteries.map(b => `B${b.componentNumber}`).join(' + ');
                } else {
                    formula += '0 (no batteries)';
                }
                voltageFormula.textContent = formula;
            }

            // Update calculated values in worksheet
            const calcElements = {
                'calc-resistance': lastKnownValues.resistance === Infinity ? '' : lastKnownValues.resistance.toFixed(1) + '',
                'calc-current': lastKnownValues.current.toFixed(3) + 'A',
                'calc-voltage': lastKnownValues.voltage.toFixed(1) + 'V',
                'calc-power': lastKnownValues.power.toFixed(2) + 'W'
            };

            Object.entries(calcElements).forEach(([id, value]) => {
                const el = document.getElementById(id);
                if (el) el.textContent = value;
            });
        }

        function updateCircuitSchematic() {
            const schematicEl = document.getElementById('circuit-schematic');
            if (!schematicEl) return;
            
            const batteries = components.filter(c => c.type === 'battery');
            const resistors = components.filter(c => c.type === 'resistor' || c.type === 'led');
            
            if (batteries.length === 0 && resistors.length === 0) {
                schematicEl.innerHTML = `
                    <div class="schematic-line">No components added yet</div>
                    <div class="schematic-line">Add battery and resistors</div>
                    <div class="schematic-line">to see circuit diagram</div>
                `;
                return;
            }
            
            // Generate ASCII circuit based on components
            let schematic = '';
            if (batteries.length > 0 && resistors.length > 0) {
                schematic = `
                    <div class="schematic-line">     +?????[R?]?????+</div>
                    <div class="schematic-line">     ?              ?</div>
                    <div class="schematic-line">   [BAT]          [R?]</div>
                    <div class="schematic-line">     ?              ?</div>
                    <div class="schematic-line">     +??????????????+</div>
                `;
            } else if (batteries.length > 0) {
                schematic = `
                    <div class="schematic-line">     +??????????????+</div>
                    <div class="schematic-line">     ?              ?</div>
                    <div class="schematic-line">   [BAT]         (no load)</div>
                    <div class="schematic-line">     ?              ?</div>
                    <div class="schematic-line">     +??????????????+</div>
                `;
            }
            
            schematicEl.innerHTML = schematic;
        }

        function updateProblemMode() {
            // Clear any previous answers
            document.getElementById('student-voltage').value = '';
            document.getElementById('student-current').value = '';
            document.getElementById('student-resistance').value = '';
            document.getElementById('student-power').value = '';
            
            const feedbackEl = document.getElementById('answer-feedback');
            if (feedbackEl) {
                feedbackEl.innerHTML = '';
            }
        }

        function checkStudentAnswers() {
            const studentVoltage = parseFloat(document.getElementById('student-voltage').value);
            const studentCurrent = parseFloat(document.getElementById('student-current').value);
            const studentResistance = parseFloat(document.getElementById('student-resistance').value);
            const studentPower = parseFloat(document.getElementById('student-power').value);
            
            const tolerance = 0.05; // 5% tolerance for answers
            const feedbackEl = document.getElementById('answer-feedback');
            
            let results = [];
            let allCorrect = true;
            
            // Check voltage
            if (!isNaN(studentVoltage)) {
                const voltageCorrect = Math.abs(studentVoltage - lastKnownValues.voltage) / lastKnownValues.voltage < tolerance;
                results.push({
                    label: 'Voltage',
                    student: studentVoltage.toFixed(1) + 'V',
                    correct: lastKnownValues.voltage.toFixed(1) + 'V',
                    isCorrect: voltageCorrect,
                    color: '#ff4444'
                });
                if (!voltageCorrect) allCorrect = false;
            }
            
            // Check current
            if (!isNaN(studentCurrent)) {
                const currentCorrect = Math.abs(studentCurrent - lastKnownValues.current) / Math.max(lastKnownValues.current, 0.001) < tolerance;
                results.push({
                    label: 'Current',
                    student: studentCurrent.toFixed(3) + 'A',
                    correct: lastKnownValues.current.toFixed(3) + 'A',
                    isCorrect: currentCorrect,
                    color: '#ff8844'
                });
                if (!currentCorrect) allCorrect = false;
            }
            
            // Check resistance
            if (!isNaN(studentResistance)) {
                const resistanceCorrect = lastKnownValues.resistance === Infinity ? 
                    studentResistance > 10000 : 
                    Math.abs(studentResistance - lastKnownValues.resistance) / lastKnownValues.resistance < tolerance;
                results.push({
                    label: 'Resistance',
                    student: studentResistance.toFixed(1) + '',
                    correct: lastKnownValues.resistance === Infinity ? '' : lastKnownValues.resistance.toFixed(1) + '',
                    isCorrect: resistanceCorrect,
                    color: '#44ff88'
                });
                if (!resistanceCorrect) allCorrect = false;
            }
            
            // Check power
            if (!isNaN(studentPower)) {
                const powerCorrect = Math.abs(studentPower - lastKnownValues.power) / Math.max(lastKnownValues.power, 0.001) < tolerance;
                results.push({
                    label: 'Power',
                    student: studentPower.toFixed(2) + 'W',
                    correct: lastKnownValues.power.toFixed(2) + 'W',
                    isCorrect: powerCorrect,
                    color: '#4488ff'
                });
                if (!powerCorrect) allCorrect = false;
            }
            
            // Display results
            let feedback = `<div class="result-feedback ${allCorrect ? 'feedback-correct' : 'feedback-incorrect'}">`;
            
            if (allCorrect && results.length > 0) {
                feedback += '?? Excellent! All answers are correct!';
            } else if (results.length === 0) {
                feedback += '? Please enter at least one answer to check.';
            } else {
                feedback += '?? Results:<br>';
                results.forEach(result => {
                    const icon = result.isCorrect ? '?' : '?';
                    feedback += `${icon} ${result.label}: ${result.student} ${result.isCorrect ? '(Correct!)' : '(Expected: ' + result.correct + ')'}<br>`;
                });
            }
            
            feedback += '</div>';
            feedbackEl.innerHTML = feedback;
        }

        // Preset Circuit Library
        const PRESET_CIRCUITS = {
            series_basic: {
                name: "Series Square Loop",
                description: "24 V source feeding three series resistors arranged as a square.",
                objectives: [
                    "Map a textbook square schematic into 3D space with battery, top, side, and bottom legs.",
                    "Log known values with W.I.R.E. (R1=150 , R2=200 , R3=250 , E=24 V) and identify I_T.",
                    "Select the correct Ohm's Law identity I = E / R_T, then compute voltage drops and power.",
                    "Confirm the solution using Kirchhoff's Voltage Law and the power identity W = I * E."
                ],
                components: [
                    { id: 'B1', type: 'battery', position: [-10, 0, 0], rotation: 1.5707963267948966, properties: { voltage: 24 } },
                    { id: 'R1', type: 'resistor', position: [0, 0, 6], properties: { resistance: 150 } },
                    { id: 'R2', type: 'resistor', position: [10, 0, 0], rotation: 1.5707963267948966, properties: { resistance: 200 } },
                    { id: 'R3', type: 'resistor', position: [0, 0, -6], properties: { resistance: 250 } }
                ],
                junctions: [
                    { id: 'J_TL', position: [-10, 0, 6] },
                    { id: 'J_TR', position: [10, 0, 6] },
                    { id: 'J_BR', position: [10, 0, -6] },
                    { id: 'J_BL', position: [-10, 0, -6] }
                ],
                wires: [
                    { from: { ref: 'B1', side: 'positive' }, to: { ref: 'J_TL', side: 'center' } },
                    { from: { ref: 'J_TL', side: 'center' }, to: { ref: 'R1', side: 'left' } },
                    { from: { ref: 'R1', side: 'right' }, to: { ref: 'J_TR', side: 'center' } },
                    { from: { ref: 'J_TR', side: 'center' }, to: { ref: 'R2', side: 'right' } },
                    { from: { ref: 'R2', side: 'left' }, to: { ref: 'J_BR', side: 'center' } },
                    { from: { ref: 'J_BR', side: 'center' }, to: { ref: 'R3', side: 'right' } },
                    { from: { ref: 'R3', side: 'left' }, to: { ref: 'J_BL', side: 'center' } },
                    { from: { ref: 'J_BL', side: 'center' }, to: { ref: 'B1', side: 'negative' } }
                ]
            },
            parallel_basic: {
                name: "Parallel Branch Rectangle",
                description: "12 V source feeding three vertical branches between shared top and bottom rails.",
                objectives: [
                    "Visualize a textbook branch network: one source and multiple resistor paths between the same two nodes.",
                    "Capture W.I.R.E. data (shared branch voltage, individual branch currents, and total current).",
                    "Compute R_T with 1 / (1/R1 + 1/R2 + 1/R3) and find each branch current with I = E / R_branch.",
                    "Check Kirchhoff's Current Law by summing branch currents and compare branch power with W = I * E."
                ],
                components: [
                    { id: 'B1', type: 'battery', position: [-10, 0, 0], rotation: 1.5707963267948966, properties: { voltage: 12 } },
                    { id: 'R1', type: 'resistor', position: [-4, 0, 0], rotation: 1.5707963267948966, properties: { resistance: 100 } },
                    { id: 'R2', type: 'resistor', position: [0, 0, 0], rotation: 1.5707963267948966, properties: { resistance: 220 } },
                    { id: 'R3', type: 'resistor', position: [4, 0, 0], rotation: 1.5707963267948966, properties: { resistance: 330 } }
                ],
                junctions: [
                    { id: 'J_LEFT_TOP', position: [-10, 0, 6] },
                    { id: 'J_BRANCH_1_TOP', position: [-4, 0, 6] },
                    { id: 'J_BRANCH_2_TOP', position: [0, 0, 6] },
                    { id: 'J_BRANCH_3_TOP', position: [4, 0, 6] },
                    { id: 'J_RIGHT_TOP', position: [10, 0, 6] },
                    { id: 'J_LEFT_BOTTOM', position: [-10, 0, -6] },
                    { id: 'J_BRANCH_1_BOTTOM', position: [-4, 0, -6] },
                    { id: 'J_BRANCH_2_BOTTOM', position: [0, 0, -6] },
                    { id: 'J_BRANCH_3_BOTTOM', position: [4, 0, -6] },
                    { id: 'J_RIGHT_BOTTOM', position: [10, 0, -6] }
                ],
                wires: [
                    { from: { ref: 'B1', side: 'positive' }, to: { ref: 'J_LEFT_TOP', side: 'center' } },
                    { from: { ref: 'B1', side: 'negative' }, to: { ref: 'J_LEFT_BOTTOM', side: 'center' } },
                    { from: { ref: 'J_LEFT_TOP', side: 'center' }, to: { ref: 'J_BRANCH_1_TOP', side: 'center' } },
                    { from: { ref: 'J_BRANCH_1_TOP', side: 'center' }, to: { ref: 'J_BRANCH_2_TOP', side: 'center' } },
                    { from: { ref: 'J_BRANCH_2_TOP', side: 'center' }, to: { ref: 'J_BRANCH_3_TOP', side: 'center' } },
                    { from: { ref: 'J_BRANCH_3_TOP', side: 'center' }, to: { ref: 'J_RIGHT_TOP', side: 'center' } },
                    { from: { ref: 'J_LEFT_BOTTOM', side: 'center' }, to: { ref: 'J_BRANCH_1_BOTTOM', side: 'center' } },
                    { from: { ref: 'J_BRANCH_1_BOTTOM', side: 'center' }, to: { ref: 'J_BRANCH_2_BOTTOM', side: 'center' } },
                    { from: { ref: 'J_BRANCH_2_BOTTOM', side: 'center' }, to: { ref: 'J_BRANCH_3_BOTTOM', side: 'center' } },
                    { from: { ref: 'J_BRANCH_3_BOTTOM', side: 'center' }, to: { ref: 'J_RIGHT_BOTTOM', side: 'center' } },
                    { from: { ref: 'J_BRANCH_1_TOP', side: 'center' }, to: { ref: 'R1', side: 'right' } },
                    { from: { ref: 'R1', side: 'left' }, to: { ref: 'J_BRANCH_1_BOTTOM', side: 'center' } },
                    { from: { ref: 'J_BRANCH_2_TOP', side: 'center' }, to: { ref: 'R2', side: 'right' } },
                    { from: { ref: 'R2', side: 'left' }, to: { ref: 'J_BRANCH_2_BOTTOM', side: 'center' } },
                    { from: { ref: 'J_BRANCH_3_TOP', side: 'center' }, to: { ref: 'R3', side: 'right' } },
                    { from: { ref: 'R3', side: 'left' }, to: { ref: 'J_BRANCH_3_BOTTOM', side: 'center' } }
                ]
            },
            mixed_circuit: {
                name: "Series-Parallel Ladder",
                description: "Textbook ladder: top series resistor, middle parallel branch box, bottom series return resistor.",
                objectives: [
                    "Practice reducing a true ladder network: R1 + (R2 || R3) + R4.",
                    "Track W.I.R.E. values (R1=150 ohm, R2=220 ohm, R3=330 ohm, R4=180 ohm, E=18 V).",
                    "Reduce the network step by step, using I = E / R_T and W = I^2 * R for branch power.",
                    "Verify both Kirchhoff's Voltage Law and Current Law at key nodes."
                ],
                components: [
                    { id: 'B1', type: 'battery', position: [-12, 0, 0], rotation: 1.5707963267948966, properties: { voltage: 18 } },
                    { id: 'R1', type: 'resistor', position: [-4, 0, 6], properties: { resistance: 150 } },
                    { id: 'R2', type: 'resistor', position: [4, 0, 0], rotation: 1.5707963267948966, properties: { resistance: 220 } },
                    { id: 'R3', type: 'resistor', position: [8, 0, 0], rotation: 1.5707963267948966, properties: { resistance: 330 } },
                    { id: 'R4', type: 'resistor', position: [0, 0, -6], properties: { resistance: 180 } }
                ],
                junctions: [
                    { id: 'J_SOURCE_TOP', position: [-12, 0, 6] },
                    { id: 'J_BRANCH_FEED', position: [0, 0, 6] },
                    { id: 'J_BRANCH_TOP_1', position: [2, 0, 6] },
                    { id: 'J_BRANCH_TOP_2', position: [6, 0, 6] },
                    { id: 'J_BRANCH_BOTTOM_1', position: [2, 0, -2] },
                    { id: 'J_BRANCH_BOTTOM_2', position: [6, 0, -2] },
                    { id: 'J_BRANCH_MERGE', position: [0, 0, -2] },
                    { id: 'J_RETURN', position: [0, 0, -6] },
                    { id: 'J_SOURCE_BOTTOM', position: [-12, 0, -6] }
                ],
                wires: [
                    { from: { ref: 'B1', side: 'positive' }, to: { ref: 'J_SOURCE_TOP', side: 'center' } },
                    { from: { ref: 'J_SOURCE_TOP', side: 'center' }, to: { ref: 'R1', side: 'left' } },
                    { from: { ref: 'R1', side: 'right' }, to: { ref: 'J_BRANCH_FEED', side: 'center' } },
                    { from: { ref: 'J_BRANCH_FEED', side: 'center' }, to: { ref: 'J_BRANCH_TOP_1', side: 'center' } },
                    { from: { ref: 'J_BRANCH_TOP_1', side: 'center' }, to: { ref: 'J_BRANCH_TOP_2', side: 'center' } },
                    { from: { ref: 'J_BRANCH_TOP_1', side: 'center' }, to: { ref: 'R2', side: 'right' } },
                    { from: { ref: 'R2', side: 'left' }, to: { ref: 'J_BRANCH_BOTTOM_1', side: 'center' } },
                    { from: { ref: 'J_BRANCH_TOP_2', side: 'center' }, to: { ref: 'R3', side: 'right' } },
                    { from: { ref: 'R3', side: 'left' }, to: { ref: 'J_BRANCH_BOTTOM_2', side: 'center' } },
                    { from: { ref: 'J_BRANCH_BOTTOM_1', side: 'center' }, to: { ref: 'J_BRANCH_BOTTOM_2', side: 'center' } },
                    { from: { ref: 'J_BRANCH_BOTTOM_1', side: 'center' }, to: { ref: 'J_BRANCH_MERGE', side: 'center' } },
                    { from: { ref: 'J_BRANCH_BOTTOM_2', side: 'center' }, to: { ref: 'J_BRANCH_MERGE', side: 'center' } },
                    { from: { ref: 'J_BRANCH_MERGE', side: 'center' }, to: { ref: 'J_RETURN', side: 'center' } },
                    { from: { ref: 'J_RETURN', side: 'center' }, to: { ref: 'R4', side: 'right' } },
                    { from: { ref: 'R4', side: 'left' }, to: { ref: 'J_SOURCE_BOTTOM', side: 'center' } },
                    { from: { ref: 'J_SOURCE_BOTTOM', side: 'center' }, to: { ref: 'B1', side: 'negative' } }
                ]
            },
            combination_advanced: {
                name: "Combo Challenge Network",
                description: "Textbook series-parallel chain with a dedicated branch box and LED return load.",
                objectives: [
                    "Interpret a multi-section network arranged as top series, middle parallel box, and bottom return chain.",
                    "Track W.I.R.E. entries for R1=120 ohm, R2=150 ohm, R3=180 ohm, R4=270 ohm, R5=220 ohm, LED=60 ohm, E=24 V.",
                    "Jump between Ohm's Law and power identities (I = E / R, W = I * E, W = I^2 * R, W = E^2 / R).",
                    "Validate results with Kirchhoff's Voltage Law on each loop and Current Law at every junction."
                ],
                components: [
                    { id: 'B1', type: 'battery', position: [-14, 0, 0], rotation: 1.5707963267948966, properties: { voltage: 24 } },
                    { id: 'R1', type: 'resistor', position: [-6, 0, 6], properties: { resistance: 120 } },
                    { id: 'R2', type: 'resistor', position: [2, 0, 6], properties: { resistance: 150 } },
                    { id: 'R3', type: 'resistor', position: [6, 0, 0], rotation: 1.5707963267948966, properties: { resistance: 180 } },
                    { id: 'R4', type: 'resistor', position: [10, 0, 0], rotation: 1.5707963267948966, properties: { resistance: 270 } },
                    { id: 'R5', type: 'resistor', position: [4, 0, -6], properties: { resistance: 220 } },
                    { id: 'LED1', type: 'led', position: [-2, 0, -6], properties: { resistance: 60 } }
                ],
                junctions: [
                    { id: 'J_TOP_LEFT', position: [-14, 0, 6] },
                    { id: 'J_AFTER_R1', position: [-5, 0, 6] },
                    { id: 'J_AFTER_R2', position: [1, 0, 6] },
                    { id: 'J_BRANCH_TOP_A', position: [6, 0, 6] },
                    { id: 'J_BRANCH_TOP_B', position: [10, 0, 6] },
                    { id: 'J_BRANCH_BOTTOM_A', position: [6, 0, -2] },
                    { id: 'J_BRANCH_BOTTOM_B', position: [10, 0, -2] },
                    { id: 'J_BRANCH_MERGE', position: [1, 0, -2] },
                    { id: 'J_DROP', position: [1, 0, -6] },
                    { id: 'J_AFTER_R5', position: [-7, 0, -6] },
                    { id: 'J_BOTTOM_LEFT', position: [-14, 0, -6] }
                ],
                wires: [
                    { from: { ref: 'B1', side: 'positive' }, to: { ref: 'J_TOP_LEFT', side: 'center' } },
                    { from: { ref: 'J_TOP_LEFT', side: 'center' }, to: { ref: 'R1', side: 'left' } },
                    { from: { ref: 'R1', side: 'right' }, to: { ref: 'J_AFTER_R1', side: 'center' } },
                    { from: { ref: 'J_AFTER_R1', side: 'center' }, to: { ref: 'R2', side: 'left' } },
                    { from: { ref: 'R2', side: 'right' }, to: { ref: 'J_AFTER_R2', side: 'center' } },
                    { from: { ref: 'J_AFTER_R2', side: 'center' }, to: { ref: 'J_BRANCH_TOP_A', side: 'center' } },
                    { from: { ref: 'J_BRANCH_TOP_A', side: 'center' }, to: { ref: 'J_BRANCH_TOP_B', side: 'center' } },
                    { from: { ref: 'J_BRANCH_TOP_A', side: 'center' }, to: { ref: 'R3', side: 'right' } },
                    { from: { ref: 'R3', side: 'left' }, to: { ref: 'J_BRANCH_BOTTOM_A', side: 'center' } },
                    { from: { ref: 'J_BRANCH_TOP_B', side: 'center' }, to: { ref: 'R4', side: 'right' } },
                    { from: { ref: 'R4', side: 'left' }, to: { ref: 'J_BRANCH_BOTTOM_B', side: 'center' } },
                    { from: { ref: 'J_BRANCH_BOTTOM_A', side: 'center' }, to: { ref: 'J_BRANCH_BOTTOM_B', side: 'center' } },
                    { from: { ref: 'J_BRANCH_BOTTOM_A', side: 'center' }, to: { ref: 'J_BRANCH_MERGE', side: 'center' } },
                    { from: { ref: 'J_BRANCH_BOTTOM_B', side: 'center' }, to: { ref: 'J_BRANCH_MERGE', side: 'center' } },
                    { from: { ref: 'J_BRANCH_MERGE', side: 'center' }, to: { ref: 'J_DROP', side: 'center' } },
                    { from: { ref: 'J_DROP', side: 'center' }, to: { ref: 'R5', side: 'right' } },
                    { from: { ref: 'R5', side: 'left' }, to: { ref: 'J_AFTER_R5', side: 'center' } },
                    { from: { ref: 'J_AFTER_R5', side: 'center' }, to: { ref: 'LED1', side: 'right' } },
                    { from: { ref: 'LED1', side: 'left' }, to: { ref: 'J_BOTTOM_LEFT', side: 'center' } },
                    { from: { ref: 'J_BOTTOM_LEFT', side: 'center' }, to: { ref: 'B1', side: 'negative' } }
                ]
            },
            troubleshoot_switch_off: {
                name: "Troubleshooting: Open Switch",
                description: "Standard four-side series loop with an open switch fault on the top leg.",
                objectives: [
                    "Identify why the circuit has no current flow.",
                    "Fix the fault and restore current flow."
                ],
                components: [
                    { id: 'B1', type: 'battery', position: [-10, 0, 0], rotation: 1.5707963267948966, properties: { voltage: 9 } },
                    { id: 'SW1', type: 'switch', position: [0, 0, 6], properties: { resistance: 0.1, isOn: false } },
                    { id: 'R1', type: 'resistor', position: [10, 0, 0], rotation: 1.5707963267948966, properties: { resistance: 220 } },
                    { id: 'R2', type: 'resistor', position: [0, 0, -6], properties: { resistance: 180 } }
                ],
                junctions: [
                    { id: 'J_TL', position: [-10, 0, 6] },
                    { id: 'J_TR', position: [10, 0, 6] },
                    { id: 'J_BR', position: [10, 0, -6] },
                    { id: 'J_BL', position: [-10, 0, -6] }
                ],
                wires: [
                    { from: { ref: 'B1', side: 'positive' }, to: { ref: 'J_TL', side: 'center' } },
                    { from: { ref: 'J_TL', side: 'center' }, to: { ref: 'SW1', side: 'left' } },
                    { from: { ref: 'SW1', side: 'right' }, to: { ref: 'J_TR', side: 'center' } },
                    { from: { ref: 'J_TR', side: 'center' }, to: { ref: 'R1', side: 'right' } },
                    { from: { ref: 'R1', side: 'left' }, to: { ref: 'J_BR', side: 'center' } },
                    { from: { ref: 'J_BR', side: 'center' }, to: { ref: 'R2', side: 'right' } },
                    { from: { ref: 'R2', side: 'left' }, to: { ref: 'J_BL', side: 'center' } },
                    { from: { ref: 'J_BL', side: 'center' }, to: { ref: 'B1', side: 'negative' } }
                ]
            },
            troubleshoot_missing_wire: {
                name: "Troubleshooting: Missing Return Wire",
                description: "Standard four-side series loop with one missing return connection.",
                objectives: [
                    "Find the missing connection that prevents current flow.",
                    "Add the missing wire and restore current flow."
                ],
                components: [
                    { id: 'B1', type: 'battery', position: [-10, 0, 0], rotation: 1.5707963267948966, properties: { voltage: 12 } },
                    { id: 'R1', type: 'resistor', position: [0, 0, 6], properties: { resistance: 150 } },
                    { id: 'R2', type: 'resistor', position: [10, 0, 0], rotation: 1.5707963267948966, properties: { resistance: 220 } },
                    { id: 'R3', type: 'resistor', position: [0, 0, -6], properties: { resistance: 330 } }
                ],
                junctions: [
                    { id: 'J_TL', position: [-10, 0, 6] },
                    { id: 'J_TR', position: [10, 0, 6] },
                    { id: 'J_BR', position: [10, 0, -6] },
                    { id: 'J_BL', position: [-10, 0, -6] }
                ],
                wires: [
                    { from: { ref: 'B1', side: 'positive' }, to: { ref: 'J_TL', side: 'center' } },
                    { from: { ref: 'J_TL', side: 'center' }, to: { ref: 'R1', side: 'left' } },
                    { from: { ref: 'R1', side: 'right' }, to: { ref: 'J_TR', side: 'center' } },
                    { from: { ref: 'J_TR', side: 'center' }, to: { ref: 'R2', side: 'right' } },
                    { from: { ref: 'R2', side: 'left' }, to: { ref: 'J_BR', side: 'center' } },
                    { from: { ref: 'J_BR', side: 'center' }, to: { ref: 'R3', side: 'right' } },
                    { from: { ref: 'J_BL', side: 'center' }, to: { ref: 'B1', side: 'negative' } }
                ]
            },
            troubleshoot_short_circuit: {
                name: "Troubleshooting: Short Circuit",
                description: "Standard four-side series loop with an added battery bypass short.",
                objectives: [
                    "Identify the short circuit path.",
                    "Fix it so current flows without short-circuit warnings."
                ],
                components: [
                    { id: 'B1', type: 'battery', position: [-10, 0, 0], rotation: 1.5707963267948966, properties: { voltage: 9 } },
                    { id: 'R1', type: 'resistor', position: [0, 0, 6], properties: { resistance: 220 } },
                    { id: 'R2', type: 'resistor', position: [10, 0, 0], rotation: 1.5707963267948966, properties: { resistance: 180 } },
                    { id: 'R3', type: 'resistor', position: [0, 0, -6], properties: { resistance: 330 } }
                ],
                junctions: [
                    { id: 'J_TL', position: [-10, 0, 6] },
                    { id: 'J_TR', position: [10, 0, 6] },
                    { id: 'J_BR', position: [10, 0, -6] },
                    { id: 'J_BL', position: [-10, 0, -6] }
                ],
                wires: [
                    { from: { ref: 'B1', side: 'positive' }, to: { ref: 'J_TL', side: 'center' } },
                    { from: { ref: 'J_TL', side: 'center' }, to: { ref: 'R1', side: 'left' } },
                    { from: { ref: 'R1', side: 'right' }, to: { ref: 'J_TR', side: 'center' } },
                    { from: { ref: 'J_TR', side: 'center' }, to: { ref: 'R2', side: 'right' } },
                    { from: { ref: 'R2', side: 'left' }, to: { ref: 'J_BR', side: 'center' } },
                    { from: { ref: 'J_BR', side: 'center' }, to: { ref: 'R3', side: 'right' } },
                    { from: { ref: 'R3', side: 'left' }, to: { ref: 'J_BL', side: 'center' } },
                    { from: { ref: 'J_BL', side: 'center' }, to: { ref: 'B1', side: 'negative' } },
                    { from: { ref: 'B1', side: 'positive' }, to: { ref: 'B1', side: 'negative' } }
                ]
            },
            troubleshoot_led_reverse: {
                name: "Troubleshooting: Reversed LED",
                description: "Standard four-side series loop with reversed LED polarity on the top leg.",
                objectives: [
                    "Identify the polarity mismatch.",
                    "Reverse the LED wiring/orientation to restore current flow."
                ],
                components: [
                    { id: 'B1', type: 'battery', position: [-10, 0, 0], rotation: 1.5707963267948966, properties: { voltage: 9 } },
                    { id: 'LED1', type: 'led', position: [0, 0, 6], properties: { resistance: 60 } },
                    { id: 'R1', type: 'resistor', position: [10, 0, 0], rotation: 1.5707963267948966, properties: { resistance: 220 } },
                    { id: 'R2', type: 'resistor', position: [0, 0, -6], properties: { resistance: 180 } }
                ],
                junctions: [
                    { id: 'J_TL', position: [-10, 0, 6] },
                    { id: 'J_TR', position: [10, 0, 6] },
                    { id: 'J_BR', position: [10, 0, -6] },
                    { id: 'J_BL', position: [-10, 0, -6] }
                ],
                wires: [
                    { from: { ref: 'B1', side: 'positive' }, to: { ref: 'J_TL', side: 'center' } },
                    { from: { ref: 'J_TL', side: 'center' }, to: { ref: 'LED1', side: 'right' } },
                    { from: { ref: 'LED1', side: 'left' }, to: { ref: 'J_TR', side: 'center' } },
                    { from: { ref: 'J_TR', side: 'center' }, to: { ref: 'R1', side: 'right' } },
                    { from: { ref: 'R1', side: 'left' }, to: { ref: 'J_BR', side: 'center' } },
                    { from: { ref: 'J_BR', side: 'center' }, to: { ref: 'R2', side: 'right' } },
                    { from: { ref: 'R2', side: 'left' }, to: { ref: 'J_BL', side: 'center' } },
                    { from: { ref: 'J_BL', side: 'center' }, to: { ref: 'B1', side: 'negative' } }
                ]
            }
        };

        function updatePracticeStatus() {
            if (!currentPracticeCircuit) return;
            
            const circuitStatusEl = document.getElementById('circuit-status');
            const circuitStatusTextEl = document.getElementById('circuit-status-text');
            const wireInstructionsEl = document.getElementById('wire-instructions');
            
            // Check if circuit is complete (has wires connecting components)
            const isComplete = wires.length > 0 && components.length > 1;
            const hasFlow = lastKnownValues.current > 0 && lastKnownValues.resistance !== Infinity;
            
            if (circuitStatusEl && circuitStatusTextEl) {
                if (hasFlow) {
                    circuitStatusEl.className = 'circuit-status status-complete';
                    circuitStatusTextEl.textContent = 'Circuit complete - current flowing! Switch to Solve tab.';
                    if (wireInstructionsEl) wireInstructionsEl.style.display = 'none';
                } else if (isComplete) {
                    circuitStatusEl.className = 'circuit-status status-incomplete';
                    circuitStatusTextEl.textContent = 'Circuit wired but not complete - check connections.';
                    if (wireInstructionsEl) wireInstructionsEl.style.display = 'block';
                } else {
                    circuitStatusEl.className = 'circuit-status status-incomplete';
                    circuitStatusTextEl.textContent = 'Circuit incomplete - add wires to connect components.';
                    if (wireInstructionsEl) wireInstructionsEl.style.display = 'block';
                }
            }
        }

        function loadPresetCircuit(presetName) {
            // Map additional preset hints to existing presets for broader compatibility
            const PRESET_ALIASES = {
                series_voltage_drop: 'series_basic',
                series_power: 'series_basic',
                series_four_resistor: 'series_basic',
                series_unknown_resistance: 'series_basic',
                series_led_resistor: 'series_basic',
                textbook_series_basic: 'series_basic',
                textbook_series_chain: 'series_basic',
                parallel_current: 'parallel_basic',
                parallel_power: 'parallel_basic',
                parallel_four_branch: 'parallel_basic',
                parallel_equal_resistors: 'parallel_basic',
                parallel_product_sum: 'parallel_basic',
                textbook_parallel_basic: 'parallel_basic',
                textbook_parallel_three: 'parallel_basic',
                combo_sp: 'mixed_circuit',
                combo_simple: 'mixed_circuit',
                combo_parallel_first: 'mixed_circuit',
                textbook_combo_basic: 'mixed_circuit',
                textbook_combo_ladder: 'mixed_circuit',
                combo_double_parallel: 'combination_advanced',
                combo_nested: 'combination_advanced',
                textbook_combo_nested: 'combination_advanced',
                textbook_combo_double: 'combination_advanced'
            };

            const inferPresetFromTopology = (name) => {
                if (!name) return null;
                if (name.startsWith('series') || name.startsWith('textbook_series')) {
                    return 'series_basic';
                }
                if (name.startsWith('parallel') || name.startsWith('textbook_parallel')) {
                    return 'parallel_basic';
                }
                if (
                    name.startsWith('combo') ||
                    name.startsWith('mixed') ||
                    name.startsWith('combination') ||
                    name.startsWith('textbook_combo')
                ) {
                    return 'mixed_circuit';
                }
                return null;
            };

            const lookupName = typeof presetName === 'string' ? presetName.trim().toLowerCase() : '';
            const aliasedPreset = PRESET_ALIASES[lookupName] || inferPresetFromTopology(lookupName);
            const resolvedPresetName = PRESET_CIRCUITS[lookupName]
                ? lookupName
                : (aliasedPreset && PRESET_CIRCUITS[aliasedPreset] ? aliasedPreset : lookupName);
            const preset = PRESET_CIRCUITS[resolvedPresetName];
            if (!preset) {
                setStatus(`Preset circuit not found: ${presetName || 'unknown'}`);
                return;
            }

            clearAll(false);
            currentPracticeCircuit = resolvedPresetName;

            const index = practiceProblems.indexOf(resolvedPresetName);
            if (index !== -1) {
                currentProblemIndex = index;
            }

            const componentLookup = new Map();
            const junctionLookup = new Map();

            if (Array.isArray(preset.components)) {
                preset.components.forEach((compData) => {
                    const position = new THREE.Vector3(compData.position[0], compData.position[1], compData.position[2]);
                    const component = new Component(compData.type, position);
                    if (compData.properties) {
                        component.updateProperties(compData.properties);
                    }
                    if (typeof compData.rotation === 'number' && component.mesh) {
                        const normalizedRotation = normalizeAngle(compData.rotation || 0);
                        component.rotation = normalizedRotation;
                        component.mesh.rotation.y = normalizedRotation;
                    }
                    if (compData.metadata) {
                        component.metadata = { ...compData.metadata };
                    }
                    components.push(component);

                    const identifier = component.getComponentIdentifier ? component.getComponentIdentifier() : null;
                    if (identifier) {
                        componentLookup.set(identifier, component);
                    }
                    if (compData.id) {
                        componentLookup.set(compData.id, component);
                    }
                    if (Array.isArray(compData.aliases)) {
                        compData.aliases.forEach((alias) => componentLookup.set(alias, component));
                    }
                    componentLookup.set(component.id, component);
                });
            }

            if (Array.isArray(preset.junctions)) {
                preset.junctions.forEach((junctionData) => {
                    const position = new THREE.Vector3(junctionData.position[0], junctionData.position[1], junctionData.position[2]);
                    const junction = new Junction(position);
                    junctions.push(junction);
                    if (junctionData.id) {
                        junctionLookup.set(junctionData.id, junction);
                    }
                    junctionLookup.set(junction.id, junction);
                });
            }

            const resolvePresetEndpoint = (endpoint) => {
                if (!endpoint || !endpoint.ref) {
                    return null;
                }
                let target = componentLookup.get(endpoint.ref) || junctionLookup.get(endpoint.ref);
                if (!target) {
                    const fallback = components.find((comp) => comp.getComponentIdentifier && comp.getComponentIdentifier() === endpoint.ref);
                    if (fallback) {
                        target = fallback;
                    }
                }
                if (!target) {
                    console.warn('Preset wiring missing endpoint', endpoint);
                    return null;
                }
                const defaultSide = target instanceof Junction ? 'center' : (target.type === 'battery' ? 'positive' : 'left');
                return {
                    object: target,
                    side: endpoint.side || defaultSide
                };
            };

            if (Array.isArray(preset.wires)) {
                preset.wires.forEach((wireSpec) => {
                    const start = resolvePresetEndpoint(wireSpec.from);
                    const end = resolvePresetEndpoint(wireSpec.to);
                    if (!start || !end) {
                        return;
                    }
                    try {
                        const wire = new Wire(start.object, start.side, end.object, end.side);
                        wires.push(wire);
                    } catch (error) {
                        console.warn('Failed to create preset wire', wireSpec, error);
                    }
                });
            }

            const questionEl = document.getElementById('practice-question');
            const descriptionEl = document.getElementById('practice-description');
            const practiceCardEl = document.getElementById('practice-problem-card');
            const helpTextEl = document.getElementById('practice-help-text');
            const objList = document.getElementById('objectives-list');

            const practiceInfo = practiceQuestions[lookupName] || practiceQuestions[resolvedPresetName];

            if (questionEl && practiceInfo) {
                questionEl.textContent = `Problem: ${practiceInfo.question}`;
            }

            if (descriptionEl) {
                const descriptionHtml = practiceInfo?.description || preset.description || '';
                descriptionEl.innerHTML = descriptionHtml;
            }

            if (practiceCardEl) {
                practiceCardEl.style.display = 'block';
            }

            if (helpTextEl) {
                helpTextEl.style.display = 'none';
            }

            if (objList && preset.objectives) {
                objList.innerHTML = preset.objectives.map(obj => `<li>${obj}</li>`).join('');
            }

            renderWireWorksheetFromPreset(resolvedPresetName, preset);

            document.querySelectorAll('.practice-btn').forEach(btn => btn.classList.remove('active'));
            const buttonIds = {
                'series_basic': 'btn-series',
                'parallel_basic': 'btn-parallel', 
                'mixed_circuit': 'btn-mixed',
                'combination_advanced': 'btn-combination'
            };
            const buttonId = buttonIds[resolvedPresetName];
            if (buttonId) {
                const button = document.getElementById(buttonId);
                if (button) button.classList.add('active');
            }

            updatePracticeCounter();
            updateNavigationButtons();

            if (currentAnalysisTab !== 'practice') {
                switchAnalysisTab('practice');
            }

            fitToScreen();
            updateCircuitInfo();
            updatePracticeStatus();
            setStatus(`Loaded practice problem: ${preset.name} - Apply W.I.R.E. to solve the unknowns.`);
        }

        function autoConnectSeries() {
            // Auto-connect components in series for educational purposes
            // Note: This is mainly used for demonstration, practice mode requires manual wiring
            if (components.length < 2) return;
            
            try {
                for (let i = 0; i < components.length - 1; i++) {
                    const comp1 = components[i];
                    const comp2 = components[i + 1];
                    
                    let startSide, endSide;
                    
                    // Determine connection sides based on component types
                    if (comp1.type === 'battery') {
                        startSide = 'positive';
                    } else {
                        startSide = 'right';
                    }
                    
                    endSide = 'left';
                    
                    const wire = new Wire(comp1, startSide, comp2, endSide);
                    wires.push(wire);
                }
                
                // Close the circuit - connect last component back to battery
                if (components.length > 1) {
                    const lastComp = components[components.length - 1];
                    const battery = components.find(c => c.type === 'battery');
                    
                    if (lastComp && battery && lastComp !== battery) {
                        const wire = new Wire(lastComp, 'right', battery, 'negative');
                        wires.push(wire);
                    }
                }
                
                analyzeCircuit();
                setStatus(' Circuit auto-wired for demonstration');
            } catch (error) {
                console.log('Auto-connect failed, students can wire manually');
            }
        }

        function generateRandomProblem() {
            // Generate a random circuit problem
            const problemTypes = ['series_basic', 'parallel_basic', 'mixed_circuit', 'combination_advanced'];
            const randomType = problemTypes[Math.floor(Math.random() * problemTypes.length)];
            
            loadPresetCircuit(randomType);
            
            // Randomize component values
            components.forEach(comp => {
                if (comp.type === 'battery') {
                    comp.updateProperties({ voltage: Math.floor(Math.random() * 15) + 3 }); // 3-18V
                } else if (comp.type === 'resistor') {
                    comp.updateProperties({ resistance: Math.floor(Math.random() * 500) + 50 }); // 50-550?
                } else if (comp.type === 'led') {
                    comp.updateProperties({ resistance: Math.floor(Math.random() * 30) + 10 }); // 10-40?
                }
            });
            
            renderWireWorksheetFromActiveCircuit('Randomised Circuit');

            // Highlight random button
            document.querySelectorAll('.practice-btn').forEach(btn => btn.classList.remove('active'));
            const randomBtn = document.getElementById('btn-random');
            if (randomBtn) randomBtn.classList.add('active');
            
            // Reset practice sequence tracking
            currentPracticeCircuit = 'random';
            updatePracticeCounter();
            
            updateCircuitInfo();
            updatePracticeStatus();
            setStatus(' Generated random practice problem with randomized values!');
        }

        // Practice sequence navigation functions
        function startPracticeSequence() {
            currentProblemIndex = 0;
            loadPracticeSequenceProblem();
            setStatus(' Started practice sequence - Problem 1 of 4');
        }

        function nextProblem() {
            if (currentProblemIndex < practiceProblems.length - 1) {
                currentProblemIndex++;
                loadPracticeSequenceProblem();
                setStatus(`  Advanced to problem ${currentProblemIndex + 1} of ${practiceProblems.length}`);
            } else {
                setStatus(' Congratulations! You completed all practice problems!');
                alert('?? Great job! You\'ve completed all practice problems.\n\nYou can:\n? Start over with "Start Practice Sequence"\n? Try "Random" for extra practice\n? Use individual problem buttons for review');
            }
        }

        function previousProblem() {
            if (currentProblemIndex > 0) {
                currentProblemIndex--;
                loadPracticeSequenceProblem();
                setStatus(`  Returned to problem ${currentProblemIndex + 1} of ${practiceProblems.length}`);
            } else {
                setStatus(' Already at the first problem');
            }
        }

        function loadPracticeSequenceProblem() {
            const problemType = practiceProblems[currentProblemIndex];
            loadPresetCircuit(problemType);
            updatePracticeCounter();
            updateNavigationButtons();
        }

        function updatePracticeCounter() {
            const counterEl = document.getElementById('problem-counter');
            const totalEl = document.getElementById('total-problems');
            
            if (counterEl && totalEl) {
                if (currentPracticeCircuit === 'random') {
                    counterEl.textContent = '?';
                    totalEl.textContent = '?';
                } else {
                    counterEl.textContent = currentProblemIndex + 1;
                    totalEl.textContent = practiceProblems.length;
                }
            }
        }

        function updateNavigationButtons() {
            const prevBtn = document.getElementById('prev-btn');
            const nextBtn = document.getElementById('next-btn');
            
            if (prevBtn && nextBtn) {
                // Show/hide buttons based on position
                prevBtn.style.opacity = currentProblemIndex > 0 ? '1.0' : '0.5';
                prevBtn.disabled = currentProblemIndex === 0;
                
                if (currentProblemIndex >= practiceProblems.length - 1) {
                    nextBtn.textContent = 'Finish ??';
                    nextBtn.style.background = 'linear-gradient(135deg, #ff6b6b, #ee5a52)';
                } else {
                    nextBtn.textContent = 'Next ?';
                    nextBtn.style.background = 'linear-gradient(135deg, #333, #444)';
                }
            }
        }

        function clearAll(shouldSaveState = true) {
            if (shouldSaveState) {
                saveState(); // Save for undo
            }
            
            hideComponentContextMenu();

            disableWireMode({ silent: true, skipNotify: true });
            disableRotateMode({ silent: true, skipNotify: true });
            exitMeasureMode({ silent: true, skipNotify: true });
            notifyParentToolState('select');

            wireStart = null;
            isDragging = false;
            selectedComponent = null;
            selectedComponents.clear();
            hideSnapIndicator();
            measureStartPoint = null;
            currentPracticeCircuit = null; // Reset practice circuit
            // Note: Don't reset currentProblemIndex to allow "Clear" during practice sequence
            
            // Reset component counters
            componentCounters = {
                battery: 0,
                resistor: 0,
                led: 0,
                switch: 0,
                capacitor: 0,
                'capacitor-ceramic': 0,
                inductor: 0,
                diode: 0,
                'zener-diode': 0,
                photodiode: 0,
                thermistor: 0,
                crystal: 0,
                bjt: 0,
                'bjt-npn': 0,
                'bjt-pnp': 0,
                darlington: 0,
                mosfet: 0,
                fuse: 0,
                potentiometer: 0,
                lamp: 0,
                ground: 0,
                ac_source: 0,
                motor: 0,
                speaker: 0,
                opamp: 0,
                transformer: 0
            };

            // Reset placement index for staggered positioning
            componentPlacementIndex = 0;
            
            currentFlowParticles.forEach(particle => {
                if (particle) scene.remove(particle);
            });
            currentFlowParticles = [];
            
            wires.forEach(wire => {
                if (wire?.wireGroup) scene.remove(wire.wireGroup);
            });
            wires = [];
            
            components.forEach(comp => {
                if (comp?.mesh) scene.remove(comp.mesh);
                if (comp?.labelDiv) document.body.removeChild(comp.labelDiv);
                // Remove polarity indicators
                if (comp?.polarityDivs) {
                    comp.polarityDivs.forEach(item => {
                        if (item.div && item.div.parentNode) {
                            document.body.removeChild(item.div);
                        }
                    });
                    comp.polarityDivs = null;
                }
            });
            components = [];
            
            junctions.forEach(junction => {
                if (junction?.mesh) scene.remove(junction.mesh);
            });
            junctions = [];
            
            // Clean up any orphaned polarity indicators as a safety measure
            document.querySelectorAll('.polarity-indicator').forEach(el => {
                if (el.parentNode) {
                    document.body.removeChild(el);
                }
            });
            
            // Reset practice mode UI only if not in a practice sequence
            if (!currentPracticeCircuit) {
                const practiceCardEl = document.getElementById('practice-problem-card');
                const helpTextEl = document.getElementById('practice-help-text');
                if (practiceCardEl) practiceCardEl.style.display = 'none';
                if (helpTextEl) helpTextEl.style.display = 'block';
                
                // Remove active state from practice buttons
                document.querySelectorAll('.practice-btn').forEach(btn => btn.classList.remove('active'));
                
                // Reset practice sequence
                currentProblemIndex = 0;
            }

            clearWireWorksheetDisplay();
            
            updateButtonStates();
            updateCircuitInfo();
            closeAllSubmenus();
            setStatus(' ALL CLEARED! Circuit builder reset with fresh component numbering');
        }

        function showPracticeModeHelp() {
            const help = `
TABLE METHOD CHECKLIST

1. Load a practice problem using Start Practice Sequence, the individual circuit buttons, or Random.
2. Scroll to the W.I.R.E. worksheet under the Practice panel.
3. Record every given value in the table columns: W (power), I (current), R (resistance), E (voltage).
4. Pick the matching formula:
   - Ohm's Law: E = I * R, I = E / R, R = E / I
   - Power: P = E * I, P = I * I * R, P = (E * E) / R
5. Solve each unknown in the table, then tap Reveal totals to confirm with Kirchhoff.
6. Press Clear entries anytime you want a fresh worksheet without reloading the circuit.

Navigation tips:
- Start Practice Sequence walks through the four core problems in order.
- Use Prev / Next buttons to move through the sequence and Finish when the counter reaches the end.
- Load individual problems to focus on one topology or use Random for new values with the same layout.

Need more detail? Open the Table Method Guide in the Builder sidebar for printable worksheets and step-by-step examples.
            `;
            alert(help);
        }

        function setStatus(message) {
            const statusEl = document.getElementById('status');
            if (statusEl) {
                statusEl.textContent = message;
                statusEl.style.display = 'block';
                
                setTimeout(() => {
                    if (statusEl.style.display !== 'none') {
                        statusEl.style.display = 'none';
                    }
                }, isMobile ? 6000 : 5000); // Longer display time on mobile
            }
        }

        // Start the application
        init();
    </script>
</body>
</html>