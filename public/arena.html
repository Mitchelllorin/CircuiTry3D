<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
  <meta name="application-name" content="CircuiTry3D" />
  <meta name="mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="format-detection" content="telephone=no" />
  <title>CircuiTry3D • Component Arena</title>
  <style>
    :root {
      --safe-top: env(safe-area-inset-top, 0px);
      --safe-left: env(safe-area-inset-left, 0px);
      --safe-right: env(safe-area-inset-right, 0px);
      --safe-bottom: env(safe-area-inset-bottom, 0px);
    }

    html,
    body {
      margin: 0;
      height: 100%;
      background: radial-gradient(ellipse at top, #1e1b4b 0%, #020617 55%, #010413 100%);
      color: #fff;
      font-family: "DM Sans", "Inter", system-ui, sans-serif;
      padding: var(--safe-top) var(--safe-right) var(--safe-bottom) var(--safe-left);
      box-sizing: border-box;
      overflow: hidden;
    }

    body::before {
      content: "";
      position: fixed;
      inset: 0;
      background: radial-gradient(circle at 50% -10%, rgba(14, 165, 233, 0.28), transparent 55%),
        radial-gradient(circle at 80% 20%, rgba(168, 85, 247, 0.25), transparent 52%),
        radial-gradient(circle at 20% 80%, rgba(244, 63, 94, 0.2), transparent 60%);
      z-index: 0;
      pointer-events: none;
      opacity: 0.9;
    }

    #arena {
      position: fixed;
      inset: 0;
      width: 100%;
      height: 100%;
      display: block;
      z-index: 1;
    }

    .hud {
      position: fixed;
      top: calc(16px + var(--safe-top));
      left: calc(16px + var(--safe-left));
      right: calc(16px + var(--safe-right));
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items: center;
      z-index: 3;
    }

    .btn {
      padding: 12px 18px;
      border-radius: 12px;
      border: 1px solid rgba(94, 234, 212, 0.45);
      background: rgba(15, 23, 42, 0.9);
      color: #e5e7eb;
      font-weight: 700;
      cursor: pointer;
      touch-action: manipulation;
      letter-spacing: 0.01em;
      transition: transform 0.2s ease, box-shadow 0.2s ease;
      box-shadow: 0 0 0 rgba(34, 211, 238, 0);
    }

    .btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 10px 25px rgba(34, 211, 238, 0.25);
    }

    .panel {
      position: fixed;
      top: calc(80px + var(--safe-top));
      left: calc(16px + var(--safe-left));
      width: 340px;
      max-width: calc(100% - 32px - var(--safe-left) - var(--safe-right));
      background: rgba(10, 12, 28, 0.82);
      backdrop-filter: blur(16px);
      border: 1px solid rgba(96, 165, 250, 0.35);
      border-radius: 16px;
      padding: 16px;
      z-index: 3;
      box-shadow: 0 25px 50px -12px rgba(59, 130, 246, 0.45);
    }

    .panel h2 {
      margin: 0 0 12px;
      font-size: 15px;
      font-weight: 700;
      color: rgba(226, 232, 240, 0.9);
      letter-spacing: 0.02em;
      text-transform: uppercase;
    }

    .row {
      display: flex;
      gap: 10px;
      align-items: center;
      margin-bottom: 10px;
    }

    .row label {
      width: 120px;
      font-size: 12px;
      color: rgba(148, 163, 184, 0.9);
      text-transform: uppercase;
      letter-spacing: 0.08em;
    }

    .row input,
    .row select {
      flex: 1;
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid rgba(71, 85, 105, 0.6);
      background: rgba(15, 23, 42, 0.88);
      color: #e5e7eb;
      font-size: 13px;
      transition: border-color 0.2s ease, box-shadow 0.2s ease;
      box-shadow: inset 0 0 0 0 rgba(59, 130, 246, 0);
    }

    .row input:focus,
    .row select:focus {
      outline: none;
      border-color: rgba(59, 130, 246, 0.9);
      box-shadow: inset 0 0 0 1px rgba(59, 130, 246, 0.6);
    }

    .stat {
      font-size: 12px;
      color: rgba(129, 140, 248, 0.95);
      margin-top: 12px;
      padding: 10px 12px;
      border-radius: 10px;
      background: rgba(30, 64, 175, 0.25);
      border: 1px solid rgba(56, 189, 248, 0.25);
      letter-spacing: 0.03em;
    }

    @media (pointer: coarse) {
      .btn {
        min-height: 52px;
        padding: 14px 22px;
        font-size: 16px;
      }

      .row label {
        font-size: 13px;
      }

      .row input,
      .row select {
        min-height: 46px;
      }
    }
  </style>
</head>
<body>
  <div class="hud">
    <button class="btn" onclick="resetArena()">Reset</button>
    <button class="btn" onclick="runTest()">Run Test</button>
    <button class="btn" onclick="exportResults()">Export</button>
  </div>
  <div class="panel">
    <h2>Run Your Component Battle</h2>
    <div class="row"><label>Mode</label>
      <select id="mode">
        <option value="single">Single</option>
        <option value="compare">Compare (A vs B)</option>
      </select>
    </div>
    <hr style="border:none;border-top:1px solid #334155;margin:8px 0" />
    <div class="row"><label>Comp A</label>
      <select id="comp-type-a">
        <option value="resistor">Resistor</option>
        <option value="capacitor">Capacitor</option>
        <option value="inductor">Inductor</option>
        <option value="led">LED</option>
      </select>
    </div>
    <div class="row"><label>Value A</label><input id="comp-value-a" type="number" value="100" /></div>
    <div class="row compare-only" style="display:none"><label>Comp B</label>
      <select id="comp-type-b">
        <option value="resistor">Resistor</option>
        <option value="capacitor">Capacitor</option>
        <option value="inductor">Inductor</option>
        <option value="led">LED</option>
      </select>
    </div>
    <div class="row compare-only" style="display:none"><label>Value B</label><input id="comp-value-b" type="number" value="200" /></div>
    <hr style="border:none;border-top:1px solid #334155;margin:8px 0" />
    <div class="row"><label>Voltage (V)</label><input id="test-voltage" type="number" value="5" /></div>
    <div class="row"><label>Frequency (Hz)</label><input id="test-frequency" type="number" value="1000" /></div>
    <div class="stat" id="stat-out">Ready.</div>
  </div>
  <canvas id="arena"></canvas>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    let scene, camera, renderer, clock;
    let componentA, componentB, energyRing, pulseRing, particles;
    const particleSpeeds = [];
    const arenaState = { mode: 'single' };
    const canvas = document.getElementById('arena');

    const componentPalettes = {
      resistor: { base: 0xf97316, glow: 0xffedd5, orbit: 0xfb923c, band: 0xfacc15 },
      capacitor: { base: 0x38bdf8, glow: 0x22d3ee, orbit: 0x0ea5e9, accent: 0xffffff },
      inductor: { base: 0xa855f7, glow: 0xc4b5fd, orbit: 0x8b5cf6 },
      led: { base: 0xf43f5e, glow: 0xfda4af, orbit: 0xf472b6 },
      default: { base: 0x38bdf8, glow: 0x1d4ed8, orbit: 0x38bdf8 }
    };

    function init() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x050716);
      scene.fog = new THREE.Fog(0x050716, 14, 36);

      camera = new THREE.PerspectiveCamera(62, window.innerWidth / window.innerHeight, 0.1, 100);
      camera.position.set(0, 2.8, 7.6);

      renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
      renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
      renderer.setSize(window.innerWidth, window.innerHeight);

      clock = new THREE.Clock();

      addLights();
      addStageElements();
      addParticles();

      runTest();

      window.addEventListener('resize', onResize);

      animate();
    }

    function addLights() {
      const hemi = new THREE.HemisphereLight(0x4c86ff, 0x050716, 0.7);
      scene.add(hemi);

      const key = new THREE.SpotLight(0x8b5cf6, 2.1, 40, Math.PI / 5, 0.7, 1.3);
      key.position.set(-6, 9, 6);
      scene.add(key);
      scene.add(key.target);
      key.target.position.set(0, 0, 0);

      const fill = new THREE.SpotLight(0x38bdf8, 1.8, 40, Math.PI / 5, 0.7, 1.1);
      fill.position.set(7, 7, 2);
      scene.add(fill);
      scene.add(fill.target);
      fill.target.position.set(0, 0, 0);

      const rim = new THREE.DirectionalLight(0x22d3ee, 0.7);
      rim.position.set(0, 6, -6);
      scene.add(rim);

      const uplight = new THREE.PointLight(0xfacc15, 0.8, 12, 2);
      uplight.position.set(0, -0.2, 0);
      scene.add(uplight);
    }

    function addStageElements() {
      const grid = new THREE.GridHelper(28, 56, 0x1d4ed8, 0x14b8a6);
      grid.position.y = -1.6;
      grid.material.transparent = true;
      grid.material.opacity = 0.2;
      grid.material.depthWrite = false;
      scene.add(grid);

      const platform = new THREE.Mesh(
        new THREE.CylinderGeometry(3.8, 3.8, 0.45, 72),
        new THREE.MeshStandardMaterial({
          color: 0x0b1220,
          metalness: 0.45,
          roughness: 0.35,
          emissive: 0x0ea5e9,
          emissiveIntensity: 0.24
        })
      );
      platform.position.y = -0.6;
      scene.add(platform);

      const innerGlow = new THREE.Mesh(
        new THREE.CircleGeometry(2.6, 72),
        new THREE.MeshBasicMaterial({
          color: 0x1d4ed8,
          transparent: true,
          opacity: 0.45,
          blending: THREE.AdditiveBlending,
          depthWrite: false
        })
      );
      innerGlow.rotation.x = -Math.PI / 2;
      innerGlow.position.y = -0.37;
      scene.add(innerGlow);

      energyRing = new THREE.Mesh(
        new THREE.TorusGeometry(3.2, 0.08, 24, 220),
        new THREE.MeshBasicMaterial({
          color: 0x38bdf8,
          transparent: true,
          opacity: 0.55,
          blending: THREE.AdditiveBlending,
          depthWrite: false
        })
      );
      energyRing.rotation.x = Math.PI / 2;
      energyRing.position.y = -0.28;
      scene.add(energyRing);

      pulseRing = new THREE.Mesh(
        new THREE.RingGeometry(2.2, 2.45, 72),
        new THREE.MeshBasicMaterial({
          color: 0xfacc15,
          transparent: true,
          opacity: 0,
          side: THREE.DoubleSide,
          blending: THREE.AdditiveBlending,
          depthWrite: false
        })
      );
      pulseRing.rotation.x = Math.PI / 2;
      pulseRing.position.y = -0.32;
      pulseRing.userData = { life: 0, strength: 0 };
      scene.add(pulseRing);
    }

    function addParticles() {
      const particleCount = 420;
      const positions = new Float32Array(particleCount * 3);
      for (let i = 0; i < particleCount; i++) {
        positions[i * 3] = (Math.random() - 0.5) * 16;
        positions[i * 3 + 1] = Math.random() * 5.5 + 0.3;
        positions[i * 3 + 2] = (Math.random() - 0.5) * 16;
        particleSpeeds.push(Math.random() * 0.7 + 0.25);
      }
      const geometry = new THREE.BufferGeometry();
      geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

      const material = new THREE.PointsMaterial({
        color: 0x60a5fa,
        size: 0.07,
        transparent: true,
        opacity: 0.85,
        blending: THREE.AdditiveBlending,
        depthWrite: false
      });

      particles = new THREE.Points(geometry, material);
      particles.frustumCulled = false;
      scene.add(particles);
    }

    function buildComponent(type, value, isPrimary) {
      const palette = componentPalettes[type] || componentPalettes.default;
      const group = new THREE.Group();
      group.userData = {
        palette,
        energy: 0.3,
        bobOffset: Math.random() * Math.PI * 2,
        baseScale: computeScale(value)
      };

      const material = new THREE.MeshStandardMaterial({
        color: palette.base,
        metalness: 0.35,
        roughness: 0.28,
        emissive: palette.glow,
        emissiveIntensity: 0.35
      });

      let core;
      switch (type) {
        case 'resistor': {
          core = new THREE.Mesh(new THREE.BoxGeometry(1.4, 0.5, 0.5), material);
          const leadGeometry = new THREE.CylinderGeometry(0.07, 0.07, 0.9, 20);
          const leadMaterial = new THREE.MeshStandardMaterial({
            color: 0xbcd0ff,
            metalness: 0.85,
            roughness: 0.25,
            emissive: 0x1e293b,
            emissiveIntensity: 0.1
          });
          const leadL = new THREE.Mesh(leadGeometry, leadMaterial);
          leadL.position.x = -1.05;
          leadL.rotation.z = Math.PI / 2;
          const leadR = leadL.clone();
          leadR.position.x = 1.05;
          group.add(leadL, leadR);

          const bandMaterial = new THREE.MeshStandardMaterial({
            color: palette.band,
            metalness: 0.45,
            roughness: 0.35,
            emissive: palette.band,
            emissiveIntensity: 0.22
          });
          [-0.35, 0, 0.35].forEach((offset) => {
            const band = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.6, 0.58), bandMaterial);
            band.position.x = offset;
            group.add(band);
          });
          break;
        }
        case 'capacitor': {
          core = new THREE.Mesh(new THREE.CylinderGeometry(0.55, 0.55, 1.2, 48), material);
          const capTopMat = new THREE.MeshStandardMaterial({
            color: palette.accent || 0xffffff,
            metalness: 0.9,
            roughness: 0.18,
            emissive: palette.glow,
            emissiveIntensity: 0.12
          });
          const top = new THREE.Mesh(new THREE.CircleGeometry(0.55, 48), capTopMat);
          top.rotation.x = Math.PI / 2;
          top.position.y = 0.6;
          const bottom = top.clone();
          bottom.position.y = -0.6;
          bottom.rotation.x = -Math.PI / 2;
          group.add(top, bottom);

          const leadMaterial = new THREE.MeshStandardMaterial({
            color: 0x86efac,
            metalness: 0.6,
            roughness: 0.45
          });
          const leadGeometry = new THREE.CylinderGeometry(0.045, 0.045, 1.4, 16);
          const lead1 = new THREE.Mesh(leadGeometry, leadMaterial);
          lead1.position.set(-0.2, -1.1, 0);
          const lead2 = lead1.clone();
          lead2.position.x = 0.2;
          group.add(lead1, lead2);
          break;
        }
        case 'inductor': {
          core = new THREE.Mesh(new THREE.TorusKnotGeometry(0.55, 0.16, 100, 18, 2, 3), material);
          break;
        }
        case 'led': {
          core = new THREE.Mesh(new THREE.ConeGeometry(0.45, 1.2, 36, 1, true), material);
          core.position.y = 0.35;
          const bulb = new THREE.Mesh(
            new THREE.SphereGeometry(0.38, 36, 36),
            new THREE.MeshStandardMaterial({
              color: 0xffffff,
              emissive: palette.glow,
              emissiveIntensity: 0.85,
              metalness: 0.1,
              roughness: 0.08,
              transparent: true,
              opacity: 0.75
            })
          );
          bulb.position.y = 0.65;
          group.add(bulb);

          const base = new THREE.Mesh(new THREE.CylinderGeometry(0.26, 0.32, 0.28, 32), new THREE.MeshStandardMaterial({
            color: 0x1f2937,
            metalness: 0.75,
            roughness: 0.42
          }));
          base.position.y = -0.35;
          group.add(base);

          const legGeometry = new THREE.CylinderGeometry(0.045, 0.045, 1.35, 16);
          const legMaterial = new THREE.MeshStandardMaterial({
            color: 0xdbeafe,
            metalness: 0.9,
            roughness: 0.25
          });
          const leg1 = new THREE.Mesh(legGeometry, legMaterial);
          leg1.position.set(-0.14, -1.05, 0);
          const leg2 = leg1.clone();
          leg2.position.x = 0.14;
          group.add(leg1, leg2);
          break;
        }
        default: {
          core = new THREE.Mesh(new THREE.OctahedronGeometry(0.75, 0), material);
          break;
        }
      }

      group.add(core);
      group.userData.core = core;

      const halo = new THREE.Mesh(
        new THREE.SphereGeometry(0.95, 32, 32),
        new THREE.MeshBasicMaterial({
          color: palette.glow,
          transparent: true,
          opacity: 0.3,
          blending: THREE.AdditiveBlending,
          depthWrite: false
        })
      );
      group.add(halo);
      group.userData.halo = halo;

      const orbiters = [];
      for (let i = 0; i < 3; i++) {
        const orb = new THREE.Mesh(
          new THREE.SphereGeometry(0.12 + i * 0.03, 18, 18),
          new THREE.MeshBasicMaterial({
            color: palette.orbit,
            transparent: true,
            opacity: 0.78 - i * 0.2,
            depthWrite: false,
            blending: THREE.AdditiveBlending
          })
        );
        orb.userData = {
          radius: 0.95 + i * 0.22,
          height: 0.28 + i * 0.16,
          speed: 0.7 + i * 0.42
        };
        orbiters.push(orb);
        group.add(orb);
      }
      group.userData.orbiters = orbiters;

      group.scale.setScalar(group.userData.baseScale);
      group.position.y = 0.25;

      if (isPrimary) {
        const badge = new THREE.Mesh(
          new THREE.CircleGeometry(0.44, 32),
          new THREE.MeshBasicMaterial({
            color: 0x22d3ee,
            transparent: true,
            opacity: 0.4,
            depthWrite: false
          })
        );
        badge.rotation.x = -Math.PI / 2;
        badge.position.set(0, -0.68, 0);
        group.add(badge);
      }

      return group;
    }

    function computeScale(value) {
      if (!Number.isFinite(value) || value <= 0) return 1;
      const scaled = Math.log10(value + 10) / 3;
      return THREE.MathUtils.clamp(0.75 + scaled, 0.7, 2.3);
    }

    function replaceComponent(slot, type, value) {
      const previous = slot === 'A' ? componentA : componentB;
      if (previous) {
        disposeGroup(previous);
      }

      const group = buildComponent(type, value, slot === 'A');
      group.position.x = slot === 'A' ? -1.65 : 1.65;
      scene.add(group);

      if (slot === 'A') {
        componentA = group;
      } else {
        componentB = group;
      }
      return group;
    }

    function disposeGroup(group) {
      scene.remove(group);
      group.traverse((child) => {
        if (child.geometry) child.geometry.dispose();
        if (child.material) {
          if (Array.isArray(child.material)) {
            child.material.forEach((mat) => mat.dispose());
          } else {
            child.material.dispose();
          }
        }
      });
    }

    function runTest() {
      const mode = document.getElementById('mode').value;
      arenaState.mode = mode;
      setCompareUI(mode === 'compare');

      const typeA = document.getElementById('comp-type-a').value;
      const valueA = parseFloat(document.getElementById('comp-value-a').value || '0');
      const typeB = document.getElementById('comp-type-b').value;
      const valueB = parseFloat(document.getElementById('comp-value-b').value || '0');
      const V = parseFloat(document.getElementById('test-voltage').value || '0');
      const f = parseFloat(document.getElementById('test-frequency').value || '0');

      const resultA = calc(typeA, valueA, V, f);
      const groupA = replaceComponent('A', typeA, valueA);
      const energyA = computeEnergy(resultA, valueA);
      energizeComponent(groupA, energyA);

      let statusText = `A ▶ ${formatResult(resultA)}`;
      let energyMax = energyA;

      if (mode === 'compare') {
        const resultB = calc(typeB, valueB, V, f);
        const groupB = replaceComponent('B', typeB, valueB);
        groupB.visible = true;
        const energyB = computeEnergy(resultB, valueB);
        energizeComponent(groupB, energyB);
        statusText += `  |  B ▶ ${formatResult(resultB)}`;
        energyMax = Math.max(energyA, energyB);
      } else if (componentB) {
        componentB.visible = false;
      }

      document.getElementById('stat-out').textContent = statusText;
      triggerPulse(energyMax);
    }

    function calc(type, value, V, f) {
      if (type === 'resistor') {
        const resistance = value || 1;
        const current = V / resistance;
        const power = V * current;
        return { R: resistance, I: current, P: power };
      }
      if (type === 'capacitor') {
        const capacitance = value || 1e-6;
        const reactance = 1 / (2 * Math.PI * (f || 1) * capacitance);
        const current = V / reactance;
        return { C: capacitance, Xc: reactance, I: current };
      }
      if (type === 'inductor') {
        const inductance = value || 1e-3;
        const reactance = 2 * Math.PI * (f || 1) * inductance;
        const current = reactance ? V / reactance : 0;
        return { L: inductance, Xl: reactance, I: current };
      }
      if (type === 'led') {
        const forward = 2.0;
        const resistance = value || 100;
        const current = Math.max(0, V - forward) / resistance;
        return { Vf: forward, R: resistance, I: current };
      }
      return { value };
    }

    function formatResult(result) {
      return Object.entries(result)
        .map(([key, val]) => `${key}:${formatNumber(val)}`)
        .join('  ');
    }

    function formatNumber(value) {
      if (!Number.isFinite(value)) return '–';
      const abs = Math.abs(value);
      if (abs === 0) return '0';
      if (abs >= 1000 || abs < 0.01) return value.toExponential(2);
      return value.toFixed(2);
    }

    function computeEnergy(result, fallback) {
      const metrics = ['P', 'I', 'Xc', 'Xl', 'Vf', 'R', 'C', 'L'];
      let magnitude = Math.abs(fallback || 0.1);
      for (const key of metrics) {
        if (typeof result[key] === 'number' && Number.isFinite(result[key])) {
          magnitude = Math.max(magnitude, Math.abs(result[key]));
        }
      }
      const normalized = Math.log10(magnitude + 1.5) / 2.5;
      return THREE.MathUtils.clamp(normalized, 0.18, 1);
    }

    function energizeComponent(group, energy) {
      if (!group) return;
      group.userData.energy = energy;
      const core = group.userData.core;
      if (core && core.material) {
        core.material.emissiveIntensity = 0.3 + energy * 1.2;
      }
      group.scale.setScalar(group.userData.baseScale * (0.9 + energy * 0.45));
      if (group.userData.halo) {
        group.userData.halo.material.opacity = 0.22 + energy * 0.5;
        group.userData.halo.scale.setScalar(1 + energy * 0.8);
      }
    }

    function triggerPulse(intensity) {
      if (!pulseRing) return;
      pulseRing.userData.life = 1;
      pulseRing.userData.strength = THREE.MathUtils.clamp(intensity, 0.2, 1.1);
      pulseRing.scale.setScalar(1);
    }

    function resetArena() {
      document.getElementById('stat-out').textContent = 'Arena reset. Components stabilised.';
      [componentA, componentB].forEach((group) => {
        if (!group) return;
        group.rotation.set(0, 0, 0);
        energizeComponent(group, 0.25);
      });
      triggerPulse(0.3);
    }

    function exportResults() {
      const text = document.getElementById('stat-out').textContent;
      const blob = new Blob([text], { type: 'text/plain' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'arena-results.txt';
      a.click();
    }

    function setCompareUI(show) {
      document.querySelectorAll('.compare-only').forEach((el) => {
        el.style.display = show ? 'flex' : 'none';
      });
    }

    function onResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
      const delta = clock.getDelta();
      const elapsed = clock.elapsedTime;

      updateComponentAnimation(componentA, elapsed, delta);
      if (componentB && componentB.visible) {
        updateComponentAnimation(componentB, elapsed + 0.6, delta);
      }

      if (energyRing) {
        energyRing.rotation.z += delta * 0.55;
        const energyLevel = Math.max(
          componentA ? componentA.userData.energy || 0 : 0,
          componentB && componentB.visible ? componentB.userData.energy || 0 : 0
        );
        energyRing.material.opacity = 0.35 + energyLevel * 0.35;
        const pulse = 1 + Math.sin(elapsed * 1.4) * 0.04 + energyLevel * 0.12;
        energyRing.scale.setScalar(pulse);
      }

      if (pulseRing && pulseRing.userData.life > 0) {
        pulseRing.userData.life -= delta * 0.9;
        const life = Math.max(pulseRing.userData.life, 0);
        pulseRing.material.opacity = life * pulseRing.userData.strength;
        const scale = 1 + (1 - life) * (1.4 + pulseRing.userData.strength * 1.2);
        pulseRing.scale.setScalar(scale);
      }

      animateParticles(delta);

      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }

    function updateComponentAnimation(group, elapsed, delta) {
      if (!group) return;
      const energy = group.userData.energy || 0.25;
      group.rotation.y += delta * (0.8 + energy * 2.8);
      group.rotation.x = Math.sin(elapsed * 0.8 + group.userData.bobOffset) * 0.2;
      group.position.y = 0.25 + Math.sin(elapsed * 1.6 + group.userData.bobOffset) * (0.12 + energy * 0.12);
      (group.userData.orbiters || []).forEach((orb, idx) => {
        const data = orb.userData;
        const angle = elapsed * (data.speed + energy) + idx * Math.PI * 0.75;
        orb.position.set(
          Math.cos(angle) * data.radius,
          data.height + Math.sin(angle * 1.8) * 0.12,
          Math.sin(angle) * data.radius
        );
      });
    }

    function animateParticles(delta) {
      if (!particles) return;
      const positions = particles.geometry.getAttribute('position');
      for (let i = 0; i < particleSpeeds.length; i++) {
        positions.array[i * 3 + 1] += particleSpeeds[i] * delta;
        if (positions.array[i * 3 + 1] > 7) {
          positions.array[i * 3] = (Math.random() - 0.5) * 16;
          positions.array[i * 3 + 1] = Math.random() * 2;
          positions.array[i * 3 + 2] = (Math.random() - 0.5) * 16;
        }
      }
      positions.needsUpdate = true;
    }

    document.getElementById('mode').addEventListener('change', runTest);
    document.getElementById('comp-type-a').addEventListener('change', runTest);
    document.getElementById('comp-type-b').addEventListener('change', runTest);
    document.getElementById('comp-value-a').addEventListener('change', runTest);
    document.getElementById('comp-value-b').addEventListener('change', runTest);
    document.getElementById('test-voltage').addEventListener('change', runTest);
    document.getElementById('test-frequency').addEventListener('change', runTest);

    init();
  </script>
</body>
</html>
