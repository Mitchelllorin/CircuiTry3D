<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>CircuiTry3D â€¢ Component Arena</title>
  <style>
    html, body { margin: 0; height: 100%; background: #0a0a1a; color: #fff; font-family: system-ui, sans-serif; }
    .hud { position: fixed; top: 12px; left: 12px; right: 12px; display: flex; gap: 8px; flex-wrap: wrap; z-index: 2; }
    .btn { padding: 10px 14px; border-radius: 10px; border: 1px solid #334155; background: #111827; color: #e5e7eb; font-weight: 700; cursor: pointer; }
    .panel { position: fixed; top: 60px; left: 12px; width: 320px; max-width: calc(100% - 24px); background: rgba(0,0,0,0.65); backdrop-filter: blur(10px); border: 1px solid #334155; border-radius: 12px; padding: 12px; z-index: 2; }
    .row { display: flex; gap: 8px; align-items: center; margin-bottom: 8px; }
    .row label { width: 120px; font-size: 12px; color: #94a3b8; }
    .row input, .row select { flex: 1; padding: 8px; border-radius: 8px; border: 1px solid #334155; background: #0b1220; color: #e5e7eb; }
    .stat { font-size: 12px; color: #a5b4fc; margin-top: 8px; }
  </style>
</head>
<body>
  <div class="hud">
    <button class="btn" onclick="resetArena()">Reset</button>
    <button class="btn" onclick="runTest()">Run Test</button>
    <button class="btn" onclick="exportResults()">Export</button>
  </div>
  <div class="panel">
    <div class="row"><label>Mode</label>
      <select id="mode">
        <option value="single">Single</option>
        <option value="compare">Compare (A vs B)</option>
      </select>
    </div>
    <hr style="border:none;border-top:1px solid #334155;margin:8px 0" />
    <div class="row"><label>Comp A</label>
      <select id="comp-type-a">
        <option value="resistor">Resistor</option>
        <option value="capacitor">Capacitor</option>
        <option value="inductor">Inductor</option>
        <option value="led">LED</option>
      </select>
    </div>
    <div class="row"><label>Value A</label><input id="comp-value-a" type="number" value="100" /></div>
    <div class="row compare-only" style="display:none"><label>Comp B</label>
      <select id="comp-type-b">
        <option value="resistor">Resistor</option>
        <option value="capacitor">Capacitor</option>
        <option value="inductor">Inductor</option>
        <option value="led">LED</option>
      </select>
    </div>
    <div class="row compare-only" style="display:none"><label>Value B</label><input id="comp-value-b" type="number" value="200" /></div>
    <hr style="border:none;border-top:1px solid #334155;margin:8px 0" />
    <div class="row"><label>Voltage (V)</label><input id="test-voltage" type="number" value="5" /></div>
    <div class="row"><label>Frequency (Hz)</label><input id="test-frequency" type="number" value="1000" /></div>
    <div class="stat" id="stat-out">Ready.</div>
  </div>
  <canvas id="arena"></canvas>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    const MODE_ID = 'mode';
    const COMP_TYPE_A_ID = 'comp-type-a';
    const COMP_TYPE_B_ID = 'comp-type-b';
    const VALUE_A_ID = 'comp-value-a';
    const VALUE_B_ID = 'comp-value-b';
    const VOLTAGE_ID = 'test-voltage';
    const FREQUENCY_ID = 'test-frequency';
    const STAT_ID = 'stat-out';

    let scene, camera, renderer, meshA, meshB;
    const canvas = document.getElementById('arena');

    function reportStatus(message) {
      if (typeof window !== 'undefined' && window.parent && typeof window.parent.postMessage === 'function') {
        window.parent.postMessage({ type: 'arena:status', payload: { message } }, '*');
      }
    }

    function notifyReady() {
      if (typeof window !== 'undefined' && window.parent && typeof window.parent.postMessage === 'function') {
        window.parent.postMessage({ type: 'arena:ready' }, '*');
      }
      reportStatus('Arena ready. Select a preset or tweak values to begin.');
    }

    function syncMeshVisibility(modeValue) {
      if (meshB) {
        meshB.visible = modeValue === 'compare';
      }
    }

    function applyConfig(config) {
      if (!config || typeof config !== 'object') {
        return;
      }

      const modeSelect = document.getElementById(MODE_ID);
      const compASelect = document.getElementById(COMP_TYPE_A_ID);
      const compBSelect = document.getElementById(COMP_TYPE_B_ID);
      const valueAInput = document.getElementById(VALUE_A_ID);
      const valueBInput = document.getElementById(VALUE_B_ID);
      const voltageInput = document.getElementById(VOLTAGE_ID);
      const frequencyInput = document.getElementById(FREQUENCY_ID);

      if (modeSelect && config.mode) {
        modeSelect.value = config.mode;
        modeSelect.dispatchEvent(new Event('change', { bubbles: true }));
      }

      if (compASelect && config.compA) {
        compASelect.value = config.compA;
      }

      if (compBSelect && config.compB) {
        compBSelect.value = config.compB;
      }

      if (valueAInput && typeof config.valueA === 'number' && !Number.isNaN(config.valueA)) {
        valueAInput.value = String(config.valueA);
      }

      if (valueBInput && typeof config.valueB === 'number' && !Number.isNaN(config.valueB)) {
        valueBInput.value = String(config.valueB);
      }

      if (voltageInput && typeof config.voltage === 'number' && !Number.isNaN(config.voltage)) {
        voltageInput.value = String(config.voltage);
      }

      if (frequencyInput && typeof config.frequency === 'number' && !Number.isNaN(config.frequency)) {
        frequencyInput.value = String(config.frequency);
      }

      const currentMode = (modeSelect && modeSelect.value) || 'single';
      syncMeshVisibility(currentMode);

      const stat = document.getElementById(STAT_ID);
      if (stat) {
        stat.textContent = 'Preset loaded. Tap Run Test to evaluate.';
      }

      reportStatus('Preset staged inside the arena.');
    }

    function init() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x0a0a1a);
      camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 2, 6);
      renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);

      const light = new THREE.DirectionalLight(0xffffff, 1.2);
      light.position.set(2, 4, 2);
      scene.add(light);
      scene.add(new THREE.AmbientLight(0x404040, 0.6));

      const geo = new THREE.BoxGeometry(1, 1, 1);
      meshA = new THREE.Mesh(geo, new THREE.MeshStandardMaterial({ color: 0x88ccff }));
      meshB = new THREE.Mesh(geo, new THREE.MeshStandardMaterial({ color: 0xffa500 }));
      meshA.position.set(-1.2, 0, 0);
      meshB.position.set(1.2, 0, 0);
      scene.add(meshA);
      scene.add(meshB);

      const modeSelect = document.getElementById(MODE_ID);
      syncMeshVisibility((modeSelect && modeSelect.value) || 'single');

      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      animate();
    }

    function animate() {
      requestAnimationFrame(animate);
      if (meshA) {
        meshA.rotation.y += 0.01;
      }
      if (meshB && meshB.visible) {
        meshB.rotation.y -= 0.01;
      }
      renderer.render(scene, camera);
    }

    function resetArena() {
      const stat = document.getElementById(STAT_ID);
      if (stat) {
        stat.textContent = 'Reset arena';
      }
      if (meshA) {
        meshA.rotation.set(0, 0, 0);
      }
      if (meshB) {
        meshB.rotation.set(0, 0, 0);
      }
      reportStatus('Arena reset to defaults.');
    }

    function runTest() {
      const modeEl = document.getElementById(MODE_ID);
      const typeAEl = document.getElementById(COMP_TYPE_A_ID);
      const valueAEl = document.getElementById(VALUE_A_ID);
      const typeBEl = document.getElementById(COMP_TYPE_B_ID);
      const valueBEl = document.getElementById(VALUE_B_ID);
      const voltageEl = document.getElementById(VOLTAGE_ID);
      const frequencyEl = document.getElementById(FREQUENCY_ID);

      const mode = modeEl ? modeEl.value : 'single';
      const typeA = typeAEl ? typeAEl.value : 'resistor';
      const valueA = parseFloat((valueAEl && valueAEl.value) || '0');
      const typeB = typeBEl ? typeBEl.value : typeA;
      const rawValueB = (valueBEl && valueBEl.value) || String(valueA);
      const valueB = parseFloat(rawValueB);
      const V = parseFloat((voltageEl && voltageEl.value) || '0');
      const f = parseFloat((frequencyEl && frequencyEl.value) || '0');

      function calc(type, value) {
        if (type === 'resistor') {
          const I = V / (value || 1);
          const P = V * I;
          return { I: Number.isFinite(I) ? Number(I.toFixed(3)) : 0, P: Number.isFinite(P) ? Number(P.toFixed(3)) : 0 };
        }
        if (type === 'capacitor') {
          const X = 1 / (2 * Math.PI * f * (value || 1e-6));
          const I = V / X;
          return { X: Number.isFinite(X) ? Number(X.toFixed(3)) : 0, I: Number.isFinite(I) ? Number(I.toFixed(3)) : 0 };
        }
        if (type === 'inductor') {
          const X = 2 * Math.PI * f * (value || 1e-3);
          const I = V / X;
          return { X: Number.isFinite(X) ? Number(X.toFixed(3)) : 0, I: Number.isFinite(I) ? Number(I.toFixed(3)) : 0 };
        }
        if (type === 'led') {
          const Vf = 2.0;
          const I = Math.max(0, V - Vf) / (value || 100);
          return { Vf, I: Number.isFinite(I) ? Number(I.toFixed(3)) : 0 };
        }
        return {};
      }

      const stat = document.getElementById(STAT_ID);

      if (mode === 'compare') {
        const A = calc(typeA, valueA);
        const B = calc(typeB, Number.isFinite(valueB) ? valueB : valueA);
        if (stat) {
          stat.textContent = 'A: ' + JSON.stringify(A) + ' | B: ' + JSON.stringify(B);
        }
        reportStatus('Compare test complete. Check the HUD for delta insights.');
      } else {
        const A = calc(typeA, valueA);
        if (stat) {
          stat.textContent = 'A: ' + JSON.stringify(A);
        }
        reportStatus('Single test complete. Metrics refreshed.');
      }
    }

    function exportResults() {
      const statText = document.getElementById(STAT_ID)?.textContent || 'Arena export (no data)';
      const blob = new Blob([statText], { type: 'text/plain' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'arena-results.txt';
      a.click();
      reportStatus('Exported the latest arena snapshot.');
    }

    document.getElementById(MODE_ID).addEventListener('change', (event) => {
      const select = event.target;
      const compare = select.value === 'compare';
      document.querySelectorAll('.compare-only').forEach((element) => {
        element.style.display = compare ? '' : 'none';
      });
      syncMeshVisibility(select.value);
    });

    window.addEventListener('message', (event) => {
      const { data } = event;
      if (!data || typeof data !== 'object') {
        return;
      }

      const { type, payload } = data;

      switch (type) {
        case 'arena:configure':
          applyConfig(payload);
          break;
        case 'arena:reset':
          resetArena();
          break;
        case 'arena:run-test':
          runTest();
          break;
        case 'arena:export':
          exportResults();
          break;
        default:
          break;
      }
    });

    init();
    notifyReady();
  </script>
</body>
</html>
