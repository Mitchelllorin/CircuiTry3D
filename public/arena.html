<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>CircuiTry3D - Component Arena</title>
  <style>
    html, body { margin: 0; height: 100%; background: #0a0a1a; color: #fff; font-family: system-ui, sans-serif; }
    .hud { position: fixed; top: 12px; left: 12px; right: 12px; display: flex; gap: 8px; flex-wrap: wrap; z-index: 2; }
    .btn { padding: 10px 14px; border-radius: 10px; border: 1px solid #334155; background: #111827; color: #e5e7eb; font-weight: 700; cursor: pointer; }
    .panel { position: fixed; top: 60px; left: 12px; width: 320px; max-width: calc(100% - 24px); background: rgba(0,0,0,0.65); backdrop-filter: blur(10px); border: 1px solid #334155; border-radius: 12px; padding: 12px; z-index: 2; }
    .row { display: flex; gap: 8px; align-items: center; margin-bottom: 8px; }
    .row label { width: 120px; font-size: 12px; color: #94a3b8; }
    .row input, .row select { flex: 1; padding: 8px; border-radius: 8px; border: 1px solid #334155; background: #0b1220; color: #e5e7eb; }
    .stat { font-size: 12px; color: #a5b4fc; margin-top: 8px; }
  </style>
</head>
<body>
  <div class="hud">
    <button class="btn" onclick="resetArena()">Reset</button>
    <button class="btn" onclick="runTest()">Run Test</button>
    <button class="btn" onclick="exportResults()">Export</button>
  </div>
  <div class="panel">
    <div class="row"><label>Mode</label>
      <select id="mode">
        <option value="single">Single</option>
        <option value="compare">Compare (A vs B)</option>
      </select>
    </div>
    <hr style="border:none;border-top:1px solid #334155;margin:8px 0" />
    <div class="row"><label>Comp A</label>
      <select id="comp-type-a">
        <option value="resistor">Resistor</option>
        <option value="capacitor">Capacitor</option>
        <option value="inductor">Inductor</option>
        <option value="led">LED</option>
      </select>
    </div>
    <div class="row"><label>Value A</label><input id="comp-value-a" type="number" value="100" /></div>
    <div class="row compare-only" style="display:none"><label>Comp B</label>
      <select id="comp-type-b">
        <option value="resistor">Resistor</option>
        <option value="capacitor">Capacitor</option>
        <option value="inductor">Inductor</option>
        <option value="led">LED</option>
      </select>
    </div>
    <div class="row compare-only" style="display:none"><label>Value B</label><input id="comp-value-b" type="number" value="200" /></div>
    <hr style="border:none;border-top:1px solid #334155;margin:8px 0" />
    <div class="row"><label>Voltage (V)</label><input id="test-voltage" type="number" value="5" /></div>
    <div class="row"><label>Frequency (Hz)</label><input id="test-frequency" type="number" value="1000" /></div>
    <div class="stat" id="stat-out">Ready.</div>
  </div>
  <canvas id="arena"></canvas>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    const MODE_ID = 'mode';
    const COMP_TYPE_A_ID = 'comp-type-a';
    const COMP_TYPE_B_ID = 'comp-type-b';
    const VALUE_A_ID = 'comp-value-a';
    const VALUE_B_ID = 'comp-value-b';
    const VOLTAGE_ID = 'test-voltage';
    const FREQUENCY_ID = 'test-frequency';
    const STAT_ID = 'stat-out';

    let scene, camera, renderer, meshA, meshB;
    const canvas = document.getElementById('arena');
    let manufacturerRoster = [];
    const activeComponentIds = { a: null, b: null };
    const manufacturerNames = { a: null, b: null };

    const ALLOWED_TYPES = ['resistor', 'capacitor', 'inductor', 'led'];

    function ingestManufacturerRoster(components) {
      if (!Array.isArray(components) || !components.length) {
        manufacturerRoster = [];
        return;
      }

      manufacturerRoster = components
        .map((component) => {
          if (!component || typeof component !== 'object') {
            return null;
          }

          const id = typeof component.id === 'string' ? component.id : String(component.id ?? '');
          const type = typeof component.type === 'string' && ALLOWED_TYPES.includes(component.type) ? component.type : undefined;

          if (!id || !type) {
            return null;
          }

          const manufacturer = typeof component.manufacturer === 'string' ? component.manufacturer : 'Manufacturer';
          const name = typeof component.name === 'string' ? component.name : 'Component';
          const family = typeof component.family === 'string' ? component.family : '';
          const highlight = typeof component.highlight === 'string' ? component.highlight : '';
          const rating = typeof component.rating === 'number' ? component.rating : null;

          const metrics = Array.isArray(component.metrics)
            ? component.metrics.slice(0, 3).map((metric) => {
                if (!metric || typeof metric !== 'object') {
                  return null;
                }
                const label = typeof metric.label === 'string' ? metric.label : 'Metric';
                const value = typeof metric.value === 'string' ? metric.value : String(metric.value ?? '');
                const unit = typeof metric.unit === 'string' ? metric.unit : undefined;
                return { label, value, unit };
              }).filter(Boolean)
            : [];

          return { id, type, manufacturer, name, family, highlight, rating, metrics };
        })
        .filter(Boolean);
    }

    function lookupComponent(componentId, fallbackType) {
      if (!manufacturerRoster.length) {
        return undefined;
      }

      if (componentId) {
        const matchById = manufacturerRoster.find((component) => component.id === componentId);
        if (matchById) {
          return matchById;
        }
      }

      if (fallbackType) {
        return manufacturerRoster.find((component) => component.type === fallbackType);
      }

      return undefined;
    }

    function formatDescriptor(component, fallbackType, fallbackManufacturer) {
      if (component) {
        return `${component.manufacturer} - ${component.name}`;
      }
      if (fallbackManufacturer && fallbackType) {
        return `${fallbackManufacturer} - ${fallbackType}`;
      }
      if (fallbackType) {
        return fallbackType;
      }
      return 'Component';
    }

    function reportStatus(message) {
      if (typeof window !== 'undefined' && window.parent && typeof window.parent.postMessage === 'function') {
        window.parent.postMessage({ type: 'arena:status', payload: { message } }, '*');
      }
    }

    function notifyReady() {
      if (typeof window !== 'undefined' && window.parent && typeof window.parent.postMessage === 'function') {
        window.parent.postMessage({ type: 'arena:ready' }, '*');
      }
      reportStatus('Arena ready. Select a preset or tweak values to begin.');
    }

    function syncMeshVisibility(modeValue) {
      if (meshB) {
        meshB.visible = modeValue === 'compare';
      }
    }

    function applyConfig(config) {
      if (!config || typeof config !== 'object') {
        return;
      }

      const modeSelect = document.getElementById(MODE_ID);
      const compASelect = document.getElementById(COMP_TYPE_A_ID);
      const compBSelect = document.getElementById(COMP_TYPE_B_ID);
      const valueAInput = document.getElementById(VALUE_A_ID);
      const valueBInput = document.getElementById(VALUE_B_ID);
      const voltageInput = document.getElementById(VOLTAGE_ID);
      const frequencyInput = document.getElementById(FREQUENCY_ID);

      activeComponentIds.a = typeof config.componentIdA === 'string' ? config.componentIdA : null;
      activeComponentIds.b = typeof config.componentIdB === 'string' ? config.componentIdB : null;
      manufacturerNames.a = typeof config.manufacturerNameA === 'string' ? config.manufacturerNameA : null;
      manufacturerNames.b = typeof config.manufacturerNameB === 'string' ? config.manufacturerNameB : null;

      if (modeSelect && config.mode) {
        modeSelect.value = config.mode;
        modeSelect.dispatchEvent(new Event('change', { bubbles: true }));
      }

      if (compASelect && config.compA) {
        compASelect.value = config.compA;
      }

      if (compBSelect && config.compB) {
        compBSelect.value = config.compB;
      }

      if (valueAInput && typeof config.valueA === 'number' && !Number.isNaN(config.valueA)) {
        valueAInput.value = String(config.valueA);
      }

      if (valueBInput && typeof config.valueB === 'number' && !Number.isNaN(config.valueB)) {
        valueBInput.value = String(config.valueB);
      }

      if (voltageInput && typeof config.voltage === 'number' && !Number.isNaN(config.voltage)) {
        voltageInput.value = String(config.voltage);
      }

      if (frequencyInput && typeof config.frequency === 'number' && !Number.isNaN(config.frequency)) {
        frequencyInput.value = String(config.frequency);
      }

      const currentMode = (modeSelect && modeSelect.value) || 'single';
      syncMeshVisibility(currentMode);

      const stat = document.getElementById(STAT_ID);
      const descriptorA = lookupComponent(activeComponentIds.a, compASelect ? compASelect.value : config.compA);
      const descriptorB = currentMode === 'compare'
        ? lookupComponent(activeComponentIds.b, compBSelect ? compBSelect.value : config.compB)
        : undefined;
      const descriptorLabelA = formatDescriptor(descriptorA, config.compA, manufacturerNames.a);
      const descriptorLabelB = currentMode === 'compare'
        ? formatDescriptor(descriptorB, config.compB, manufacturerNames.b)
        : null;

      if (stat) {
        if (currentMode === 'compare' && descriptorLabelB) {
          stat.textContent = `Preset staged: ${descriptorLabelA} vs ${descriptorLabelB}`;
        } else {
          stat.textContent = `Preset staged: ${descriptorLabelA}`;
        }
      }
      if (currentMode === 'compare' && descriptorLabelB) {
        reportStatus(`Preset staged inside the arena: ${descriptorLabelA} vs ${descriptorLabelB}.`);
      } else {
        reportStatus(`Preset staged inside the arena: ${descriptorLabelA}.`);
      }
    }

    function init() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x0a0a1a);
      camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 2, 6);
      renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);

      const light = new THREE.DirectionalLight(0xffffff, 1.2);
      light.position.set(2, 4, 2);
      scene.add(light);
      scene.add(new THREE.AmbientLight(0x404040, 0.6));

      const geo = new THREE.BoxGeometry(1, 1, 1);
      meshA = new THREE.Mesh(geo, new THREE.MeshStandardMaterial({ color: 0x88ccff }));
      meshB = new THREE.Mesh(geo, new THREE.MeshStandardMaterial({ color: 0xffa500 }));
      meshA.position.set(-1.2, 0, 0);
      meshB.position.set(1.2, 0, 0);
      scene.add(meshA);
      scene.add(meshB);

      const modeSelect = document.getElementById(MODE_ID);
      syncMeshVisibility((modeSelect && modeSelect.value) || 'single');

      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      animate();
    }

    function animate() {
      requestAnimationFrame(animate);
      if (meshA) {
        meshA.rotation.y += 0.01;
      }
      if (meshB && meshB.visible) {
        meshB.rotation.y -= 0.01;
      }
      renderer.render(scene, camera);
    }

    function resetArena() {
      const stat = document.getElementById(STAT_ID);
      if (stat) {
        stat.textContent = 'Reset arena';
      }
      if (meshA) {
        meshA.rotation.set(0, 0, 0);
      }
      if (meshB) {
        meshB.rotation.set(0, 0, 0);
      }
      const benchCount = manufacturerRoster.length;
      reportStatus(`Arena reset to defaults. Bench holds ${benchCount} manufacturer component${benchCount === 1 ? '' : 's'}.`);
    }

    function runTest() {
      const modeEl = document.getElementById(MODE_ID);
      const typeAEl = document.getElementById(COMP_TYPE_A_ID);
      const valueAEl = document.getElementById(VALUE_A_ID);
      const typeBEl = document.getElementById(COMP_TYPE_B_ID);
      const valueBEl = document.getElementById(VALUE_B_ID);
      const voltageEl = document.getElementById(VOLTAGE_ID);
      const frequencyEl = document.getElementById(FREQUENCY_ID);

      const mode = modeEl ? modeEl.value : 'single';
      const typeA = typeAEl ? typeAEl.value : 'resistor';
      const valueA = parseFloat((valueAEl && valueAEl.value) || '0');
      const typeB = typeBEl ? typeBEl.value : typeA;
      const rawValueB = (valueBEl && valueBEl.value) || String(valueA);
      const valueB = parseFloat(rawValueB);
      const V = parseFloat((voltageEl && voltageEl.value) || '0');
      const f = parseFloat((frequencyEl && frequencyEl.value) || '0');

      const descriptorA = lookupComponent(activeComponentIds.a, typeA);
      const descriptorB = lookupComponent(activeComponentIds.b, typeB);
      const descriptorLabelA = formatDescriptor(descriptorA, typeA, manufacturerNames.a);
      const descriptorLabelB = formatDescriptor(descriptorB, typeB, manufacturerNames.b);

      function calc(type, value) {
        if (type === 'resistor') {
          const I = V / (value || 1);
          const P = V * I;
          return { I: Number.isFinite(I) ? Number(I.toFixed(3)) : 0, P: Number.isFinite(P) ? Number(P.toFixed(3)) : 0 };
        }
        if (type === 'capacitor') {
          const X = 1 / (2 * Math.PI * f * (value || 1e-6));
          const I = V / X;
          return { X: Number.isFinite(X) ? Number(X.toFixed(3)) : 0, I: Number.isFinite(I) ? Number(I.toFixed(3)) : 0 };
        }
        if (type === 'inductor') {
          const X = 2 * Math.PI * f * (value || 1e-3);
          const I = V / X;
          return { X: Number.isFinite(X) ? Number(X.toFixed(3)) : 0, I: Number.isFinite(I) ? Number(I.toFixed(3)) : 0 };
        }
        if (type === 'led') {
          const Vf = 2.0;
          const I = Math.max(0, V - Vf) / (value || 100);
          return { Vf, I: Number.isFinite(I) ? Number(I.toFixed(3)) : 0 };
        }
        return {};
      }

      const stat = document.getElementById(STAT_ID);

      if (mode === 'compare') {
        const A = calc(typeA, valueA);
        const B = calc(typeB, Number.isFinite(valueB) ? valueB : valueA);
        if (stat) {
          stat.textContent = `A (${descriptorLabelA}): ${JSON.stringify(A)} | B (${descriptorLabelB}): ${JSON.stringify(B)}`;
        }
        reportStatus(`Compare test complete: ${descriptorLabelA} vs ${descriptorLabelB}.`);
      } else {
        const A = calc(typeA, valueA);
        if (stat) {
          stat.textContent = `A (${descriptorLabelA}): ${JSON.stringify(A)}`;
        }
        reportStatus(`Single test complete: ${descriptorLabelA} metrics refreshed.`);
      }
    }

    function exportResults() {
      const statText = document.getElementById(STAT_ID)?.textContent || 'Arena export (no data)';
      const blob = new Blob([statText], { type: 'text/plain' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'arena-results.txt';
      a.click();
      reportStatus('Exported the latest arena snapshot.');
    }

    document.getElementById(MODE_ID).addEventListener('change', (event) => {
      const select = event.target;
      const compare = select.value === 'compare';
      document.querySelectorAll('.compare-only').forEach((element) => {
        element.style.display = compare ? '' : 'none';
      });
      syncMeshVisibility(select.value);
    });

    window.addEventListener('message', (event) => {
      const { data } = event;
      if (!data || typeof data !== 'object') {
        return;
      }

      const { type, payload } = data;

      switch (type) {
        case 'arena:configure':
          applyConfig(payload);
          break;
        case 'arena:reset':
          resetArena();
          break;
        case 'arena:run-test':
          runTest();
          break;
        case 'arena:export':
          exportResults();
          break;
        case 'arena:register-components': {
          const payloadObject = payload && typeof payload === 'object' ? payload : {};
          const components = Array.isArray(payloadObject.components) ? payloadObject.components : [];
          ingestManufacturerRoster(components);
          const count = manufacturerRoster.length;
          reportStatus(`Registered ${count} manufacturer component${count === 1 ? '' : 's'} for arena matchups.`);
          const stat = document.getElementById(STAT_ID);
          if (stat) {
            stat.textContent = `Arena bench updated (${count} components).`;
          }
          if (typeof window !== 'undefined' && window.parent && typeof window.parent.postMessage === 'function') {
            window.parent.postMessage({ type: 'arena:components-registered', payload: { count } }, '*');
          }
          break;
        }
        default:
          break;
      }
    });

    init();
    notifyReady();
  </script>
</body>
</html>
