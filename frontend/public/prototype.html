<!DOCTYPE html>
<html>
<head>
    <title>CircuiTry - Professional Circuit Design</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <style>
        * { 
            margin: 0; 
            padding: 0; 
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        
        body { 
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            color: white; 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            touch-action: none;
            position: fixed;
            width: 100%;
            height: 100%;
            -webkit-overflow-scrolling: touch;
        }
        
        .menu-bar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 100;
            background: rgba(0,0,0,0.95);
            backdrop-filter: blur(15px);
            border-bottom: 2px solid rgba(0,255,136,0.3);
            padding: 12px 16px;
            transition: transform 0.3s ease;
            max-height: 90vh;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
        }
        
        .menu-bar.hidden {
            transform: translateY(-100%);
        }
        
        .menu-tabs {
            display: flex;
            flex-direction: column;
            gap: 8px;
            justify-content: center;
            max-width: 100%;
            margin: 0 auto;
        }
        
        .menu-tab {
            padding: 16px 20px;
            background: linear-gradient(135deg, #333, #444);
            border: 2px solid #555;
            color: white;
            border-radius: 12px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            white-space: nowrap;
            position: relative;
            text-align: center;
            min-height: 56px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .menu-tab:hover, .menu-tab:active {
            background: linear-gradient(135deg, #444, #555);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,255,136,0.2);
        }
        
        .menu-tab.active {
            background: linear-gradient(135deg, #00ff88, #00cc66);
            color: #000;
            border-color: #00ff88;
            box-shadow: 0 0 20px rgba(0,255,136,0.4);
        }
        
        .submenu {
            background: rgba(0,0,0,0.95);
            backdrop-filter: blur(15px);
            border: 2px solid rgba(0,255,136,0.3);
            border-radius: 12px;
            padding: 16px;
            margin-top: 8px;
            display: none;
            width: 100%;
            z-index: 200;
        }
        
        .submenu.active {
            display: block;
        }
        
        .submenu-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
        }
        
        .submenu-row {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin-bottom: 12px;
        }
        
        .submenu-row:last-child {
            margin-bottom: 0;
        }
        
        .btn { 
            padding: 16px 20px; 
            background: linear-gradient(135deg, #333, #444);
            border: 2px solid #555;
            color: white; 
            border-radius: 12px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            white-space: nowrap;
            min-height: 56px;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
        }
        
        .btn:hover, .btn:active { 
            background: linear-gradient(135deg, #444, #555);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }
        
        .wire-btn.active { 
            background: linear-gradient(135deg, #00ff88, #00cc66);
            color: #000;
            border-color: #00ff88;
            box-shadow: 0 0 20px rgba(0,255,136,0.4);
        }
        
        .rotate-btn.active { 
            background: linear-gradient(135deg, #8800ff, #6600cc);
            border-color: #8800ff;
            box-shadow: 0 0 20px rgba(136,0,255,0.4);
        }
        
        .wire-analysis-fixed {
            position: fixed;
            bottom: 20px;
            left: 20px;
            right: 20px;
            background: rgba(0,0,0,0.95);
            backdrop-filter: blur(15px);
            padding: 20px;
            border-radius: 16px;
            border: 2px solid rgba(0,255,136,0.4);
            z-index: 90;
            transition: transform 0.3s ease;
            max-height: 60vh;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
        }
        
        .wire-analysis-fixed.collapsed {
            transform: translateY(calc(100% - 60px));
        }

        .analysis-tabs {
            display: flex;
            margin-bottom: 16px;
            border-radius: 8px;
            overflow: hidden;
            background: rgba(255,255,255,0.1);
            flex-wrap: wrap;
        }

        .analysis-tab {
            flex: 1;
            padding: 10px 6px;
            background: rgba(255,255,255,0.1);
            border: none;
            color: #ccc;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 60px;
            text-align: center;
        }

        .analysis-tab.active {
            background: #00ff88;
            color: #000;
        }

        .analysis-tab:hover {
            background: rgba(255,255,255,0.2);
        }

        .analysis-tab.active:hover {
            background: #00cc66;
        }

        .vir-triangle {
            text-align: center;
            margin-bottom: 20px;
            background: rgba(255,255,255,0.1);
            padding: 16px;
            border-radius: 12px;
            border: 2px solid rgba(255,255,255,0.3);
        }

        .triangle-container {
            position: relative;
            width: 160px;
            height: 140px;
            margin: 0 auto 16px;
        }

        .triangle-shape {
            width: 0;
            height: 0;
            border-left: 80px solid transparent;
            border-right: 80px solid transparent;
            border-bottom: 140px solid rgba(0,255,136,0.3);
            position: relative;
            margin: 0 auto;
        }

        .triangle-sections {
            position: absolute;
            top: 0;
            left: 0;
            width: 160px;
            height: 140px;
        }

        .triangle-v {
            position: absolute;
            top: 15px;
            left: 50%;
            transform: translateX(-50%);
            color: #ff4444;
            font-size: 20px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .triangle-i {
            position: absolute;
            bottom: 15px;
            left: 25%;
            transform: translateX(-50%);
            color: #ff8844;
            font-size: 20px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .triangle-r {
            position: absolute;
            bottom: 15px;
            right: 25%;
            transform: translateX(50%);
            color: #44ff88;
            font-size: 20px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .triangle-v:hover, .triangle-i:hover, .triangle-r:hover {
            transform: translateX(-50%) scale(1.2);
            text-shadow: 0 0 10px currentColor;
        }

        .triangle-formula {
            color: #00ff88;
            font-size: 12px;
            margin-top: 10px;
            font-weight: 600;
        }

        .worksheet-panel {
            background: rgba(255,255,255,0.05);
            border: 2px solid rgba(255,255,255,0.2);
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 16px;
        }

        .worksheet-title {
            color: #00ff88;
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 16px;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .component-list {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            gap: 8px;
            margin-bottom: 16px;
        }

        .component-item {
            background: rgba(255,255,255,0.1);
            padding: 8px;
            border-radius: 8px;
            border: 1px solid rgba(255,255,255,0.3);
            text-align: center;
        }

        .component-label {
            color: #ccc;
            font-size: 10px;
            margin-bottom: 4px;
        }

        .component-value {
            color: white;
            font-weight: bold;
            font-size: 12px;
        }

        .calculations-section {
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
            padding: 12px;
            margin-top: 16px;
        }

        .calculation-step {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 8px;
            background: rgba(255,255,255,0.05);
            border-radius: 6px;
            margin-bottom: 6px;
            border-left: 3px solid;
        }

        .step-voltage { border-left-color: #ff4444; }
        .step-current { border-left-color: #ff8844; }
        .step-resistance { border-left-color: #44ff88; }
        .step-power { border-left-color: #4488ff; }

        .step-label {
            color: #ccc;
            font-size: 12px;
            font-weight: 600;
        }

        .step-formula {
            color: #888;
            font-size: 10px;
            font-family: monospace;
        }

        .step-value {
            color: white;
            font-weight: bold;
            font-size: 14px;
        }

        .problem-mode {
            background: rgba(255,165,0,0.1);
            border: 2px solid rgba(255,165,0,0.3);
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 16px;
        }

        .problem-title {
            color: #ffaa00;
            font-weight: bold;
            margin-bottom: 12px;
            text-align: center;
            font-size: 16px;
        }

        .unknown-input {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }

        .unknown-input label {
            font-size: 12px;
            width: 100px;
        }

        .unknown-input input {
            width: 70px;
            padding: 6px;
            border: 2px solid #555;
            border-radius: 6px;
            background: rgba(255,255,255,0.1);
            color: white;
            text-align: center;
            font-weight: bold;
            font-size: 12px;
        }

        .unknown-input input:focus {
            outline: none;
            border-color: #00ff88;
        }

        .check-answer-btn {
            background: linear-gradient(135deg, #00ff88, #00cc66);
            color: #000;
            border: none;
            padding: 8px 16px;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 12px;
            width: 100%;
        }

        .check-answer-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0,255,136,0.3);
        }

        .result-feedback {
            padding: 8px;
            border-radius: 8px;
            margin-top: 8px;
            font-weight: bold;
            text-align: center;
            font-size: 12px;
        }

        .feedback-correct {
            background: rgba(0,255,0,0.2);
            border: 2px solid #00ff00;
            color: #00ff88;
        }

        .feedback-incorrect {
            background: rgba(255,0,0,0.2);
            border: 2px solid #ff0000;
            color: #ff6666;
        }

        .circuit-diagram {
            background: rgba(255,255,255,0.05);
            border: 2px solid rgba(255,255,255,0.2);
            border-radius: 12px;
            padding: 12px;
            margin-bottom: 16px;
            min-height: 120px;
            position: relative;
        }

        .diagram-title {
            color: #00ff88;
            font-size: 14px;
            font-weight: bold;
            margin-bottom: 8px;
            text-align: center;
        }

        .circuit-schematic {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100px;
            font-family: monospace;
            color: #ccc;
            line-height: 1.2;
            font-size: 11px;
        }

        .schematic-line {
            margin: 1px 0;
            white-space: pre;
        }

        .practice-problem-card {
            background: rgba(0,150,255,0.1);
            border: 2px solid rgba(0,150,255,0.3);
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 16px;
        }

        .problem-question {
            color: #4da6ff;
            font-weight: bold;
            font-size: 16px;
            margin-bottom: 12px;
            text-align: center;
        }

        .problem-description {
            color: #ccc;
            margin-bottom: 12px;
            text-align: center;
            font-size: 14px;
        }

        .circuit-status {
            background: rgba(255,255,255,0.1);
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 12px;
            text-align: center;
        }

        .status-complete {
            border: 2px solid #00ff88;
            color: #00ff88;
        }

        .status-incomplete {
            border: 2px solid #ffaa00;
            color: #ffaa00;
        }

        .wire-instructions {
            background: rgba(255,200,0,0.1);
            border: 1px solid rgba(255,200,0,0.3);
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 12px;
            color: #ffcc66;
            font-size: 12px;
            text-align: center;
        }

        .practice-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-bottom: 16px;
        }

        .practice-btn {
            padding: 12px 8px;
            background: linear-gradient(135deg, #333, #444);
            border: 2px solid #555;
            color: white;
            border-radius: 8px;
            font-size: 11px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
        }

        .practice-btn:hover {
            background: linear-gradient(135deg, #444, #555);
            transform: translateY(-1px);
        }

        .practice-btn.active {
            background: linear-gradient(135deg, #00ff88, #00cc66);
            color: #000;
            border-color: #00ff88;
        }
        
        .analysis-toggle {
            position: absolute;
            left: 50%;
            top: -30px;
            transform: translateX(-50%);
            background: #00ff88;
            border: 3px solid #ffffff;
            color: #000000;
            border-radius: 50%;
            width: 60px;
            height: 60px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 18px;
            box-shadow: 0 4px 12px rgba(0,255,136,0.3);
        }
        
        .menu-toggle {
            position: fixed;
            top: 20px;
            left: 20px;
            background: #00ff88;
            border: 3px solid #ffffff;
            color: #000000;
            border-radius: 50%;
            width: 64px;
            height: 64px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 300;
            font-weight: bold;
            font-size: 20px;
            box-shadow: 0 4px 12px rgba(0,255,136,0.3);
        }
        
        .status {
            position: fixed;
            bottom: 300px;
            left: 20px;
            right: 20px;
            background: rgba(0,255,136,0.1);
            backdrop-filter: blur(10px);
            padding: 16px 20px;
            border-radius: 16px;
            border: 1px solid rgba(0,255,136,0.3);
            z-index: 100;
            color: #00ff88;
            font-weight: 600;
            text-align: center;
            font-size: 16px;
            line-height: 1.4;
        }
        
        .edit-popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.95);
            backdrop-filter: blur(15px);
            border: 2px solid #00ff88;
            border-radius: 16px;
            padding: 24px;
            z-index: 1000;
            display: none;
            width: 90%;
            max-width: 400px;
            max-height: 80vh;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            box-shadow: 0 10px 30px rgba(0,255,136,0.3);
        }
        
        .edit-popup h3 {
            color: #00ff88;
            margin: 0 0 20px 0;
            text-align: center;
            font-size: 20px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .edit-row {
            margin-bottom: 20px;
        }
        
        .edit-row label {
            display: block;
            color: #ccc;
            margin-bottom: 8px;
            font-size: 16px;
            font-weight: 600;
        }
        
        .edit-row input, .edit-row select {
            width: 100%;
            padding: 16px;
            border: 2px solid #555;
            border-radius: 12px;
            background: rgba(255,255,255,0.1);
            color: white;
            font-size: 16px;
            transition: border-color 0.3s ease;
            min-height: 56px;
        }
        
        .edit-row input:focus, .edit-row select:focus {
            outline: none;
            border-color: #00ff88;
            box-shadow: 0 0 10px rgba(0,255,136,0.2);
        }
        
        .edit-buttons {
            display: flex;
            gap: 16px;
            margin-top: 24px;
        }
        
        .edit-btn {
            flex: 1;
            padding: 16px;
            border: none;
            border-radius: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 16px;
            min-height: 56px;
        }
        
        .edit-btn.save {
            background: linear-gradient(135deg, #00ff88, #00cc66);
            color: #000;
        }
        
        .e<!DOCTYPE html>
<html>
<head>
    <title>CircuiTry - Professional Circuit Design</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <style>
        * { 
            margin: 0; 
            padding: 0; 
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        
        body { 
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            color: white; 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            touch-action: none;
            position: fixed;
            width: 100%;
            height: 100%;
            -webkit-overflow-scrolling: touch;
        }
        
        .menu-bar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 100;
            background: rgba(0,0,0,0.95);
            backdrop-filter: blur(15px);
            border-bottom: 2px solid rgba(0,255,136,0.3);
            padding: 12px 16px;
            transition: transform 0.3s ease;
            max-height: 90vh;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
        }
        
        .menu-bar.hidden {
            transform: translateY(-100%);
        }
        
        .menu-tabs {
            display: flex;
            flex-direction: column;
            gap: 8px;
            justify-content: center;
            max-width: 100%;
            margin: 0 auto;
        }
        
        .menu-tab {
            padding: 16px 20px;
            background: linear-gradient(135deg, #333, #444);
            border: 2px solid #555;
            color: white;
            border-radius: 12px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            white-space: nowrap;
            position: relative;
            text-align: center;
            min-height: 56px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .menu-tab:hover, .menu-tab:active {
            background: linear-gradient(135deg, #444, #555);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,255,136,0.2);
        }
        
        .menu-tab.active {
            background: linear-gradient(135deg, #00ff88, #00cc66);
            color: #000;
            border-color: #00ff88;
            box-shadow: 0 0 20px rgba(0,255,136,0.4);
        }
        
        .submenu {
            background: rgba(0,0,0,0.95);
            backdrop-filter: blur(15px);
            border: 2px solid rgba(0,255,136,0.3);
            border-radius: 12px;
            padding: 16px;
            margin-top: 8px;
            display: none;
            width: 100%;
            z-index: 200;
        }
        
        .submenu.active {
            display: block;
        }
        
        .submenu-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
        }
        
        .submenu-row {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin-bottom: 12px;
        }
        
        .submenu-row:last-child {
            margin-bottom: 0;
        }
        
        .btn { 
            padding: 16px 20px; 
            background: linear-gradient(135deg, #333, #444);
            border: 2px solid #555;
            color: white; 
            border-radius: 12px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            white-space: nowrap;
            min-height: 56px;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
        }
        
        .btn:hover, .btn:active { 
            background: linear-gradient(135deg, #444, #555);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }
        
        .wire-btn.active { 
            background: linear-gradient(135deg, #00ff88, #00cc66);
            color: #000;
            border-color: #00ff88;
            box-shadow: 0 0 20px rgba(0,255,136,0.4);
        }
        
        .rotate-btn.active { 
            background: linear-gradient(135deg, #8800ff, #6600cc);
            border-color: #8800ff;
            box-shadow: 0 0 20px rgba(136,0,255,0.4);
        }
        
        .wire-analysis-fixed {
            position: fixed;
            bottom: 20px;
            left: 20px;
            right: 20px;
            background: rgba(0,0,0,0.95);
            backdrop-filter: blur(15px);
            padding: 20px;
            border-radius: 16px;
            border: 2px solid rgba(0,255,136,0.4);
            z-index: 90;
            transition: transform 0.3s ease;
            max-height: 60vh;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
        }
        
        .wire-analysis-fixed.collapsed {
            transform: translateY(calc(100% - 60px));
        }

        .analysis-tabs {
            display: flex;
            margin-bottom: 16px;
            border-radius: 8px;
            overflow: hidden;
            background: rgba(255,255,255,0.1);
            flex-wrap: wrap;
        }

        .analysis-tab {
            flex: 1;
            padding: 10px 6px;
            background: rgba(255,255,255,0.1);
            border: none;
            color: #ccc;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 60px;
            text-align: center;
        }

        .analysis-tab.active {
            background: #00ff88;
            color: #000;
        }

        .analysis-tab:hover {
            background: rgba(255,255,255,0.2);
        }

        .analysis-tab.active:hover {
            background: #00cc66;
        }

        .vir-triangle {
            text-align: center;
            margin-bottom: 20px;
            background: rgba(255,255,255,0.1);
            padding: 16px;
            border-radius: 12px;
            border: 2px solid rgba(255,255,255,0.3);
        }

        .triangle-container {
            position: relative;
            width: 160px;
            height: 140px;
            margin: 0 auto 16px;
        }

        .triangle-shape {
            width: 0;
            height: 0;
            border-left: 80px solid transparent;
            border-right: 80px solid transparent;
            border-bottom: 140px solid rgba(0,255,136,0.3);
            position: relative;
            margin: 0 auto;
        }

        .triangle-sections {
            position: absolute;
            top: 0;
            left: 0;
            width: 160px;
            height: 140px;
        }

        .triangle-v {
            position: absolute;
            top: 15px;
            left: 50%;
            transform: translateX(-50%);
            color: #ff4444;
            font-size: 20px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .triangle-i {
            position: absolute;
            bottom: 15px;
            left: 25%;
            transform: translateX(-50%);
            color: #ff8844;
            font-size: 20px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .triangle-r {
            position: absolute;
            bottom: 15px;
            right: 25%;
            transform: translateX(50%);
            color: #44ff88;
            font-size: 20px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .triangle-v:hover, .triangle-i:hover, .triangle-r:hover {
            transform: translateX(-50%) scale(1.2);
            text-shadow: 0 0 10px currentColor;
        }

        .triangle-formula {
            color: #00ff88;
            font-size: 12px;
            margin-top: 10px;
            font-weight: 600;
        }

        .worksheet-panel {
            background: rgba(255,255,255,0.05);
            border: 2px solid rgba(255,255,255,0.2);
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 16px;
        }

        .worksheet-title {
            color: #00ff88;
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 16px;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .component-list {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            gap: 8px;
            margin-bottom: 16px;
        }

        .component-item {
            background: rgba(255,255,255,0.1);
            padding: 8px;
            border-radius: 8px;
            border: 1px solid rgba(255,255,255,0.3);
            text-align: center;
        }

        .component-label {
            color: #ccc;
            font-size: 10px;
            margin-bottom: 4px;
        }

        .component-value {
            color: white;
            font-weight: bold;
            font-size: 12px;
        }

        .calculations-section {
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
            padding: 12px;
            margin-top: 16px;
        }

        .calculation-step {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 8px;
            background: rgba(255,255,255,0.05);
            border-radius: 6px;
            margin-bottom: 6px;
            border-left: 3px solid;
        }

        .step-voltage { border-left-color: #ff4444; }
        .step-current { border-left-color: #ff8844; }
        .step-resistance { border-left-color: #44ff88; }
        .step-power { border-left-color: #4488ff; }

        .step-label {
            color: #ccc;
            font-size: 12px;
            font-weight: 600;
        }

        .step-formula {
            color: #888;
            font-size: 10px;
            font-family: monospace;
        }

        .step-value {
            color: white;
            font-weight: bold;
            font-size: 14px;
        }

        .problem-mode {
            background: rgba(255,165,0,0.1);
            border: 2px solid rgba(255,165,0,0.3);
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 16px;
        }

        .problem-title {
            color: #ffaa00;
            font-weight: bold;
            margin-bottom: 12px;
            text-align: center;
            font-size: 16px;
        }

        .unknown-input {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }

        .unknown-input label {
            font-size: 12px;
            width: 100px;
        }

        .unknown-input input {
            width: 70px;
            padding: 6px;
            border: 2px solid #555;
            border-radius: 6px;
            background: rgba(255,255,255,0.1);
            color: white;
            text-align: center;
            font-weight: bold;
            font-size: 12px;
        }

        .unknown-input input:focus {
            outline: none;
            border-color: #00ff88;
        }

        .check-answer-btn {
            background: linear-gradient(135deg, #00ff88, #00cc66);
            color: #000;
            border: none;
            padding: 8px 16px;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 12px;
            width: 100%;
        }

        .check-answer-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0,255,136,0.3);
        }

        .result-feedback {
            padding: 8px;
            border-radius: 8px;
            margin-top: 8px;
            font-weight: bold;
            text-align: center;
            font-size: 12px;
        }

        .feedback-correct {
            background: rgba(0,255,0,0.2);
            border: 2px solid #00ff00;
            color: #00ff88;
        }

        .feedback-incorrect {
            background: rgba(255,0,0,0.2);
            border: 2px solid #ff0000;
            color: #ff6666;
        }

        .circuit-diagram {
            background: rgba(255,255,255,0.05);
            border: 2px solid rgba(255,255,255,0.2);
            border-radius: 12px;
            padding: 12px;
            margin-bottom: 16px;
            min-height: 120px;
            position: relative;
        }

        .diagram-title {
            color: #00ff88;
            font-size: 14px;
            font-weight: bold;
            margin-bottom: 8px;
            text-align: center;
        }

        .circuit-schematic {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100px;
            font-family: monospace;
            color: #ccc;
            line-height: 1.2;
            font-size: 11px;
        }

        .schematic-line {
            margin: 1px 0;
            white-space: pre;
        }

        .practice-problem-card {
            background: rgba(0,150,255,0.1);
            border: 2px solid rgba(0,150,255,0.3);
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 16px;
        }

        .problem-question {
            color: #4da6ff;
            font-weight: bold;
            font-size: 16px;
            margin-bottom: 12px;
            text-align: center;
        }

        .problem-description {
            color: #ccc;
            margin-bottom: 12px;
            text-align: center;
            font-size: 14px;
        }

        .circuit-status {
            background: rgba(255,255,255,0.1);
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 12px;
            text-align: center;
        }

        .status-complete {
            border: 2px solid #00ff88;
            color: #00ff88;
        }

        .status-incomplete {
            border: 2px solid #ffaa00;
            color: #ffaa00;
        }

        .wire-instructions {
            background: rgba(255,200,0,0.1);
            border: 1px solid rgba(255,200,0,0.3);
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 12px;
            color: #ffcc66;
            font-size: 12px;
            text-align: center;
        }

        .practice-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-bottom: 16px;
        }

        .practice-btn {
            padding: 12px 8px;
            background: linear-gradient(135deg, #333, #444);
            border: 2px solid #555;
            color: white;
            border-radius: 8px;
            font-size: 11px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
        }

        .practice-btn:hover {
            background: linear-gradient(135deg, #444, #555);
            transform: translateY(-1px);
        }

        .practice-btn.active {
            background: linear-gradient(135deg, #00ff88, #00cc66);
            color: #000;
            border-color: #00ff88;
        }
        
        .analysis-toggle {
            position: absolute;
            left: 50%;
            top: -30px;
            transform: translateX(-50%);
            background: #00ff88;
            border: 3px solid #ffffff;
            color: #000000;
            border-radius: 50%;
            width: 60px;
            height: 60px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 18px;
            box-shadow: 0 4px 12px rgba(0,255,136,0.3);
        }
        
        .menu-toggle {
            position: fixed;
            top: 20px;
            left: 20px;
            background: #00ff88;
            border: 3px solid #ffffff;
            color: #000000;
            border-radius: 50%;
            width: 64px;
            height: 64px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 300;
            font-weight: bold;
            font-size: 20px;
            box-shadow: 0 4px 12px rgba(0,255,136,0.3);
        }
        
        .status {
            position: fixed;
            bottom: 300px;
            left: 20px;
            right: 20px;
            background: rgba(0,255,136,0.1);
            backdrop-filter: blur(10px);
            padding: 16px 20px;
            border-radius: 16px;
            border: 1px solid rgba(0,255,136,0.3);
            z-index: 100;
            color: #00ff88;
            font-weight: 600;
            text-align: center;
            font-size: 16px;
            line-height: 1.4;
        }
        
        .edit-popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.95);
            backdrop-filter: blur(15px);
            border: 2px solid #00ff88;
            border-radius: 16px;
            padding: 24px;
            z-index: 1000;
            display: none;
            width: 90%;
            max-width: 400px;
            max-height: 80vh;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            box-shadow: 0 10px 30px rgba(0,255,136,0.3);
        }
        
        .edit-popup h3 {
            color: #00ff88;
            margin: 0 0 20px 0;
            text-align: center;
            font-size: 20px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .edit-row {
            margin-bottom: 20px;
        }
        
        .edit-row label {
            display: block;
            color: #ccc;
            margin-bottom: 8px;
            font-size: 16px;
            font-weight: 600;
        }
        
        .edit-row input, .edit-row select {
            width: 100%;
            padding: 16px;
            border: 2px solid #555;
            border-radius: 12px;
            background: rgba(255,255,255,0.1);
            color: white;
            font-size: 16px;
            transition: border-color 0.3s ease;
            min-height: 56px;
        }
        
        .edit-row input:focus, .edit-row select:focus {
            outline: none;
            border-color: #00ff88;
            box-shadow: 0 0 10px rgba(0,255,136,0.2);
        }
        
        .edit-buttons {
            display: flex;
            gap: 16px;
            margin-top: 24px;
        }
        
        .edit-btn {
            flex: 1;
            padding: 16px;
            border: none;
            border-radius: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 16px;
            min-height: 56px;
        }
        
        .edit-btn.save {
            background: linear-gradient(135deg, #00ff88, #00cc66);
            color: #000;
        }
        
        .edit-btn.cancel {
            background: linear-gradient(135deg, #ff4444, #cc3333);
            color: white;
        }
        
        .edit-btn:hover, .edit-btn:active {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }
        
        .wire-analysis {
            text-align: center;
            margin-bottom: 16px;
            background: rgba(0,255,136,0.1);
            padding: 20px;
            border-radius: 16px;
            border: 2px solid rgba(0,255,136,0.3);
        }
        
        .wire-title {
            color: #00ff88;
            font-weight: bold;
            font-size: 20px;
            margin-bottom: 16px;
            text-transform: uppercase;
            letter-spacing: 2px;
            text-shadow: 0 0 10px rgba(0,255,136,0.5);
        }
        
        .wire-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            margin-bottom: 12px;
        }
        
        .wire-item {
            background: rgba(255,255,255,0.12);
            padding: 16px 12px;
            border-radius: 12px;
            border: 2px solid;
            text-align: center;
            transition: all 0.3s ease;
            min-height: 80px;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }
        
        .wire-item:hover, .wire-item:active {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }
        
        .wire-letter {
            font-weight: bold;
            font-size: 28px;
            margin-bottom: 6px;
            text-shadow: 0 0 8px currentColor;
        }
        
        .wire-label {
            color: #ccc;
            font-size: 11px;
            text-transform: uppercase;
            margin-bottom: 6px;
            letter-spacing: 0.5px;
        }
        
        .wire-value {
            font-weight: bold;
            font-size: 18px;
            text-shadow: 0 0 6px currentColor;
        }
        
        .wire-w { border-color: #4488ff; }
        .wire-w .wire-letter { color: #4488ff; }
        .wire-w .wire-value { color: #4488ff; }
        
        .wire-i { border-color: #ff8844; }
        .wire-i .wire-letter { color: #ff8844; }
        .wire-i .wire-value { color: #ff8844; }
        
        .wire-r { border-color: #44ff88; }
        .wire-r .wire-letter { color: #44ff88; }
        .wire-r .wire-value { color: #44ff88; }
        
        .wire-e { border-color: #ff4444; }
        .wire-e .wire-letter { color: #ff4444; }
        .wire-e .wire-value { color: #ff4444; }
        
        #canvas {
            width: 100vw;
            height: 100vh;
            display: block;
            touch-action: none;
            position: fixed;
            top: 0;
            left: 0;
        }
        
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 20px;
            z-index: 1000;
            text-align: center;
            padding: 20px;
        }
        
        .component-label {
            position: absolute;
            pointer-events: none;
            color: white;
            font-weight: bold;
            font-size: 14px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            white-space: nowrap;
            z-index: 10;
            background: rgba(0,0,0,0.7);
            padding: 4px 8px;
            border-radius: 8px;
            border: 1px solid rgba(255,255,255,0.3);
        }

        /* Desktop styles for larger screens */
        @media (min-width: 769px) {
            .menu-tabs {
                flex-direction: row;
                flex-wrap: wrap;
                gap: 8px;
            }
            
            .menu-tab {
                width: auto;
                padding: 12px 16px;
                font-size: 14px;
                min-height: auto;
            }
            
            .submenu {
                position: absolute;
                top: 100%;
                left: 50%;
                transform: translateX(-50%);
                margin-top: 8px;
                width: 250px;
            }
            
            .submenu-grid {
                grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            }
            
            .submenu-row {
                flex-direction: row;
                margin-bottom: 8px;
            }
            
            .btn {
                padding: 10px 14px;
                font-size: 14px;
                min-height: auto;
            }
            
            .wire-analysis-fixed {
                top: 80px;
                right: 20px;
                left: auto;
                bottom: auto;
                max-width: 320px;
                max-height: none;
            }
            
            .wire-analysis-fixed.collapsed {
                transform: translateX(calc(100% - 60px));
            }
            
            .analysis-toggle {
                left: -40px;
                top: 50%;
                transform: translateY(-50%);
                width: 40px;
                height: 40px;
                font-size: 14px;
            }
            
            .status {
                bottom: 20px;
                left: 50%;
                right: auto;
                transform: translateX(-50%);
                max-width: 600px;
                font-size: 14px;
            }
            
            .menu-toggle {
                width: 45px;
                height: 45px;
                font-size: 16px;
            }
            
            .edit-popup {
                position: fixed;
                width: 320px;
                max-width: none;
            }
        }

        /* Additional mobile optimizations */
        @media (max-width: 480px) {
            .menu-bar {
                padding: 8px 12px;
            }
            
            .menu-tab {
                padding: 14px 16px;
                font-size: 15px;
            }
            
            .btn {
                padding: 14px 16px;
                font-size: 15px;
            }
            
            .wire-analysis-fixed {
                padding: 16px;
                left: 10px;
                right: 10px;
                bottom: 10px;
            }
            
            .status {
                bottom: 280px;
                left: 10px;
                right: 10px;
                padding: 12px 16px;
                font-size: 15px;
            }
            
            .menu-toggle {
                top: 15px;
                left: 15px;
                width: 56px;
                height: 56px;
            }
            
            .analysis-toggle {
                width: 56px;
                height: 56px;
                top: -28px;
            }
        }

        /* High DPI screens */
        @media (-webkit-min-device-pixel-ratio: 2), (min-resolution: 192dpi) {
            .component-label {
                font-size: 16px;
            }
            
            .wire-letter {
                font-size: 32px;
            }
            
            .wire-value {
                font-size: 20px;
            }
        }

        /* Landscape orientation on mobile */
        @media (orientation: landscape) and (max-height: 500px) {
            .wire-analysis-fixed {
                max-height: 30vh;
            }
            
            .menu-bar {
                max-height: 70vh;
            }
            
            .status {
                bottom: 200px;
            }
        }

        /* Reduce animations on lower-end devices */
        @media (prefers-reduced-motion: reduce) {
            * {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }
        
        /* Landing Page Styles */
        .landing-page {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f1419 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            padding: 20px;
            box-sizing: border-box;
        }
        
        .landing-logo {
            font-size: clamp(48px, 12vw, 80px);
            font-weight: 900;
            color: #00ff88;
            text-align: center;
            margin-bottom: 20px;
            letter-spacing: -2px;
            text-shadow: 0 0 30px rgba(0, 255, 136, 0.5);
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
        }
        
        .landing-subtitle {
            font-size: clamp(14px, 3vw, 18px);
            color: #8899aa;
            text-align: center;
            margin-bottom: 40px;
            letter-spacing: 3px;
            text-transform: uppercase;
            font-weight: 500;
        }
        
        .circuit-preview {
            width: min(90vw, 400px);
            height: 180px;
            background: rgba(0, 20, 40, 0.6);
            border: 3px solid #00ff88;
            border-radius: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 30px;
            position: relative;
            overflow: hidden;
            backdrop-filter: blur(10px);
        }
        
        .circuit-preview::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(0, 255, 136, 0.1), transparent);
            animation: shimmer 3s infinite;
        }
        
        @keyframes shimmer {
            0% { left: -100%; }
            100% { left: 100%; }
        }
        
        .circuit-svg {
            width: 320px;
            height: 140px;
        }
        
        .circuit-element {
            stroke: #00ff88;
            stroke-width: 2.5;
            fill: none;
        }
        
        .circuit-wire {
            stroke: #66bbff;
            stroke-width: 2;
            fill: none;
        }
        
        .circuit-text {
            fill: #ffffff;
            font-family: 'Segoe UI', sans-serif;
            font-size: 12px;
            font-weight: bold;
        }
        
        .circuit-voltage {
            fill: #ff6666;
            font-size: 11px;
        }
        
        .launch-button {
            background: linear-gradient(135deg, #00ff88 0%, #00cc66 100%);
            color: #000;
            border: none;
            padding: 18px 40px;
            border-radius: 25px;
            font-size: clamp(16px, 4vw, 20px);
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
            box-shadow: 0 8px 25px rgba(0, 255, 136, 0.3);
            margin-bottom: 30px;
        }
        
        .launch-button:hover {
            transform: translateY(-3px);
            box-shadow: 0 12px 35px rgba(0, 255, 136, 0.4);
            background: linear-gradient(135deg, #00ff88 0%, #00dd77 100%);
        }
        
        .launch-button:active {
            transform: translateY(-1px);
        }
        
        .loading-progress {
            width: min(80vw, 300px);
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            overflow: hidden;
            margin-bottom: 20px;
        }
        
        .loading-bar {
            height: 100%;
            background: linear-gradient(90deg, #00ff88, #00cc66, #00ff88);
            background-size: 200% 100%;
            animation: loading 2s ease-in-out;
            border-radius: 2px;
        }
        
        @keyframes loading {
            0% { width: 0%; }
            50% { width: 70%; }
            100% { width: 100%; }
        }
        
        .loading-text {
            color: #00ff88;
            font-size: clamp(14px, 3.5vw, 16px);
            font-weight: 600;
            text-align: center;
            margin-bottom: 15px;
        }
        
        .version-text {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            color: #666;
            font-size: 12px;
        }
        
        .landing-hidden {
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s ease;
        }
        
        /* Improved circuit centering and alignment */
        .circuit-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            padding: 20px;
        }
        
        /* Professional schematic styling */
        .schematic-mode .component-label {
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.5);
            padding: 6px 10px;
            border-radius: 6px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 12px;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <!-- Landing Page -->
    <div id="landing-page" class="landing-page">
        <div class="landing-logo">CircuiTry</div>
        <div class="landing-subtitle">Professional Circuit Design</div>
        
        <div class="circuit-preview">
            <svg class="circuit-svg" viewBox="0 0 320 140">
                <!-- Main circuit outline -->
                <path class="circuit-wire" d="M 60 70 L 100 70 L 100 40 L 160 40 L 160 70 L 200 70 L 200 100 L 160 100 L 160 70" />
                <path class="circuit-wire" d="M 160 70 L 160 100 L 100 100 L 100 70" />
                
                <!-- Battery -->
                <rect class="circuit-element" x="50" y="60" width="20" height="20" />
                <text class="circuit-voltage" x="45" y="55">12V</text>
                
                <!-- Resistor R1 -->
                <rect class="circuit-element" x="150" y="30" width="20" height="20" />
                <path class="circuit-element" d="M 155 35 L 165 45 L 155 45 L 165 35" />
                <text class="circuit-text" x="158" y="28">R1</text>
                
                <!-- Resistor R2 -->
                <rect class="circuit-element" x="190" y="60" width="20" height="20" />
                <path class="circuit-element" d="M 195 65 L 205 75 L 195 75 L 205 65" />
                <text class="circuit-text" x="198" y="58">R2</text>
                
                <!-- Resistor R3 -->
                <rect class="circuit-element" x="150" y="90" width="20" height="20" />
                <path class="circuit-element" d="M 155 95 L 165 105 L 155 105 L 165 95" />
                <text class="circuit-text" x="158" y="118">R3</text>
                
                <!-- Connection dots -->
                <circle class="circuit-element" cx="160" cy="70" r="2" fill="#00ff88" />
                <circle class="circuit-element" cx="100" cy="70" r="2" fill="#00ff88" />
            </svg>
        </div>
        
        <button class="launch-button" id="launch-btn" onclick="launchApplication()">
            Launch CircuiTry
        </button>
        
        <div class="loading-progress" id="loading-progress" style="display: none;">
            <div class="loading-bar"></div>
        </div>
        
        <div class="loading-text" id="loading-text" style="display: none;">
             CircuiTry Environment Ready!
        </div>
        
        <div class="version-text">Professional Edition v2.0</div>
    </div>

    <div id="loading" class="loading" style="display: none;">Loading CircuiTry...</div>
    
    <button class="menu-toggle" id="menu-toggle" onclick="toggleMenuBar()"></button>
    
    <div class="menu-bar" id="menu-bar" style="display: none;">
        <div class="menu-tabs">
            <div class="menu-tab" onclick="toggleSubmenu('components')">
                 Components
                <div class="submenu" id="submenu-components">
                    <div class="submenu-grid">
                        <button class="btn" onclick="addComponent('battery')"> Battery</button>
                        <button class="btn" onclick="addComponent('resistor')"> Resistor</button>
                        <button class="btn" onclick="addComponent('led')"> LED</button>
                        <button class="btn" onclick="addComponent('switch')"> Switch</button>
                    </div>
                </div>
            </div>
            
            <div class="menu-tab" onclick="toggleSubmenu('tools')">
                 Tools
                <div class="submenu" id="submenu-tools">
                    <div class="submenu-row">
                        <button class="btn wire-btn" id="wire-btn" onclick="toggleWireMode()"> Wire</button>
                        <button class="btn rotate-btn" id="rotate-btn" onclick="toggleRotateMode()"> Rotate</button>
                    </div>
                    <div class="submenu-row">
                        <button class="btn" onclick="addJunction()"> Junction</button>
                        <button class="btn" onclick="arrangeCircuitSchematic()"> Auto-Arrange</button>
                    </div>
                    <div class="submenu-row">
                        <button class="btn" onclick="clearAll()"> Clear All</button>
                        <button class="btn" onclick="centerCircuit()"> Center Circuit</button>
                    </div>
                </div>
            </div>
            
            <div class="menu-tab" onclick="toggleSubmenu('edit')">
                 Edit
                <div class="submenu" id="submenu-edit">
                    <div class="submenu-row">
                        <button class="btn" onclick="undo()" id="undo-btn"> Undo</button>
                        <button class="btn" onclick="redo()" id="redo-btn"> Redo</button>
                    </div>
                    <div class="submenu-row">
                        <button class="btn" onclick="copySelected()"> Copy</button>
                        <button class="btn" onclick="pasteSelected()"> Paste</button>
                    </div>
                    <div class="submenu-row">
                        <button class="btn" onclick="selectAll()"> Select All</button>
                        <button class="btn" onclick="deleteSelected()"> Delete</button>
                    </div>
                </div>
            </div>
            
            <div class="menu-tab" onclick="toggleSubmenu('file')">
                 File
                <div class="submenu" id="submenu-file">
                    <div class="submenu-row">
                        <button class="btn" onclick="saveCircuit()"> Save</button>
                        <button class="btn" onclick="loadCircuit()"> Load</button>
                    </div>
                    <div class="submenu-row">
                        <button class="btn" onclick="exportImage()"> Export</button>
                        <button class="btn" onclick="newCircuit()"> New</button>
                    </div>
                </div>
            </div>
            
            <div class="menu-tab" onclick="toggleSubmenu('view')">
                 View
                <div class="submenu" id="submenu-view">
                    <div class="submenu-row">
                        <button class="btn" onclick="resetCamera()"> Reset View</button>
                        <button class="btn" onclick="fitToScreen()"> Fit Screen</button>
                    </div>
                    <div class="submenu-row">
                        <button class="btn" onclick="toggleGrid()"> Toggle Grid</button>
                        <button class="btn" onclick="toggleLabels()"> Labels</button>
                    </div>
                </div>
            </div>
            
            <div class="menu-tab" onclick="toggleSubmenu('practice')">
                 Practice
                <div class="submenu" id="submenu-practice">
                    <div class="submenu-row">
                        <button class="btn" onclick="loadPresetCircuit('series_basic')"> Series Circuit</button>
                        <button class="btn" onclick="loadPresetCircuit('parallel_basic')"> Parallel Circuit</button>
                    </div>
                    <div class="submenu-row">
                        <button class="btn" onclick="loadPresetCircuit('mixed_circuit')"> Mixed Circuit</button>
                        <button class="btn" onclick="loadPresetCircuit('switch_control')"> Switch Control</button>
                    </div>
                    <div class="submenu-row">
                        <button class="btn" onclick="generateRandomProblem()"> Random Problem</button>
                        <button class="btn" onclick="showPracticeModeHelp()"> How to Use</button>
                    </div>
                </div>
            </div>
            
            <div class="menu-tab" onclick="toggleSubmenu('help')">
                 Help
                <div class="submenu" id="submenu-help">
                    <div class="submenu-row">
                        <button class="btn" onclick="showTutorial()"> Tutorial</button>
                        <button class="btn" onclick="showWireGuide()"> W.I.R.E. Guide</button>
                    </div>
                    <div class="submenu-row">
                        <button class="btn" onclick="showShortcuts()"> Shortcuts</button>
                        <button class="btn" onclick="showAbout()"> About</button>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <div class="wire-analysis-fixed" id="wire-analysis">
        <button class="analysis-toggle" onclick="toggleAnalysis()"></button>
        
        <div class="analysis-tabs">
            <button class="analysis-tab active" onclick="switchAnalysisTab('wire')" id="tab-wire">W.I.R.E.</button>
            <button class="analysis-tab" onclick="switchAnalysisTab('eir')" id="tab-eir">EIR </button>
            <button class="analysis-tab" onclick="switchAnalysisTab('power')" id="tab-power">Power </button>
            <button class="analysis-tab" onclick="switchAnalysisTab('worksheet')" id="tab-worksheet">Sheet</button>
            <button class="analysis-tab" onclick="switchAnalysisTab('problem')" id="tab-problem">Solve</button>
            <button class="analysis-tab" onclick="switchAnalysisTab('practice')" id="tab-practice">Practice</button>
        </div>

        <!-- W.I.R.E. Method Panel -->
        <div class="analysis-content" id="content-wire">
            <div class="wire-analysis">
                <div class="wire-title"> W.I.R.E. METHOD</div>
                <div class="wire-grid">
                    <div class="wire-item wire-w">
                        <div class="wire-letter">W</div>
                        <div class="wire-label">Watts (Power)</div>
                        <div class="wire-value" id="power">0W</div>
                    </div>
                    <div class="wire-item wire-i">
                        <div class="wire-letter">I</div>
                        <div class="wire-label">Current (Amps)</div>
                        <div class="wire-value" id="current">0A</div>
                    </div>
                    <div class="wire-item wire-r">
                        <div class="wire-letter">R</div>
                        <div class="wire-label">Resistance (Ohms)</div>
                        <div class="wire-value" id="resistance"></div>
                    </div>
                    <div class="wire-item wire-e">
                        <div class="wire-letter">E</div>
                        <div class="wire-label">Voltage (EMF)</div>
                        <div class="wire-value" id="voltage">0V</div>
                    </div>
                </div>
                <div style="font-size: 12px; color: #888; margin-top: 12px; text-align: center;">
                    <strong> Circuit Status:</strong><br>
                    Components: <span id="count" style="color: #00ff88;">0</span> | 
                    Wires: <span id="wire-count" style="color: #ffaa88;">0</span> | 
                    Junctions: <span id="junction-count" style="color: #aa88ff;">0</span>
                </div>
            </div>
        </div>

        <!-- EIR Triangle Panel (EMF, Current, Resistance) -->
        <div class="analysis-content" id="content-eir" style="display: none;">
            <div class="vir-triangle">
                <div class="triangle-container">
                    <div class="triangle-shape"></div>
                    <div class="triangle-sections">
                        <div class="triangle-v" onclick="explainOhmsLaw('E')">E</div>
                        <div class="triangle-i" onclick="explainOhmsLaw('I')">I</div>
                        <div class="triangle-r" onclick="explainOhmsLaw('R')">R</div>
                    </div>
                </div>
                <div class="triangle-formula" id="eir-formula">
                    E = I  R | I = E  R | R = E  I
                </div>
                <div style="color: #ccc; font-size: 12px; margin-top: 12px; text-align: center;">
                    Click E, I, or R to see the formula<br>
                    <strong>E</strong> = EMF/Voltage | <strong>I</strong> = Current | <strong>R</strong> = Resistance
                </div>
            </div>
            
            <div class="circuit-diagram">
                <div class="diagram-title">Circuit Schematic</div>
                <div class="circuit-schematic" id="circuit-schematic">
                    <div class="schematic-line">     +[R]+</div>
                    <div class="schematic-line">                   </div>
                    <div class="schematic-line">   [BAT]          [R]</div>
                    <div class="schematic-line">                   </div>
                    <div class="schematic-line">     ++</div>
                </div>
            </div>
        </div>

        <!-- Power Triangle Panel (Watts, Current, EMF) -->
        <div class="analysis-content" id="content-power" style="display: none;">
            <div class="vir-triangle">
                <div class="triangle-container">
                    <div class="triangle-shape" style="border-bottom-color: rgba(68,136,255,0.3);"></div>
                    <div class="triangle-sections">
                        <div class="triangle-v" onclick="explainPowerLaw('W')" style="color: #4488ff;">W</div>
                        <div class="triangle-i" onclick="explainPowerLaw('I')" style="color: #ff8844;">I</div>
                        <div class="triangle-r" onclick="explainPowerLaw('E')" style="color: #ff4444;">E</div>
                    </div>
                </div>
                <div class="triangle-formula" id="power-formula" style="color: #4488ff;">
                    W = I  E | I = W  E | E = W  I
                </div>
                <div style="color: #ccc; font-size: 12px; margin-top: 12px; text-align: center;">
                    Click W, I, or E to see the power formula<br>
                    <strong>W</strong> = Watts/Power | <strong>I</strong> = Current | <strong>E</strong> = EMF/Voltage
                </div>
                
                <div style="background: rgba(68,136,255,0.1); padding: 12px; border-radius: 8px; margin-top: 12px; border: 1px solid rgba(68,136,255,0.3);">
                    <div style="color: #4488ff; font-weight: bold; text-align: center; margin-bottom: 8px;">
                         Additional Power Formulas
                    </div>
                    <div style="color: #ccc; font-size: 11px; text-align: center; line-height: 1.4;">
                        W = I  R (Power = Current  Resistance)<br>
                        W = E  R (Power = Voltage  Resistance)
                    </div>
                </div>
            </div>
        </div>

        <!-- Worksheet Panel -->
        <div class="analysis-content" id="content-worksheet" style="display: none;">
            <div class="worksheet-panel">
                <div class="worksheet-title">Circuit Analysis Worksheet</div>
                
                <div class="component-list" id="component-list">
                    <!-- Components will be populated here -->
                </div>

                <div class="calculations-section">
                    <div class="calculation-step step-resistance">
                        <div>
                            <div class="step-label">Total Resistance</div>
                            <div class="step-formula" id="resistance-formula">R_total = R + R + R...</div>
                        </div>
                        <div class="step-value" id="calc-resistance"></div>
                    </div>
                    
                    <div class="calculation-step step-current">
                        <div>
                            <div class="step-label">Total Current</div>
                            <div class="step-formula" id="current-formula">I = V  R_total</div>
                        </div>
                        <div class="step-value" id="calc-current">0A</div>
                    </div>
                    
                    <div class="calculation-step step-voltage">
                        <div>
                            <div class="step-label">Source Voltage</div>
                            <div class="step-formula" id="voltage-formula">V = V_bat1 + V_bat2...</div>
                        </div>
                        <div class="step-value" id="calc-voltage">0V</div>
                    </div>
                    
                    <div class="calculation-step step-power">
                        <div>
                            <div class="step-label">Total Power</div>
                            <div class="step-formula" id="worksheet-power-formula">P = V  I</div>
                        </div>
                        <div class="step-value" id="calc-power">0W</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Problem Solving Panel -->
        <div class="analysis-content" id="content-problem" style="display: none;">
            <div class="problem-mode">
                <div class="problem-title"> Solve for the Unknown</div>
                <div style="color: #ccc; margin-bottom: 16px; text-align: center;">
                    Enter your calculated values below:
                </div>
                
                <div class="unknown-input">
                    <label style="color: #ff4444; width: 120px;">Total Voltage:</label>
                    <input type="number" id="student-voltage" step="0.1" placeholder="V">
                    <span style="color: #ff4444;">V</span>
                </div>
                
                <div class="unknown-input">
                    <label style="color: #ff8844; width: 120px;">Total Current:</label>
                    <input type="number" id="student-current" step="0.001" placeholder="A">
                    <span style="color: #ff8844;">A</span>
                </div>
                
                <div class="unknown-input">
                    <label style="color: #44ff88; width: 120px;">Total Resistance:</label>
                    <input type="number" id="student-resistance" step="0.1" placeholder="">
                    <span style="color: #44ff88;"></span>
                </div>
                
                <div class="unknown-input">
                    <label style="color: #4488ff; width: 120px;">Total Power:</label>
                    <input type="number" id="student-power" step="0.01" placeholder="W">
                    <span style="color: #4488ff;">W</span>
                </div>
                
                <div style="text-align: center; margin-top: 16px;">
                    <button class="check-answer-btn" onclick="checkStudentAnswers()">
                         Check My Answers
                    </button>
                </div>
                
                <div id="answer-feedback"></div>
            </div>
        </div>

        <!-- Practice Mode Panel -->
        <div class="analysis-content" id="content-practice" style="display: none;">
            <div class="practice-problem-card" id="practice-problem-card" style="display: none;">
                <div class="problem-question" id="practice-question">
                     Problem: Find the total resistance
                </div>
                <div class="problem-description" id="practice-description">
                    Calculate the total resistance of this series circuit
                </div>
                
                <div style="display: flex; justify-content: space-between; align-items: center; margin: 12px 0;">
                    <div style="color: #4da6ff; font-size: 12px; font-weight: bold;">
                        Problem <span id="problem-counter">1</span> of <span id="total-problems">4</span>
                    </div>
                    <div style="display: flex; gap: 8px;">
                        <button class="practice-btn" onclick="previousProblem()" id="prev-btn" style="padding: 6px 12px; font-size: 11px;"> Prev</button>
                        <button class="practice-btn" onclick="nextProblem()" id="next-btn" style="padding: 6px 12px; font-size: 11px;">Next </button>
                    </div>
                </div>
                
                <div class="circuit-status" id="circuit-status">
                    <div id="circuit-status-text"> Circuit incomplete - Add wires to connect components</div>
                </div>
                
                <div class="wire-instructions" id="wire-instructions">
                     <strong>How to wire:</strong> 1) Click  Tools   Wire Mode  2) Touch red/white terminals to connect  3) Switch to Solve tab when complete
                </div>
                
                <div id="practice-objectives" style="margin-top: 12px;">
                    <div style="color: #4da6ff; font-weight: bold; margin-bottom: 8px; font-size: 14px;"> Learning Objectives:</div>
                    <ul id="objectives-list" style="color: #ccc; margin-left: 20px; line-height: 1.5; font-size: 12px;">
                        <!-- Objectives will be populated here -->
                    </ul>
                </div>
            </div>
            
            <div class="worksheet-panel">
                <div class="worksheet-title"> Practice Circuit Problems</div>
                
                <div style="text-align: center; margin-bottom: 16px;">
                    <button class="practice-btn" onclick="startPracticeSequence()" style="background: linear-gradient(135deg, #00ff88, #00cc66); color: #000; padding: 12px 24px; font-size: 14px; font-weight: bold;">
                         Start Practice Sequence
                    </button>
                </div>
                
                <div class="practice-buttons">
                    <button class="practice-btn" onclick="loadPresetCircuit('series_basic')" id="btn-series"> Basic Series</button>
                    <button class="practice-btn" onclick="loadPresetCircuit('parallel_basic')" id="btn-parallel"> Basic Parallel</button>
                    <button class="practice-btn" onclick="loadPresetCircuit('mixed_circuit')" id="btn-mixed"> Mixed Circuit</button>
                    <button class="practice-btn" onclick="generateRandomProblem()" id="btn-random"> Random</button>
                </div>
                
                <div id="practice-help-text" style="background: rgba(255,255,255,0.1); padding: 16px; border-radius: 8px; color: #ccc; text-align: center; font-size: 12px;">
                    <strong> Choose your practice method:</strong><br>
                     <strong>Practice Sequence</strong> - Work through problems 1234<br>
                     <strong>Individual Problems</strong> - Jump to any specific circuit<br>
                     <strong>Random</strong> - Get randomized component values<br><br>
                    <small>All problems require manual wiring and calculations!</small>
                </div>
            </div>
        </div>
    </div>
    
    <div class="status" id="status" style="display: none;">W.I.R.E. Circuit Builder Ready!</div>
    
    <div class="edit-popup" id="edit-popup">
        <h3 id="edit-title">Edit Component</h3>
        <div id="edit-content">
            <!-- Dynamic content will be inserted here -->
        </div>
        <div class="edit-buttons">
            <button class="edit-btn save" onclick="saveEdit()"> Save</button>
            <button class="edit-btn cancel" onclick="cancelEdit()"> Cancel</button>
        </div>
    </div>
    
    <canvas id="canvas" style="display: none;"></canvas>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Global variables
        let scene, camera, renderer, raycaster, mouse;
        let components = [], wires = [], junctions = [];
        let isWireMode = false, isRotateMode = false, wireStart = null;
        let isDragging = false, selectedComponent = null;
        let currentFlowParticles = [];
        let menuVisible = true, analysisVisible = true;
        let undoStack = [], redoStack = [];
        let clipboard = null;
        let selectedComponents = new Set();
        let showGrid = true, showLabels = true;
        let currentAnalysisTab = 'wire';
        let lastKnownValues = { voltage: 0, current: 0, resistance: Infinity, power: 0 };
        let currentPracticeCircuit = null;
        let currentProblemIndex = 0;
        let practiceProblems = ['series_basic', 'parallel_basic', 'mixed_circuit', 'switch_control'];
        let practiceQuestions = {
            series_basic: {
                question: "Find the total resistance and current",
                expectedAnswer: "resistance", // What we're testing for
                description: "Calculate R_total = R + R, then find I = E  R_total"
            },
            parallel_basic: {
                question: "Find the total resistance (parallel)",
                expectedAnswer: "resistance",
                description: "Use 1/R_total = 1/R + 1/R, then find the equivalent resistance"
            },
            mixed_circuit: {
                question: "Analyze the complex circuit",
                expectedAnswer: "current",
                description: "Break down into series and parallel sections, find total resistance and current"
            },
            switch_control: {
                question: "Determine circuit behavior with switch",
                expectedAnswer: "power",
                description: "Compare power consumption when switch is ON vs OFF"
            }
        };
        
        // Long press and edit variables
        let longPressTimer = null;
        let longPressStartPos = { x: 0, y: 0 };
        let isLongPressing = false;
        let currentEditComponent = null;
        const LONG_PRESS_DURATION = 600; // Shorter for mobile
        
        // Grid and snapping variables
        const GRID_SIZE = 2; // Grid spacing
        let gridHelper = null;
        let snapIndicator = null;
        
        // W.I.R.E. Color coding
        const WIRE_COLORS = {
            W: '#4488ff', // Power (Watts) - Blue
            I: '#ff8844', // Current (Amps) - Orange  
            R: '#44ff88', // Resistance (Ohms) - Green
            E: '#ff4444'  // Voltage (Volts) - Red
        };
        
        // Component counters for labeling
        let componentCounters = {
            battery: 0,
            resistor: 0,
            led: 0,
            switch: 0
        };
        
        // Camera controls
        let cameraDistance = 15;
        let cameraAngleX = 0, cameraAngleY = 0.5;
        let cameraTarget = new THREE.Vector3(0, 0, 0);
        let isRotating = false, isPanning = false;
        let lastTouchPos = { x: 0, y: 0 };
        let lastTwoFingerCenter = { x: 0, y: 0 };
        let lastPinchDistance = 0;

        // Mobile detection
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        const isAndroid = /Android/i.test(navigator.userAgent);

        // Adjust settings for mobile
        if (isMobile) {
            // Reduce particle count for better performance
            const originalParticleCount = 8;
            // Increase touch sensitivity
            const TOUCH_SENSITIVITY = 0.8;
            // Reduce quality for better performance
            const MOBILE_QUALITY_FACTOR = 0.7;
        }

        // Junction class
        class Junction {
            constructor(position) {
                this.position = snapToGrid(position);
                this.connections = [];
                this.id = 'junction_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                this.createMesh();
            }

            createMesh() {
                const group = new THREE.Group();
                
                // Main purple sphere
                const bodyGeometry = new THREE.SphereGeometry(0.25, isMobile ? 12 : 16, isMobile ? 8 : 12);
                const bodyMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0x8844ff,
                    emissive: 0x221188,
                    shininess: 100
                });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                group.add(body);
                
                // Selection sphere
                const selectionGeometry = new THREE.SphereGeometry(isMobile ? 1.2 : 0.8, 8, 6);
                const selectionMaterial = new THREE.MeshBasicMaterial({ 
                    transparent: true,
                    opacity: 0.0
                });
                const selectionSphere = new THREE.Mesh(selectionGeometry, selectionMaterial);
                selectionSphere.userData = { junction: this, isSelectionBox: true };
                group.add(selectionSphere);
                
                group.position.copy(this.position);
                group.userData = { junction: this };
                
                this.mesh = group;
                this.selectionSphere = selectionSphere;
                scene.add(group);
                
                this.createConnectionPoint();
            }

            createConnectionPoint() {
                const pointGeometry = new THREE.SphereGeometry(0.28, isMobile ? 12 : 16, isMobile ? 8 : 12);
                const pointMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0xaa66ff,
                    emissive: 0x332288,
                    shininess: 200
                });
                
                const connectionPoint = new THREE.Mesh(pointGeometry, pointMaterial);
                connectionPoint.position.set(0, 0, 0);
                connectionPoint.userData = { 
                    junction: this, 
                    isConnectionPoint: true, 
                    side: 'center',
                    polarity: 'neutral'
                };
                
                this.mesh.add(connectionPoint);
                this.connectionPoint = connectionPoint;
            }

            getWorldConnectionPoint() {
                if (this.connectionPoint) {
                    const worldPosition = new THREE.Vector3();
                    this.connectionPoint.getWorldPosition(worldPosition);
                    return snapToGrid(worldPosition);
                }
                return snapToGrid(this.position.clone());
            }

            addConnection(wire) {
                this.connections.push(wire);
            }

            removeConnection(wire) {
                const index = this.connections.indexOf(wire);
                if (index > -1) {
                    this.connections.splice(index, 1);
                }
            }

            remove() {
                if (this.mesh) {
                    scene.remove(this.mesh);
                }
                const connectedWires = [...this.connections];
                connectedWires.forEach(wire => wire.remove());
                const index = junctions.indexOf(this);
                if (index > -1) {
                    junctions.splice(index, 1);
                }
            }
        }

        // Component class
        class Component {
            constructor(type, position) {
                this.type = type;
                this.position = snapToGrid(position);
                this.rotation = 0;
                this.connections = [];
                this.properties = this.getDefaultProperties(type);
                
                // Assign component number
                componentCounters[type]++;
                this.componentNumber = componentCounters[type];
                this.id = type + '_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                
                this.createMesh();
                this.createConnectionPoints();
                this.createComponentLabels();
            }

            getDefaultProperties(type) {
                switch(type) {
                    case 'battery': return { voltage: 9 };
                    case 'resistor': return { resistance: 100 };
                    case 'led': return { resistance: 10 };
                    case 'switch': return { resistance: 0.1, isOn: true };
                    default: return {};
                }
            }

            createComponentLabels() {
                // Create DOM labels that will float above components
                this.labelDiv = document.createElement('div');
                this.labelDiv.className = 'component-label';
                this.labelDiv.style.fontSize = isMobile ? '16px' : '14px';
                this.labelDiv.style.fontWeight = 'bold';
                this.labelDiv.style.textAlign = 'center';
                this.labelDiv.style.lineHeight = '1.2';
                
                // Component identifier
                const identifier = this.getComponentIdentifier();
                
                // Component value with color coding
                const { text, color } = this.getValueTextAndColor();
                
                this.labelDiv.innerHTML = `
                    <div style="color: white; font-size: ${isMobile ? '14px' : '12px'};">${identifier}</div>
                    <div style="color: ${color}; font-size: ${isMobile ? '13px' : '11px'}; font-weight: bold;">${text}</div>
                `;
                
                document.body.appendChild(this.labelDiv);
                this.updateLabelPosition();
            }

            getComponentIdentifier() {
                switch(this.type) {
                    case 'battery': return `B${this.componentNumber}`;
                    case 'resistor': return `R${this.componentNumber}`;
                    case 'led': return `LED${this.componentNumber}`;
                    case 'switch': return `SW${this.componentNumber}`;
                    default: return `C${this.componentNumber}`;
                }
            }

            getValueTextAndColor() {
                switch(this.type) {
                    case 'battery':
                        return {
                            text: `${this.properties.voltage}V`,
                            color: WIRE_COLORS.E // Voltage - Red
                        };
                    case 'resistor':
                        return {
                            text: `${this.properties.resistance}`,
                            color: WIRE_COLORS.R // Resistance - Green
                        };
                    case 'led':
                        return {
                            text: `${this.properties.resistance}`,
                            color: WIRE_COLORS.R // Resistance - Green
                        };
                    case 'switch':
                        const state = this.properties.isOn ? 'ON' : 'OFF';
                        return {
                            text: state,
                            color: this.properties.isOn ? '#44ff44' : '#ff4444'
                        };
                    default:
                        return { text: '', color: '#ffffff' };
                }
            }

            updateLabelPosition() {
                if (!this.labelDiv || !this.mesh) return;
                
                const vector = new THREE.Vector3();
                vector.setFromMatrixPosition(this.mesh.matrixWorld);
                vector.y += 3; // Position above component
                vector.project(camera);
                
                const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
                const y = (vector.y * -0.5 + 0.5) * window.innerHeight;
                
                this.labelDiv.style.left = (x - (isMobile ? 40 : 30)) + 'px';
                this.labelDiv.style.top = (y - (isMobile ? 40 : 30)) + 'px';
                
                // Hide label if component is behind camera
                this.labelDiv.style.display = vector.z > 1 ? 'none' : (showLabels ? 'block' : 'none');
            }

            updateLabels() {
                if (!this.labelDiv) return;
                
                const identifier = this.getComponentIdentifier();
                const { text, color } = this.getValueTextAndColor();
                
                this.labelDiv.innerHTML = `
                    <div style="color: white; font-size: ${isMobile ? '14px' : '12px'};">${identifier}</div>
                    <div style="color: ${color}; font-size: ${isMobile ? '13px' : '11px'}; font-weight: bold;">${text}</div>
                `;
                
                this.updateLabelPosition();
            }

            createMesh() {
                const group = new THREE.Group();
                
                switch(this.type) {
                    case 'battery':
                        this.createBatteryMesh(group);
                        break;
                    case 'resistor':
                        this.createResistorMesh(group);
                        break;
                    case 'led':
                        this.createLEDMesh(group);
                        break;
                    case 'switch':
                        this.createSwitchMesh(group);
                        break;
                }
                
                group.position.copy(this.position);
                group.userData = { component: this };
                
                this.createSelectionBox(group);
                this.mesh = group;
                scene.add(group);
            }

            createSelectionBox(group) {
                const selectionGeometry = new THREE.BoxGeometry(
                    isMobile ? 3.5 : 2.5, 
                    isMobile ? 2.0 : 1.5, 
                    isMobile ? 2.0 : 1.5
                );
                const selectionMaterial = new THREE.MeshBasicMaterial({ 
                    transparent: true,
                    opacity: 0.0
                });
                
                const selectionBox = new THREE.Mesh(selectionGeometry, selectionMaterial);
                selectionBox.userData = { component: this, isSelectionBox: true };
                
                group.add(selectionBox);
                this.selectionBox = selectionBox;
            }

            createBatteryMesh(group) {
                // Battery body
                const segments = isMobile ? 6 : 8;
                const bodyGeometry = new THREE.CylinderGeometry(0.3, 0.3, 1.2, segments);
                const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0x1a1a1a });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.rotation.z = Math.PI / 2;
                group.add(body);

                // Positive terminal
                const posGeometry = new THREE.CylinderGeometry(0.2, 0.2, 0.3, segments);
                const posMaterial = new THREE.MeshPhongMaterial({ color: 0xb87333 });
                const pos = new THREE.Mesh(posGeometry, posMaterial);
                pos.rotation.z = Math.PI / 2;
                pos.position.x = 0.75;
                group.add(pos);

                // Negative terminal
                const negGeometry = new THREE.CylinderGeometry(0.3, 0.3, 0.15, segments);
                const negMaterial = new THREE.MeshLambertMaterial({ color: 0x2a2a2a });
                const neg = new THREE.Mesh(negGeometry, negMaterial);
                neg.rotation.z = Math.PI / 2;
                neg.position.x = -0.7;
                group.add(neg);

                // Labels
                this.addText(group, '+', new THREE.Vector3(1.0, 0.4, 0), 0xff0000);
                this.addText(group, '-', new THREE.Vector3(-1.0, 0.4, 0), 0x000000);
            }

            createResistorMesh(group) {
                const segments = isMobile ? 6 : 8;
                // Resistor body
                const bodyGeometry = new THREE.CylinderGeometry(0.15, 0.15, 1, segments);
                const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0xccaa66 });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.rotation.z = Math.PI / 2;
                group.add(body);

                // Color bands
                for(let i = 0; i < 4; i++) {
                    const bandGeometry = new THREE.CylinderGeometry(0.16, 0.16, 0.1, segments);
                    const colors = [0xff0000, 0x00ff00, 0x0000ff, 0xffd700];
                    const bandMaterial = new THREE.MeshLambertMaterial({ color: colors[i] });
                    const band = new THREE.Mesh(bandGeometry, bandMaterial);
                    band.rotation.z = Math.PI / 2;
                    band.position.x = -0.3 + i * 0.2;
                    group.add(band);
                }

                this.addLeads(group);
            }

            createLEDMesh(group) {
                const segments = isMobile ? 6 : 8;
                // LED dome
                const domeGeometry = new THREE.SphereGeometry(0.25, segments, segments/2, 0, Math.PI * 2, 0, Math.PI / 2);
                const domeMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0xff4444, 
                    transparent: true, 
                    opacity: 0.8 
                });
                const dome = new THREE.Mesh(domeGeometry, domeMaterial);
                dome.position.y = 0.1;
                group.add(dome);

                // LED base
                const baseGeometry = new THREE.CylinderGeometry(0.25, 0.25, 0.2, segments);
                const baseMaterial = new THREE.MeshLambertMaterial({ color: 0x333333 });
                const base = new THREE.Mesh(baseGeometry, baseMaterial);
                base.position.y = -0.1;
                group.add(base);

                this.addLeads(group);
            }

            createSwitchMesh(group) {
                // Switch base
                const baseGeometry = new THREE.BoxGeometry(0.8, 0.2, 0.4);
                const baseMaterial = new THREE.MeshLambertMaterial({ color: 0x666666 });
                const base = new THREE.Mesh(baseGeometry, baseMaterial);
                group.add(base);

                // Switch lever
                const leverGeometry = new THREE.BoxGeometry(0.1, 0.4, 0.1);
                const leverMaterial = new THREE.MeshLambertMaterial({ 
                    color: this.properties.isOn ? 0x00ff00 : 0xff0000 
                });
                const lever = new THREE.Mesh(leverGeometry, leverMaterial);
                lever.position.y = 0.3;
                lever.rotation.z = this.properties.isOn ? 0 : Math.PI / 6;
                group.add(lever);
                this.leverMesh = lever;

                this.addLeads(group);
            }

            addLeads(group) {
                const segments = isMobile ? 4 : 6;
                const leadGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.8, segments);
                const leadMaterial = new THREE.MeshLambertMaterial({ color: 0x888888 });
                
                const leftLead = new THREE.Mesh(leadGeometry, leadMaterial);
                leftLead.rotation.z = Math.PI / 2;
                leftLead.position.x = -0.6;
                group.add(leftLead);

                const rightLead = new THREE.Mesh(leadGeometry, leadMaterial);
                rightLead.rotation.z = Math.PI / 2;
                rightLead.position.x = 0.6;
                group.add(rightLead);
            }

            addText(group, text, position, color) {
                if (text === '+') {
                    const hBarGeometry = new THREE.BoxGeometry(0.2, 0.04, 0.04);
                    const hBarMaterial = new THREE.MeshLambertMaterial({ color: color });
                    const hBar = new THREE.Mesh(hBarGeometry, hBarMaterial);
                    hBar.position.copy(position);
                    group.add(hBar);
                    
                    const vBarGeometry = new THREE.BoxGeometry(0.04, 0.2, 0.04);
                    const vBar = new THREE.Mesh(vBarGeometry, hBarMaterial);
                    vBar.position.copy(position);
                    group.add(vBar);
                } else if (text === '-') {
                    const barGeometry = new THREE.BoxGeometry(0.2, 0.04, 0.04);
                    const barMaterial = new THREE.MeshLambertMaterial({ color: color });
                    const bar = new THREE.Mesh(barGeometry, barMaterial);
                    bar.position.copy(position);
                    group.add(bar);
                }
            }

            createConnectionPoints() {
                this.connectionPoints = [];
                
                const pointGeometry = new THREE.SphereGeometry(0.3, isMobile ? 16 : 20, isMobile ? 12 : 16);
                const leftPos = new THREE.Vector3(-1.2, 0, 0);
                const rightPos = new THREE.Vector3(1.2, 0, 0);
                
                if (this.type === 'battery') {
                    // Red positive terminal
                    const positiveMaterial = new THREE.MeshPhongMaterial({ 
                        color: 0xff0000,
                        emissive: 0x330000,
                        shininess: 200
                    });
                    const positivePoint = new THREE.Mesh(pointGeometry, positiveMaterial);
                    positivePoint.position.copy(rightPos);
                    positivePoint.userData = { 
                        component: this, 
                        isConnectionPoint: true, 
                        side: 'positive', 
                        polarity: 'positive'
                    };
                    this.mesh.add(positivePoint);
                    this.connectionPoints.push(positivePoint);

                    // Gray negative terminal
                    const negativeMaterial = new THREE.MeshPhongMaterial({ 
                        color: 0x333333,
                        emissive: 0x111111,
                        shininess: 200
                    });
                    const negativePoint = new THREE.Mesh(pointGeometry, negativeMaterial);
                    negativePoint.position.copy(leftPos);
                    negativePoint.userData = { 
                        component: this, 
                        isConnectionPoint: true, 
                        side: 'negative', 
                        polarity: 'negative'
                    };
                    this.mesh.add(negativePoint);
                    this.connectionPoints.push(negativePoint);
                    
                } else {
                    // White neutral terminals
                    const neutralMaterial = new THREE.MeshPhongMaterial({ 
                        color: 0xffffff,
                        emissive: 0x222222,
                        shininess: 200
                    });

                    const leftPoint = new THREE.Mesh(pointGeometry, neutralMaterial.clone());
                    leftPoint.position.copy(leftPos);
                    leftPoint.userData = { 
                        component: this, 
                        isConnectionPoint: true, 
                        side: 'left', 
                        polarity: 'neutral'
                    };
                    this.mesh.add(leftPoint);
                    this.connectionPoints.push(leftPoint);

                    const rightPoint = new THREE.Mesh(pointGeometry, neutralMaterial.clone());
                    rightPoint.position.copy(rightPos);
                    rightPoint.userData = { 
                        component: this, 
                        isConnectionPoint: true, 
                        side: 'right', 
                        polarity: 'neutral'
                    };
                    this.mesh.add(rightPoint);
                    this.connectionPoints.push(rightPoint);
                }
            }

            getWorldConnectionPoint(side) {
                const targetPoint = this.connectionPoints?.find(point => 
                    point.userData?.side === side
                );
                
                if (targetPoint) {
                    const worldPosition = new THREE.Vector3();
                    targetPoint.getWorldPosition(worldPosition);
                    return snapToGrid(worldPosition);
                }
                
                const offset = (side === 'positive' || side === 'right') ? 1.2 : -1.2;
                return snapToGrid(new THREE.Vector3(
                    this.position.x + offset,
                    this.position.y,
                    this.position.z
                ));
            }

            updateProperties(newProperties) {
                Object.assign(this.properties, newProperties);
                if (this.type === 'switch' && this.leverMesh) {
                    this.leverMesh.material.color.setHex(this.properties.isOn ? 0x00ff00 : 0xff0000);
                    this.leverMesh.rotation.z = this.properties.isOn ? 0 : Math.PI / 6;
                }
                
                // Update the labels with new values
                this.updateLabels();
            }

            remove() {
                if (this.mesh) {
                    scene.remove(this.mesh);
                }
                
                if (this.labelDiv) {
                    document.body.removeChild(this.labelDiv);
                }
                
                const connectedWires = [...this.connections];
                connectedWires.forEach(connection => {
                    if (connection.wire) {
                        connection.wire.remove();
                    }
                });
                
                const index = components.indexOf(this);
                if (index > -1) {
                    components.splice(index, 1);
                }
                
                // Reset component counter if this was the last one
                this.updateComponentCounters();
            }

            updateComponentCounters() {
                // Recalculate component numbers to avoid gaps
                const typeComponents = components.filter(comp => comp.type === this.type);
                typeComponents.forEach((comp, index) => {
                    comp.componentNumber = index + 1;
                    comp.updateLabels();
                });
                componentCounters[this.type] = typeComponents.length;
            }
        }

        // Wire class
        class Wire {
            constructor(startObj, startSide, endObj, endSide) {
                this.startObj = startObj;
                this.startSide = startSide;
                this.endObj = endObj;
                this.endSide = endSide;
                this.id = 'wire_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                this.segments = [];
                
                this.createMesh();
                this.createCurve();
                this.addToConnections();
            }

            createMesh() {
                const startPos = this.getStartPosition();
                const endPos = this.getEndPosition();
                
                const distance = startPos.distanceTo(endPos);
                if (distance < 0.1) {
                    throw new Error('Wire too short');
                }
                
                // Create right-angled wire path
                const path = createRightAngledWirePath(startPos, endPos);
                this.createWireSegments(path);
            }

            createWireSegments(path) {
                this.wireGroup = new THREE.Group();
                this.segments = [];
                
                for (let i = 0; i < path.length - 1; i++) {
                    const segmentStart = path[i];
                    const segmentEnd = path[i + 1];
                    const distance = segmentStart.distanceTo(segmentEnd);
                    
                    if (distance > 0.1) {
                        const wireGeometry = new THREE.CylinderGeometry(0.08, 0.08, distance, isMobile ? 8 : 12);
                        
                        const material = new THREE.MeshPhongMaterial({ 
                            color: 0xd2691e,
                            shininess: 150,
                            transparent: true,
                            opacity: 0.9
                        });
                        
                        const segment = new THREE.Mesh(wireGeometry, material);
                        
                        // Position segment at midpoint
                        const midPoint = new THREE.Vector3().addVectors(segmentStart, segmentEnd).multiplyScalar(0.5);
                        segment.position.copy(midPoint);
                        
                        // Rotate segment to connect the points
                        const direction = new THREE.Vector3().subVectors(segmentEnd, segmentStart).normalize();
                        const up = new THREE.Vector3(0, 1, 0);
                        const quaternion = new THREE.Quaternion().setFromUnitVectors(up, direction);
                        segment.setRotationFromQuaternion(quaternion);
                        
                        this.wireGroup.add(segment);
                        this.segments.push({
                            mesh: segment,
                            start: segmentStart.clone(),
                            end: segmentEnd.clone()
                        });
                    }
                }
                
                this.wireGroup.userData = { wire: this };
                this.mesh = this.wireGroup;
                scene.add(this.wireGroup);
            }

            getStartPosition() {
                if (this.startObj.getWorldConnectionPoint) {
                    return snapToGrid(this.startObj.getWorldConnectionPoint(this.startSide));
                }
                return snapToGrid(this.startObj.position.clone());
            }

            getEndPosition() {
                if (this.endObj.getWorldConnectionPoint) {
                    return snapToGrid(this.endObj.getWorldConnectionPoint(this.endSide));
                }
                return snapToGrid(this.endObj.position.clone());
            }

            createCurve() {
                try {
                    const startPos = this.getStartPosition();
                    const endPos = this.getEndPosition();
                    const path = createRightAngledWirePath(startPos, endPos);
                    
                    this.curve = {
                        getPoint: (t) => {
                            t = Math.max(0, Math.min(1, t));
                            
                            let totalDistance = 0;
                            const distances = [];
                            
                            // Calculate segment distances
                            for (let i = 0; i < path.length - 1; i++) {
                                const segmentDistance = path[i].distanceTo(path[i + 1]);
                                distances.push(segmentDistance);
                                totalDistance += segmentDistance;
                            }
                            
                            // Find which segment we're on
                            const targetDistance = t * totalDistance;
                            let currentDistance = 0;
                            
                            for (let i = 0; i < distances.length; i++) {
                                if (currentDistance + distances[i] >= targetDistance) {
                                    const segmentT = (targetDistance - currentDistance) / distances[i];
                                    return new THREE.Vector3().lerpVectors(path[i], path[i + 1], segmentT);
                                }
                                currentDistance += distances[i];
                            }
                            
                            return path[path.length - 1].clone();
                        }
                    };
                } catch (error) {
                    console.error('Error creating wire curve:', error);
                    this.curve = null;
                }
            }

            updatePath() {
                if (this.wireGroup) {
                    scene.remove(this.wireGroup);
                }
                
                const startPos = this.getStartPosition();
                const endPos = this.getEndPosition();
                const path = createRightAngledWirePath(startPos, endPos);
                
                this.createWireSegments(path);
                this.createCurve();
            }

            addToConnections() {
                if (this.startObj.connections) {
                    this.startObj.connections.push({
                        wire: this,
                        connectedTo: this.endObj,
                        side: this.startSide
                    });
                }
                if (this.startObj.addConnection) {
                    this.startObj.addConnection(this);
                }
                
                if (this.endObj.connections) {
                    this.endObj.connections.push({
                        wire: this,
                        connectedTo: this.startObj,
                        side: this.endSide
                    });
                }
                if (this.endObj.addConnection) {
                    this.endObj.addConnection(this);
                }
            }

            remove() {
                if (this.wireGroup) {
                    scene.remove(this.wireGroup);
                }
                
                if (this.startObj?.connections) {
                    this.startObj.connections = this.startObj.connections.filter(
                        conn => conn.wire !== this
                    );
                }
                if (this.startObj?.removeConnection) {
                    this.startObj.removeConnection(this);
                }
                
                if (this.endObj?.connections) {
                    this.endObj.connections = this.endObj.connections.filter(
                        conn => conn.wire !== this
                    );
                }
                if (this.endObj?.removeConnection) {
                    this.endObj.removeConnection(this);
                }
                
                const index = wires.indexOf(this);
                if (index > -1) {
                    wires.splice(index, 1);
                }
            }
        }

        // Center circuit for optimal viewing
        function centerCircuit() {
            if (components.length === 0 && junctions.length === 0) {
                setStatus(' No components to center');
                return;
            }
            
            saveState(); // Save for undo
            
            // Calculate center of all components
            const allObjects = [...components, ...junctions];
            let centerX = 0, centerZ = 0;
            
            allObjects.forEach(obj => {
                centerX += obj.position.x;
                centerZ += obj.position.z;
            });
            
            centerX /= allObjects.length;
            centerZ /= allObjects.length;
            
            // Move all objects to center the circuit at origin
            const offsetX = -centerX;
            const offsetZ = -centerZ;
            
            allObjects.forEach(obj => {
                obj.position.x += offsetX;
                obj.position.z += offsetZ;
                
                // Snap to grid
                obj.position.copy(snapToGrid(obj.position));
                
                if (obj.mesh) {
                    obj.mesh.position.copy(obj.position);
                }
            });
            
            // Update all wire paths
            wires.forEach(wire => {
                if (wire.updatePath) {
                    wire.updatePath();
                }
            });
            
            // Center camera view
            cameraTarget.set(0, 0, 0);
            updateCameraPosition();
            
            setStatus(' Circuit centered and aligned to grid for professional schematic appearance');
        }

        // Initialize the scene
        function init() {
            try {
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x0a0a1a);
                
                camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                updateCameraPosition();
                
                const canvas = document.getElementById('canvas');
                renderer = new THREE.WebGLRenderer({ 
                    canvas: canvas,
                    antialias: !isMobile, // Disable antialiasing on mobile for performance
                    powerPreference: isMobile ? "low-power" : "high-performance"
                });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, isMobile ? 1.5 : 2));
                
                raycaster = new THREE.Raycaster();
                mouse = new THREE.Vector2();
                
                // Lighting - reduced for mobile performance
                const directionalLight = new THREE.DirectionalLight(0xffffff, isMobile ? 1.0 : 1.2);
                directionalLight.position.set(10, 10, 5);
                scene.add(directionalLight);
                
                if (!isMobile) {
                    const pointLight = new THREE.PointLight(0xffa500, 0.8, 50);
                    pointLight.position.set(5, 8, 5);
                    scene.add(pointLight);
                }
                
                const ambientLight = new THREE.AmbientLight(0x404040, isMobile ? 0.6 : 0.4);
                scene.add(ambientLight);
                
                // Enhanced grid system
                createEnhancedGrid();
                createSnapIndicator();
                
                setupEvents();
                
                // Hide main app initially - landing page shows first
                document.getElementById('loading').style.display = 'none';
                document.getElementById('menu-bar').style.display = 'none';
                document.getElementById('status').style.display = 'none';
                document.getElementById('canvas').style.display = 'none';
                
                animate();
                
                updateCircuitInfo();

                // Prevent context menu on long press
                document.addEventListener('contextmenu', function(e) {
                    e.preventDefault();
                    return false;
                });

                // Prevent zoom on double tap
                let lastTouchEnd = 0;
                document.addEventListener('touchend', function (event) {
                    const now = (new Date()).getTime();
                    if (now - lastTouchEnd <= 300) {
                        event.preventDefault();
                    }
                    lastTouchEnd = now;
                }, false);

            } catch (error) {
                console.error('Initialization error:', error);
                document.getElementById('loading').textContent = 'Error loading. Please refresh.';
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            updateFlowParticles();
            updateComponentLabels();
            if (renderer) {
                renderer.render(scene, camera);
            }
        }

        function updateComponentLabels() {
            // Update all component label positions
            components.forEach(component => {
                if (component.updateLabelPosition) {
                    component.updateLabelPosition();
                }
            });
        }

        function updateFlowParticles() {
            currentFlowParticles.forEach((particle, index) => {
                try {
                    if (!particle?.userData?.wire || !particle.userData.isFlowing) {
                        scene.remove(particle);
                        currentFlowParticles.splice(index, 1);
                        return;
                    }
                    
                    const wireData = particle.userData;
                    const wire = wireData.wire;
                    
                    if (!wire || !wire.curve) {
                        scene.remove(particle);
                        currentFlowParticles.splice(index, 1);
                        return;
                    }
                    
                    wireData.progress += wireData.baseSpeed;
                    
                    if (wireData.progress > 1) {
                        wireData.progress = 0;
                    }
                    
                    const position = wire.curve.getPoint(wireData.progress);
                    if (position && position.isVector3) {
                        particle.position.copy(position);
                    }
                    
                } catch (error) {
                    console.error(`Error updating particle ${index}:`, error);
                    scene.remove(particle);
                    currentFlowParticles.splice(index, 1);
                }
            });
        }

        function updateCameraPosition() {
            const x = cameraDistance * Math.cos(cameraAngleY) * Math.cos(cameraAngleX);
            const y = cameraDistance * Math.sin(cameraAngleY);
            const z = cameraDistance * Math.cos(cameraAngleY) * Math.sin(cameraAngleX);
            
            camera.position.set(
                cameraTarget.x + x, 
                cameraTarget.y + y, 
                cameraTarget.z + z
            );
            camera.lookAt(cameraTarget);
        }

        function setupEvents() {
            const canvas = renderer.domElement;
            
            // Touch events with improved handling for Android
            canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
            canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
            canvas.addEventListener('touchend', handleTouchEnd, { passive: false });
            canvas.addEventListener('touchcancel', handleTouchEnd, { passive: false });
            
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseup', handleMouseUp);
            canvas.addEventListener('wheel', handleWheel, { passive: false });
            canvas.addEventListener('contextmenu', e => e.preventDefault());
            
            // Keyboard shortcuts (mainly for desktop)
            if (!isMobile) {
                document.addEventListener('keydown', handleKeyDown);
            }
            
            // Close submenus when clicking outside
            document.addEventListener('click', (e) => {
                if (!e.target.closest('.menu-bar')) {
                    closeAllSubmenus();
                }
                
                // Close edit popup when clicking outside
                if (!e.target.closest('.edit-popup') && !e.target.closest('#canvas')) {
                    if (currentEditComponent) {
                        hideEditPopup();
                    }
                }
            });
            
            window.addEventListener('resize', onResize);
            window.addEventListener('orientationchange', () => {
                setTimeout(onResize, 100); // Delay to ensure orientation change is complete
            });
        }

        function handleKeyDown(e) {
            // Check if user is typing in an input field
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.tagName === 'SELECT') {
                // Handle special keys in edit popup
                if (e.key === 'Enter' && currentEditComponent) {
                    e.preventDefault();
                    saveEdit();
                    return;
                } else if (e.key === 'Escape' && currentEditComponent) {
                    e.preventDefault();
                    cancelEdit();
                    return;
                }
                return;
            }
            
            const key = e.key.toLowerCase();
            const ctrl = e.ctrlKey || e.metaKey;
            
            // Prevent default for our shortcuts
            if (ctrl || ['b', 'r', 'l', 's', 'j', 'w', 't', 'c', ' ', 'h', 'f', 'g'].includes(key)) {
                e.preventDefault();
            }
            
            if (ctrl) {
                switch (key) {
                    case 'z':
                        if (e.shiftKey) {
                            redo();
                        } else {
                            undo();
                        }
                        break;
                    case 'y':
                        redo();
                        break;
                    case 'c':
                        copySelected();
                        break;
                    case 'v':
                        pasteSelected();
                        break;
                    case 's':
                        saveCircuit();
                        break;
                    case 'o':
                        loadCircuit();
                        break;
                    case 'n':
                        newCircuit();
                        break;
                }
            } else {
                switch (key) {
                    case 'b':
                        addComponent('battery');
                        break;
                    case 'r':
                        addComponent('resistor');
                        break;
                    case 'l':
                        addComponent('led');
                        break;
                    case 's':
                        addComponent('switch');
                        break;
                    case 'j':
                        addJunction();
                        break;
                    case 'w':
                        toggleWireMode();
                        break;
                    case 't':
                        toggleRotateMode();
                        break;
                    case 'c':
                        clearAll();
                        break;
                    case ' ':
                        toggleMenuBar();
                        break;
                    case 'h':
                        resetCamera();
                        break;
                    case 'f':
                        fitToScreen();
                        break;
                    case 'g':
                        toggleGrid();
                        break;
                    case 'delete':
                    case 'backspace':
                        deleteSelected();
                        break;
                    case 'escape':
                        if (currentEditComponent) {
                            cancelEdit();
                        }
                        break;
                }
            }
        }

        function handleTouchStart(e) {
            e.preventDefault();
            
            if (e.touches.length === 1) {
                const touch = e.touches[0];
                lastTouchPos = { x: touch.clientX, y: touch.clientY };
                longPressStartPos = { x: touch.clientX, y: touch.clientY };
                
                // Start long press timer
                startLongPressTimer(touch.clientX, touch.clientY);
                
                if (checkComponentHit(touch.clientX, touch.clientY)) {
                    return;
                }
                
                isRotating = true;
                isPanning = false;
                
            } else if (e.touches.length === 2) {
                // Two-finger gesture setup
                cancelLongPress();
                
                const touch1 = e.touches[0];
                const touch2 = e.touches[1];
                
                // Calculate center point for panning
                lastTwoFingerCenter = {
                    x: (touch1.clientX + touch2.clientX) / 2,
                    y: (touch1.clientY + touch2.clientY) / 2
                };
                
                // Calculate distance for pinch-to-zoom
                lastPinchDistance = Math.sqrt(
                    Math.pow(touch2.clientX - touch1.clientX, 2) + 
                    Math.pow(touch2.clientY - touch1.clientY, 2)
                );
                
                isRotating = false;
                isPanning = true;
            }
        }

        function handleTouchMove(e) {
            e.preventDefault();
            
            if (e.touches.length === 1) {
                const touch = e.touches[0];
                
                // Check if moved too far for long press
                const deltaX = Math.abs(touch.clientX - longPressStartPos.x);
                const deltaY = Math.abs(touch.clientY - longPressStartPos.y);
                if ((deltaX > 15 || deltaY > 15) && longPressTimer) {
                    cancelLongPress();
                }
                
                if (isDragging && selectedComponent) {
                    handleComponentDrag(touch.clientX, touch.clientY);
                } else if (isRotating) {
                    const deltaX = touch.clientX - lastTouchPos.x;
                    const deltaY = touch.clientY - lastTouchPos.y;
                    
                    const sensitivity = isMobile ? 0.008 : 0.01;
                    cameraAngleX += deltaX * sensitivity;
                    cameraAngleY = Math.max(-1.5, Math.min(1.5, cameraAngleY - deltaY * sensitivity));
                    updateCameraPosition();
                }
                
                lastTouchPos = { x: touch.clientX, y: touch.clientY };
                
            } else if (e.touches.length === 2 && isPanning) {
                const touch1 = e.touches[0];
                const touch2 = e.touches[1];
                
                // Calculate new center point
                const newCenter = {
                    x: (touch1.clientX + touch2.clientX) / 2,
                    y: (touch1.clientY + touch2.clientY) / 2
                };
                
                // Calculate new distance
                const newDistance = Math.sqrt(
                    Math.pow(touch2.clientX - touch1.clientX, 2) + 
                    Math.pow(touch2.clientY - touch1.clientY, 2)
                );
                
                // Handle pinch-to-zoom
                if (lastPinchDistance > 0) {
                    const pinchDelta = newDistance - lastPinchDistance;
                    const zoomSensitivity = isMobile ? 0.015 : 0.02;
                    cameraDistance = Math.max(5, Math.min(50, cameraDistance - pinchDelta * zoomSensitivity));
                    updateCameraPosition();
                }
                
                // Handle two-finger pan (camera target movement)
                const panDeltaX = newCenter.x - lastTwoFingerCenter.x;
                const panDeltaY = newCenter.y - lastTwoFingerCenter.y;
                
                // Convert screen movement to world movement
                const panSensitivity = cameraDistance * 0.005;
                
                // Calculate camera right and up vectors for proper panning
                const cameraDirection = new THREE.Vector3();
                camera.getWorldDirection(cameraDirection);
                
                const cameraRight = new THREE.Vector3();
                cameraRight.crossVectors(cameraDirection, new THREE.Vector3(0, 1, 0)).normalize();
                
                const cameraUp = new THREE.Vector3();
                cameraUp.crossVectors(cameraRight, cameraDirection).normalize();
                
                // Apply pan movement to camera target
                cameraTarget.add(cameraRight.multiplyScalar(-panDeltaX * panSensitivity));
                cameraTarget.add(cameraUp.multiplyScalar(panDeltaY * panSensitivity));
                
                updateCameraPosition();
                
                // Update stored values
                lastTwoFingerCenter = newCenter;
                lastPinchDistance = newDistance;
            }
        }

        function handleTouchEnd(e) {
            e.preventDefault();
            isRotating = false;
            isPanning = false;
            cancelLongPress();
            
            if (isDragging) {
                handleRelease();
            }
            
            // Reset touch tracking
            lastPinchDistance = 0;
            lastTwoFingerCenter = { x: 0, y: 0 };
        }

        function handleMouseDown(e) {
            if (e.button === 0) {
                longPressStartPos = { x: e.clientX, y: e.clientY };
                startLongPressTimer(e.clientX, e.clientY);
                checkComponentHit(e.clientX, e.clientY);
            } else if (e.button === 2) {
                isRotating = true;
                lastTouchPos = { x: e.clientX, y: e.clientY };
            }
        }

        function handleMouseMove(e) {
            // Check if moved too far for long press
            const deltaX = Math.abs(e.clientX - longPressStartPos.x);
            const deltaY = Math.abs(e.clientY - longPressStartPos.y);
            if ((deltaX > 10 || deltaY > 10) && longPressTimer) {
                cancelLongPress();
            }
            
            if (isRotating) {
                const deltaX = e.clientX - lastTouchPos.x;
                const deltaY = e.clientY - lastTouchPos.y;
                
                cameraAngleX += deltaX * 0.01;
                cameraAngleY = Math.max(-1.5, Math.min(1.5, cameraAngleY - deltaY * 0.01));
                updateCameraPosition();
                
                lastTouchPos = { x: e.clientX, y: e.clientY };
            } else if (isDragging && selectedComponent) {
                handleComponentDrag(e.clientX, e.clientY);
            }
        }

        function handleMouseUp(e) {
            isRotating = false;
            cancelLongPress();
            if (isDragging) {
                handleRelease();
            }
        }

        function handleWheel(e) {
            e.preventDefault();
            const sensitivity = isMobile ? 0.005 : 0.01;
            cameraDistance = Math.max(5, Math.min(50, cameraDistance + e.deltaY * sensitivity));
            updateCameraPosition();
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Grid and snapping functions
        function createEnhancedGrid() {
            // Main grid - reduced complexity for mobile
            const gridSize = isMobile ? 20 : 40;
            const gridDivisions = isMobile ? 20 : 40;
            
            gridHelper = new THREE.GridHelper(gridSize, gridDivisions, 0x333366, 0x111122);
            scene.add(gridHelper);
            
            // Fine grid overlay - only on desktop
            if (!isMobile) {
                const fineGrid = new THREE.GridHelper(gridSize, gridDivisions * 2, 0x222244, 0x0a0a1a);
                fineGrid.position.y = 0.01; // Slightly above main grid
                scene.add(fineGrid);
            }
        }

        function createSnapIndicator() {
            const geometry = new THREE.RingGeometry(0.8, 1.0, 8);
            const material = new THREE.MeshBasicMaterial({ 
                color: 0x00ff88, 
                transparent: true, 
                opacity: 0.8 
            });
            snapIndicator = new THREE.Mesh(geometry, material);
            snapIndicator.rotation.x = -Math.PI / 2;
            snapIndicator.visible = false;
            scene.add(snapIndicator);
        }

        function snapToGrid(position) {
            return new THREE.Vector3(
                Math.round(position.x / GRID_SIZE) * GRID_SIZE,
                0,
                Math.round(position.z / GRID_SIZE) * GRID_SIZE
            );
        }

        function showSnapIndicator(position) {
            if (snapIndicator) {
                const snappedPos = snapToGrid(position);
                snapIndicator.position.copy(snappedPos);
                snapIndicator.visible = true;
            }
        }

        function hideSnapIndicator() {
            if (snapIndicator) {
                snapIndicator.visible = false;
            }
        }

        function createRightAngledWirePath(startPos, endPos) {
            const path = [];
            
            // Snap both positions to grid
            const snappedStart = snapToGrid(startPos);
            const snappedEnd = snapToGrid(endPos);
            
            path.push(snappedStart.clone());
            
            // Professional schematic routing with outside right angles
            const deltaX = snappedEnd.x - snappedStart.x;
            const deltaZ = snappedEnd.z - snappedStart.z;
            
            // Minimum distance for clean routing
            const MIN_SEGMENT = GRID_SIZE * 2;
            
            // Determine routing style based on component positions and circuit aesthetics
            if (Math.abs(deltaX) < MIN_SEGMENT && Math.abs(deltaZ) < MIN_SEGMENT) {
                // Direct connection for very close components
                path.push(snappedEnd.clone());
            } else if (Math.abs(deltaX) > Math.abs(deltaZ) * 2) {
                // Primarily horizontal routing - go out, across, in
                const outDistance = Math.sign(deltaX) * MIN_SEGMENT;
                const midX = snappedStart.x + outDistance;
                
                // Go out from start
                const outPoint = new THREE.Vector3(midX, 0, snappedStart.z);
                if (Math.abs(outDistance) > 0.1) {
                    path.push(outPoint);
                }
                
                // Go to end Z level
                if (Math.abs(deltaZ) > 0.1) {
                    const acrossPoint = new THREE.Vector3(midX, 0, snappedEnd.z);
                    path.push(acrossPoint);
                }
                
                // Go to final X position if needed
                if (Math.abs(snappedEnd.x - midX) > 0.1) {
                    const inPoint = new THREE.Vector3(snappedEnd.x - Math.sign(deltaX) * MIN_SEGMENT, 0, snappedEnd.z);
                    path.push(inPoint);
                }
                
            } else if (Math.abs(deltaZ) > Math.abs(deltaX) * 2) {
                // Primarily vertical routing - go out, across, in
                const outDistance = Math.sign(deltaZ) * MIN_SEGMENT;
                const midZ = snappedStart.z + outDistance;
                
                // Go out from start
                const outPoint = new THREE.Vector3(snappedStart.x, 0, midZ);
                if (Math.abs(outDistance) > 0.1) {
                    path.push(outPoint);
                }
                
                // Go to end X level
                if (Math.abs(deltaX) > 0.1) {
                    const acrossPoint = new THREE.Vector3(snappedEnd.x, 0, midZ);
                    path.push(acrossPoint);
                }
                
                // Go to final Z position if needed
                if (Math.abs(snappedEnd.z - midZ) > 0.1) {
                    const inPoint = new THREE.Vector3(snappedEnd.x, 0, snappedEnd.z - Math.sign(deltaZ) * MIN_SEGMENT);
                    path.push(inPoint);
                }
                
            } else {
                // Balanced routing - professional L-shape with extensions
                const preferHorizontalFirst = Math.abs(deltaX) >= Math.abs(deltaZ);
                
                if (preferHorizontalFirst) {
                    // Go out horizontally, then vertically, then in
                    const midX = snappedStart.x + Math.sign(deltaX) * (Math.abs(deltaX) * 0.7 + MIN_SEGMENT);
                    
                    // Horizontal extension from start
                    const hPoint = new THREE.Vector3(midX, 0, snappedStart.z);
                    path.push(hPoint);
                    
                    // Vertical to end level
                    if (Math.abs(deltaZ) > 0.1) {
                        const vPoint = new THREE.Vector3(midX, 0, snappedEnd.z);
                        path.push(vPoint);
                    }
                    
                } else {
                    // Go out vertically, then horizontally, then in
                    const midZ = snappedStart.z + Math.sign(deltaZ) * (Math.abs(deltaZ) * 0.7 + MIN_SEGMENT);
                    
                    // Vertical extension from start
                    const vPoint = new THREE.Vector3(snappedStart.x, 0, midZ);
                    path.push(vPoint);
                    
                    // Horizontal to end level
                    if (Math.abs(deltaX) > 0.1) {
                        const hPoint = new THREE.Vector3(snappedEnd.x, 0, midZ);
                        path.push(hPoint);
                    }
                }
            }
            
            path.push(snappedEnd.clone());
            
            // Remove any duplicate consecutive points
            const cleanPath = [path[0]];
            for (let i = 1; i < path.length; i++) {
                const prev = cleanPath[cleanPath.length - 1];
                const curr = path[i];
                if (prev.distanceTo(curr) > 0.1) {
                    cleanPath.push(curr);
                }
            }
            
            return cleanPath;
        }

        // Auto-arrange circuit for professional schematic layout
        function arrangeCircuitSchematic() {
            if (components.length === 0) return;
            
            saveState(); // Save for undo
            
            // Find batteries (power sources)
            const batteries = components.filter(c => c.type === 'battery');
            const otherComponents = components.filter(c => c.type !== 'battery');
            
            if (batteries.length === 0) {
                setStatus(' Add a battery first for schematic arrangement');
                return;
            }
            
            // Clear existing wires for clean re-routing
            wires.forEach(wire => wire.remove());
            wires = [];
            
            // Arrange components in schematic style
            const SPACING = GRID_SIZE * 4;
            const battery = batteries[0];
            
            // Position battery on the left
            battery.position.set(-SPACING * 2, 0, 0);
            battery.mesh.position.copy(battery.position);
            
            // Arrange other components in a logical flow
            otherComponents.forEach((comp, index) => {
                const angle = (index / otherComponents.length) * Math.PI * 1.5;
                const radius = SPACING * 1.5;
                const x = Math.cos(angle) * radius;
                const z = Math.sin(angle) * radius;
                
                comp.position.set(
                    snapToGrid(new THREE.Vector3(x, 0, z)).x,
                    0,
                    snapToGrid(new THREE.Vector3(x, 0, z)).z
                );
                comp.mesh.position.copy(comp.position);
            });
            
            // Auto-wire in series for demonstration
            if (otherComponents.length > 0) {
                // Connect battery positive to first component
                const firstComp = otherComponents[0];
                const wire1 = new Wire(battery, 'positive', firstComp, 'left');
                wires.push(wire1);
                
                // Connect components in series
                for (let i = 0; i < otherComponents.length - 1; i++) {
                    const comp1 = otherComponents[i];
                    const comp2 = otherComponents[i + 1];
                    const wire = new Wire(comp1, 'right', comp2, 'left');
                    wires.push(wire);
                }
                
                // Connect last component back to battery negative
                const lastComp = otherComponents[otherComponents.length - 1];
                const wire2 = new Wire(lastComp, 'right', battery, 'negative');
                wires.push(wire2);
            }
            
            // Center the view on the circuit
            fitToScreen();
            analyzeCircuit();
            setStatus(' Circuit arranged in professional schematic layout with intelligent routing!');
        }

        // Launch application function
        function launchApplication() {
            const landingPage = document.getElementById('landing-page');
            const launchBtn = document.getElementById('launch-btn');
            const loadingProgress = document.getElementById('loading-progress');
            const loadingText = document.getElementById('loading-text');
            
            // Hide launch button and show loading
            launchBtn.style.display = 'none';
            loadingProgress.style.display = 'block';
            loadingText.style.display = 'block';
            
            // Simulate loading and launch main app
            setTimeout(() => {
                landingPage.classList.add('landing-hidden');
                
                setTimeout(() => {
                    landingPage.style.display = 'none';
                    
                    // Initialize the main application
                    document.getElementById('menu-bar').style.display = 'block';
                    document.getElementById('status').style.display = 'block';
                    document.getElementById('canvas').style.display = 'block';
                    
                    // Set initial status for CircuiTry
                    setStatus(' CircuiTry Professional Circuit Design Environment Ready!');
                }, 500);
            }, 2000);
        }

        // Long press detection functions
        function startLongPressTimer(clientX, clientY) {
            cancelLongPress(); // Clear any existing timer
            
            longPressTimer = setTimeout(() => {
                isLongPressing = true;
                handleLongPress(clientX, clientY);
            }, LONG_PRESS_DURATION);
        }

        function cancelLongPress() {
            if (longPressTimer) {
                clearTimeout(longPressTimer);
                longPressTimer = null;
            }
            isLongPressing = false;
        }

        function handleLongPress(clientX, clientY) {
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((clientY - rect.top) / rect.height) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            
            // Check for component selection boxes
            const selectionBoxes = [];
            components.forEach(comp => {
                if (comp?.selectionBox) {
                    selectionBoxes.push(comp.selectionBox);
                }
            });
            
            const componentHits = raycaster.intersectObjects(selectionBoxes, false);
            if (componentHits.length > 0) {
                const hitBox = componentHits[0].object;
                if (hitBox.userData?.component) {
                    showEditPopup(hitBox.userData.component, clientX, clientY);
                    
                    // Add haptic feedback for mobile devices
                    if (navigator.vibrate && isMobile) {
                        navigator.vibrate(50);
                    }
                    return;
                }
            }
            
            // Check for junctions
            const selectionSpheres = [];
            junctions.forEach(junction => {
                if (junction?.selectionSphere) {
                    selectionSpheres.push(junction.selectionSphere);
                }
            });
            
            const junctionHits = raycaster.intersectObjects(selectionSpheres, false);
            if (junctionHits.length > 0) {
                const hitSphere = junctionHits[0].object;
                if (hitSphere.userData?.junction) {
                    // Junctions don't have editable properties currently
                    setStatus(' Junctions have no editable properties');
                    return;
                }
            }
        }

        // Edit popup functions
        function showEditPopup(component, clientX, clientY) {
            currentEditComponent = component;
            const popup = document.getElementById('edit-popup');
            const title = document.getElementById('edit-title');
            const content = document.getElementById('edit-content');
            
            if (!popup || !title || !content) return;
            
            // Set title
            title.textContent = `Edit ${component.type.charAt(0).toUpperCase() + component.type.slice(1)}`;
            
            // Create edit form based on component type
            content.innerHTML = createEditForm(component);
            
            // Show popup centered on screen for mobile
            popup.style.display = 'block';
            
            // Focus first input with delay for mobile keyboards
            const firstInput = popup.querySelector('input');
            if (firstInput && !isMobile) {
                setTimeout(() => firstInput.focus(), 100);
            }
            
            setStatus(` Editing ${component.type} - Long press to edit components!`);
        }

        function createEditForm(component) {
            let formHTML = '';
            
            switch (component.type) {
                case 'battery':
                    formHTML = `
                        <div class="edit-row">
                            <label> Voltage (V)</label>
                            <input type="number" id="edit-voltage" value="${component.properties.voltage}" min="0" max="24" step="0.1">
                        </div>
                    `;
                    break;
                    
                case 'resistor':
                    formHTML = `
                        <div class="edit-row">
                            <label> Resistance ()</label>
                            <input type="number" id="edit-resistance" value="${component.properties.resistance}" min="1" max="10000" step="1">
                        </div>
                    `;
                    break;
                    
                case 'led':
                    formHTML = `
                        <div class="edit-row">
                            <label> Forward Resistance ()</label>
                            <input type="number" id="edit-resistance" value="${component.properties.resistance}" min="1" max="1000" step="1">
                        </div>
                    `;
                    break;
                    
                case 'switch':
                    formHTML = `
                        <div class="edit-row">
                            <label> Switch State</label>
                            <select id="edit-switch-state">
                                <option value="true" ${component.properties.isOn ? 'selected' : ''}>ON (Closed)</option>
                                <option value="false" ${!component.properties.isOn ? 'selected' : ''}>OFF (Open)</option>
                            </select>
                        </div>
                        <div class="edit-row">
                            <label> Contact Resistance ()</label>
                            <input type="number" id="edit-resistance" value="${component.properties.resistance}" min="0.01" max="10" step="0.01">
                        </div>
                    `;
                    break;
                    
                default:
                    formHTML = '<div class="edit-row">No editable properties</div>';
            }
            
            return formHTML;
        }

        function saveEdit() {
            if (!currentEditComponent) return;
            
            const popup = document.getElementById('edit-popup');
            if (!popup) return;
            
            saveState(); // Save for undo
            
            const newProperties = {};
            
            switch (currentEditComponent.type) {
                case 'battery':
                    const voltageInput = document.getElementById('edit-voltage');
                    if (voltageInput) {
                        newProperties.voltage = parseFloat(voltageInput.value) || 0;
                    }
                    break;
                    
                case 'resistor':
                case 'led':
                    const resistanceInput = document.getElementById('edit-resistance');
                    if (resistanceInput) {
                        newProperties.resistance = parseFloat(resistanceInput.value) || 1;
                    }
                    break;
                    
                case 'switch':
                    const switchStateSelect = document.getElementById('edit-switch-state');
                    const switchResistanceInput = document.getElementById('edit-resistance');
                    if (switchStateSelect) {
                        newProperties.isOn = switchStateSelect.value === 'true';
                    }
                    if (switchResistanceInput) {
                        newProperties.resistance = parseFloat(switchResistanceInput.value) || 0.1;
                    }
                    break;
            }
            
            // Update component properties
            currentEditComponent.updateProperties(newProperties);
            
            // Hide popup
            hideEditPopup();
            
            // Recalculate circuit
            analyzeCircuit();
            
            const componentType = currentEditComponent.type;
            setStatus(` ${componentType.charAt(0).toUpperCase() + componentType.slice(1)} updated successfully!`);
        }

        function cancelEdit() {
            hideEditPopup();
            setStatus(' Edit cancelled');
        }

        function hideEditPopup() {
            const popup = document.getElementById('edit-popup');
            if (popup) {
                popup.style.display = 'none';
            }
            currentEditComponent = null;
        }

        function checkComponentHit(clientX, clientY) {
            // If we're in the middle of a long press, don't handle regular clicks
            if (isLongPressing) {
                return false;
            }
            
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((clientY - rect.top) / rect.height) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            
            // Check connection points
            const connectionPoints = [];
            components.forEach(comp => {
                if (comp?.connectionPoints) {
                    connectionPoints.push(...comp.connectionPoints);
                }
            });
            junctions.forEach(junction => {
                if (junction?.connectionPoint) {
                    connectionPoints.push(junction.connectionPoint);
                }
            });
            
            const connectionHits = raycaster.intersectObjects(connectionPoints, false);
            if (connectionHits.length > 0) {
                const hitPoint = connectionHits[0].object;
                if (hitPoint.userData?.isConnectionPoint) {
                    handleConnectionPointClick(hitPoint.userData);
                    return true;
                }
            }
            
            // Check component selection boxes
            if (!isWireMode) {
                const selectionBoxes = [];
                components.forEach(comp => {
                    if (comp?.selectionBox) {
                        selectionBoxes.push(comp.selectionBox);
                    }
                });
                junctions.forEach(junction => {
                    if (junction?.selectionSphere) {
                        selectionBoxes.push(junction.selectionSphere);
                    }
                });
                
                const componentHits = raycaster.intersectObjects(selectionBoxes, false);
                if (componentHits.length > 0) {
                    const hitBox = componentHits[0].object;
                    if (hitBox.userData?.component) {
                        handleComponentClick(hitBox.userData.component);
                        return true;
                    }
                    if (hitBox.userData?.junction) {
                        handleJunctionClick(hitBox.userData.junction);
                        return true;
                    }
                }
            }
            
            handleGroundClick(clientX, clientY);
            return false;
        }

        function handleConnectionPointClick(pointData) {
            if (!isWireMode) {
                const terminalInfo = getTerminalInfo(pointData);
                const objectType = pointData.component ? pointData.component.type : 'junction';
                setStatus(` ${objectType} ${terminalInfo} - Enable  Wire mode to connect!`);
                return;
            }
            
            if (!wireStart) {
                wireStart = pointData;
                highlightConnectionPoint(pointData, true);
                
                const terminalInfo = getTerminalInfo(pointData);
                const objectType = pointData.component ? pointData.component.type : 'junction';
                setStatus(` FIRST: ${objectType} ${terminalInfo} - Click another terminal!`);
                
            } else {
                const sameObject = (wireStart.component && pointData.component && wireStart.component === pointData.component) ||
                                  (wireStart.junction && pointData.junction && wireStart.junction === pointData.junction);
                
                if (sameObject) {
                    setStatus(' Cannot connect terminal to itself!');
                    return;
                }
                
                createWire(wireStart, pointData);
                highlightConnectionPoint(wireStart, false);
                wireStart = null;
            }
        }

        function createWire(startPoint, endPoint) {
            if (!startPoint || !endPoint) return;
            
            const startObj = startPoint.component || startPoint.junction;
            const endObj = endPoint.component || endPoint.junction;
            
            if (!startObj || !endObj) return;
            
            const existingWire = wires.find(wire => 
                (wire.startObj === startObj && wire.startSide === startPoint.side &&
                 wire.endObj === endObj && wire.endSide === endPoint.side) ||
                (wire.startObj === endObj && wire.startSide === endPoint.side &&
                 wire.endObj === startObj && wire.endSide === startPoint.side)
            );
            
            if (existingWire) {
                setStatus(' Wire already exists between these terminals');
                return;
            }
            
            try {
                saveState(); // Save for undo
                const wire = new Wire(startObj, startPoint.side, endObj, endPoint.side);
                wires.push(wire);
                
                const startType = startObj.type || 'junction';
                const endType = endObj.type || 'junction';
                setStatus(` Wire connected ${startType}  ${endType}!`);
                
                analyzeCircuit();
                
            } catch (error) {
                console.error('Wire creation error:', error);
                setStatus(' Wire creation failed');
            }
        }

        function getTerminalInfo(pointData) {
            if (pointData.junction) return 'JUNCTION (PURPLE)';
            
            switch (pointData.polarity) {
                case 'positive': return 'POSITIVE (RED)';
                case 'negative': return 'NEGATIVE (GRAY)';
                default: return 'NEUTRAL (WHITE)';
            }
        }

        function highlightConnectionPoint(pointData, highlight) {
            let connectionPoint;
            
            if (pointData.component) {
                connectionPoint = pointData.component.connectionPoints?.find(point => 
                    point.userData?.side === pointData.side
                );
            } else if (pointData.junction) {
                connectionPoint = pointData.junction.connectionPoint;
            }
            
            if (!connectionPoint?.material) return;
            
            if (highlight) {
                connectionPoint.material.color.setRGB(1.0, 1.0, 0.0);
                connectionPoint.material.emissive.setRGB(0.8, 0.8, 0.0);
                connectionPoint.scale.setScalar(2.0);
            } else {
                if (pointData.junction) {
                    connectionPoint.material.color.setRGB(0.67, 0.4, 1.0);
                    connectionPoint.material.emissive.setRGB(0.2, 0.1, 0.4);
                } else {
                    const originalColor = getOriginalColor(pointData.polarity);
                    connectionPoint.material.color.copy(originalColor);
                    setOriginalEmissive(connectionPoint, pointData.polarity);
                }
                connectionPoint.scale.setScalar(1.0);
            }
        }

        function getOriginalColor(polarity) {
            switch (polarity) {
                case 'positive': return new THREE.Color(1, 0, 0);
                case 'negative': return new THREE.Color(0.3, 0.3, 0.3);
                default: return new THREE.Color(1, 1, 1);
            }
        }

        function setOriginalEmissive(point, polarity) {
            switch (polarity) {
                case 'positive':
                    point.material.emissive.setRGB(0.3, 0.0, 0.0);
                    break;
                case 'negative':
                    point.material.emissive.setRGB(0.1, 0.1, 0.1);
                    break;
                default:
                    point.material.emissive.setRGB(0.2, 0.2, 0.2);
            }
        }

        function handleComponentClick(component) {
            if (isRotateMode) {
                saveState(); // Save for undo
                const rotationAmount = Math.PI / 2;
                component.rotation += rotationAmount;
                component.mesh.rotation.y = component.rotation;
                
                component.mesh.scale.setScalar(1.5);
                setTimeout(() => {
                    component.mesh.scale.setScalar(1.0);
                }, 500);
                
                const rotationDegrees = Math.round((component.rotation * 180 / Math.PI) % 360);
                setStatus(` ${component.type.toUpperCase()} ROTATED 90! Now at ${rotationDegrees}`);
                
                if (component.connections) {
                    component.connections.forEach(conn => {
                        if (conn.wire && conn.wire.updatePath) {
                            conn.wire.updatePath();
                        }
                    });
                }
                
                analyzeCircuit();
                
            } else if (component.type === 'switch' && !isWireMode) {
                saveState(); // Save for undo
                component.properties.isOn = !component.properties.isOn;
                component.updateProperties({ isOn: component.properties.isOn });
                const state = component.properties.isOn ? 'ON' : 'OFF';
                setStatus(` Switch ${state} - circuit updated`);
                analyzeCircuit();
            } else if (!isWireMode && !isDragging) {
                selectComponent(component);
            }
        }

        function handleJunctionClick(junction) {
            if (!isWireMode && !isDragging) {
                selectJunction(junction);
            }
        }

        function selectComponent(component) {
            selectedComponent = component;
            isDragging = true;
            setStatus(` Dragging ${component.type} - tap to place`);
        }

        function selectJunction(junction) {
            selectedComponent = junction;
            isDragging = true;
            setStatus(` Dragging junction - tap to place`);
        }

        function handleGroundClick(clientX, clientY) {
            if (!isWireMode) {
                const worldPos = screenToWorld(clientX, clientY);
                if (worldPos && selectedComponent && isDragging) {
                    const snappedPos = snapToGrid(worldPos);
                    
                    if (selectedComponent.mesh) {
                        selectedComponent.mesh.position.copy(snappedPos);
                        selectedComponent.position.copy(snappedPos);
                    }
                    
                    const placedComponent = selectedComponent;
                    handleRelease();
                    
                    const objType = placedComponent.type || 'junction';
                    setStatus(` ${objType} placed at grid position!`);
                    
                    if (placedComponent.connections) {
                        placedComponent.connections.forEach(conn => {
                            if (conn.wire && conn.wire.updatePath) {
                                conn.wire.updatePath();
                            }
                        });
                    }
                }
            }
        }

        function screenToWorld(clientX, clientY) {
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((clientY - rect.top) / rect.height) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            
            const groundPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
            const intersection = new THREE.Vector3();
            
            if (raycaster.ray.intersectPlane(groundPlane, intersection)) {
                return intersection;
            }
            return null;
        }

        function handleComponentDrag(clientX, clientY) {
            const worldPos = screenToWorld(clientX, clientY);
            if (worldPos && selectedComponent) {
                const snappedPos = snapToGrid(worldPos);
                showSnapIndicator(snappedPos);
                
                if (selectedComponent.mesh) {
                    selectedComponent.mesh.position.copy(snappedPos);
                    selectedComponent.position.copy(snappedPos);
                }
            }
        }

        function handleRelease() {
            isDragging = false;
            hideSnapIndicator();
            
            if (selectedComponent) {
                // Final snap to grid
                const snappedPos = snapToGrid(selectedComponent.position);
                selectedComponent.position.copy(snappedPos);
                if (selectedComponent.mesh) {
                    selectedComponent.mesh.position.copy(snappedPos);
                }
                
                // Update any connected wires
                if (selectedComponent.connections) {
                    selectedComponent.connections.forEach(conn => {
                        if (conn.wire && conn.wire.updatePath) {
                            conn.wire.updatePath();
                        }
                    });
                }
            }
            
            selectedComponent = null;
        }

        // Menu system functions
        function toggleMenuBar() {
            const menuBar = document.getElementById('menu-bar');
            const toggle = document.getElementById('menu-toggle');
            
            if (!menuBar || !toggle) return;
            
            menuBar.classList.toggle('hidden');
            menuVisible = !menuVisible;
            
            if (menuVisible) {
                toggle.textContent = '';
                setStatus(' Menu shown - all tools available');
            } else {
                toggle.textContent = '';
                setStatus(' Menu hidden - click  to show');
                closeAllSubmenus();
            }
        }

        function toggleSubmenu(menuName) {
            const allSubmenus = document.querySelectorAll('.submenu');
            const targetSubmenu = document.getElementById(`submenu-${menuName}`);
            const allTabs = document.querySelectorAll('.menu-tab');
            
            // Close all other submenus
            allSubmenus.forEach(submenu => {
                if (submenu !== targetSubmenu) {
                    submenu.classList.remove('active');
                }
            });
            
            // Remove active class from all tabs
            allTabs.forEach(tab => {
                if (!tab.querySelector(`#submenu-${menuName}`)) {
                    tab.classList.remove('active');
                }
            });
            
            // Toggle target submenu
            if (targetSubmenu) {
                const isActive = targetSubmenu.classList.contains('active');
                targetSubmenu.classList.toggle('active');
                
                // Toggle tab active state
                const parentTab = targetSubmenu.closest('.menu-tab');
                if (parentTab) {
                    parentTab.classList.toggle('active', !isActive);
                }
            }
        }

        function closeAllSubmenus() {
            document.querySelectorAll('.submenu').forEach(submenu => {
                submenu.classList.remove('active');
            });
            document.querySelectorAll('.menu-tab').forEach(tab => {
                tab.classList.remove('active');
            });
        }

        function toggleAnalysis() {
            const panel = document.getElementById('wire-analysis');
            if (!panel) return;
            
            panel.classList.toggle('collapsed');
            analysisVisible = !panel.classList.contains('collapsed');
            
            if (analysisVisible) {
                setStatus(' W.I.R.E. Analysis panel expanded');
            } else {
                setStatus(' W.I.R.E. Analysis panel collapsed');
            }
        }

        // State management functions
        function saveState() {
            const state = {
                components: components.map(comp => ({
                    type: comp.type,
                    position: comp.position.toArray(),
                    rotation: comp.rotation,
                    properties: comp.properties,
                    componentNumber: comp.componentNumber,
                    id: comp.id
                })),
                junctions: junctions.map(junction => ({
                    position: junction.position.toArray(),
                    id: junction.id
                })),
                wires: wires.map(wire => ({
                    startId: wire.startObj.id,
                    startSide: wire.startSide,
                    endId: wire.endObj.id,
                    endSide: wire.endSide,
                    id: wire.id
                })),
                componentCounters: { ...componentCounters }
            };
            
            undoStack.push(JSON.stringify(state));
            if (undoStack.length > 50) {
                undoStack.shift(); // Keep only last 50 states
            }
            redoStack = []; // Clear redo stack when new action is performed
            updateUndoRedoButtons();
        }

        function undo() {
            if (undoStack.length === 0) {
                setStatus(' Nothing to undo');
                return;
            }
            
            // Save current state to redo stack
            redoStack.push(getCurrentStateString());
            
            // Restore previous state
            const previousState = undoStack.pop();
            restoreState(JSON.parse(previousState));
            
            updateUndoRedoButtons();
            setStatus(' Undo completed');
        }

        function redo() {
            if (redoStack.length === 0) {
                setStatus(' Nothing to redo');
                return;
            }
            
            // Save current state to undo stack
            undoStack.push(getCurrentStateString());
            
            // Restore redo state
            const redoState = redoStack.pop();
            restoreState(JSON.parse(redoState));
            
            updateUndoRedoButtons();
            setStatus(' Redo completed');
        }

        function getCurrentStateString() {
            const state = {
                components: components.map(comp => ({
                    type: comp.type,
                    position: comp.position.toArray(),
                    rotation: comp.rotation,
                    properties: comp.properties,
                    componentNumber: comp.componentNumber,
                    id: comp.id
                })),
                junctions: junctions.map(junction => ({
                    position: junction.position.toArray(),
                    id: junction.id
                })),
                wires: wires.map(wire => ({
                    startId: wire.startObj.id,
                    startSide: wire.startSide,
                    endId: wire.endObj.id,
                    endSide: wire.endSide,
                    id: wire.id
                })),
                componentCounters: { ...componentCounters }
            };
            return JSON.stringify(state);
        }

        function restoreState(state) {
            // Clear current circuit
            clearAll(false); // Don't save state during clear
            
            // Restore component counters
            if (state.componentCounters) {
                componentCounters = { ...state.componentCounters };
            }
            
            // Restore components
            state.components.forEach(compData => {
                const position = new THREE.Vector3().fromArray(compData.position);
                const component = new Component(compData.type, position);
                component.rotation = compData.rotation;
                component.properties = compData.properties;
                component.id = compData.id;
                
                // Restore component numbering if available
                if (compData.componentNumber) {
                    component.componentNumber = compData.componentNumber;
                }
                
                component.mesh.rotation.y = component.rotation;
                component.updateProperties(component.properties);
                components.push(component);
            });
            
            // Restore junctions
            state.junctions.forEach(junctionData => {
                const position = new THREE.Vector3().fromArray(junctionData.position);
                const junction = new Junction(position);
                junction.id = junctionData.id;
                junctions.push(junction);
            });
            
            // Restore wires
            state.wires.forEach(wireData => {
                const startObj = [...components, ...junctions].find(obj => obj.id === wireData.startId);
                const endObj = [...components, ...junctions].find(obj => obj.id === wireData.endId);
                
                if (startObj && endObj) {
                    const wire = new Wire(startObj, wireData.startSide, endObj, wireData.endSide);
                    wire.id = wireData.id;
                    wires.push(wire);
                }
            });
            
            analyzeCircuit();
            updateCircuitInfo();
        }

        function updateUndoRedoButtons() {
            const undoBtn = document.getElementById('undo-btn');
            const redoBtn = document.getElementById('redo-btn');
            
            if (undoBtn) {
                undoBtn.style.opacity = undoStack.length > 0 ? '1.0' : '0.5';
                undoBtn.disabled = undoStack.length === 0;
            }
            
            if (redoBtn) {
                redoBtn.style.opacity = redoStack.length > 0 ? '1.0' : '0.5';
                redoBtn.disabled = redoStack.length === 0;
            }
        }

        // File operations
        function saveCircuit() {
            const state = {
                components: components.map(comp => ({
                    type: comp.type,
                    position: comp.position.toArray(),
                    rotation: comp.rotation,
                    properties: comp.properties,
                    componentNumber: comp.componentNumber,
                    id: comp.id
                })),
                junctions: junctions.map(junction => ({
                    position: junction.position.toArray(),
                    id: junction.id
                })),
                wires: wires.map(wire => ({
                    startId: wire.startObj.id,
                    startSide: wire.startSide,
                    endId: wire.endObj.id,
                    endSide: wire.endSide,
                    id: wire.id
                })),
                componentCounters: { ...componentCounters },
                metadata: {
                    created: new Date().toISOString(),
                    app: 'W.I.R.E. Circuit Builder',
                    version: '2.0'
                }
            };
            
            const dataStr = JSON.stringify(state, null, 2);
            const dataBlob = new Blob([dataStr], {type: 'application/json'});
            
            const link = document.createElement('a');
            link.href = URL.createObjectURL(dataBlob);
            link.download = `circuit_${new Date().toISOString().slice(0,19).replace(/:/g, '-')}.json`;
            link.click();
            
            setStatus(' Circuit saved with W.I.R.E. labels and component numbering!');
        }

        function loadCircuit() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            
            input.onchange = function(event) {
                const file = event.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const state = JSON.parse(e.target.result);
                        restoreState(state);
                        setStatus(' Circuit loaded successfully with W.I.R.E. labels!');
                    } catch (error) {
                        console.error('Load error:', error);
                        setStatus(' Failed to load circuit file');
                    }
                };
                reader.readAsText(file);
            };
            
            input.click();
        }

        function newCircuit() {
            if (components.length > 0 || wires.length > 0 || junctions.length > 0) {
                if (confirm('Create new circuit? This will clear your current work.')) {
                    clearAll();
                    setStatus(' New circuit created');
                }
            } else {
                setStatus(' Circuit is already empty');
            }
        }

        function exportImage() {
            // Temporarily hide UI elements
            const menuBar = document.getElementById('menu-bar');
            const wireAnalysis = document.getElementById('wire-analysis');
            const status = document.getElementById('status');
            const menuToggle = document.getElementById('menu-toggle');
            
            menuBar.style.display = 'none';
            wireAnalysis.style.display = 'none';
            status.style.display = 'none';
            menuToggle.style.display = 'none';
            
            // Render and export
            renderer.render(scene, camera);
            
            const link = document.createElement('a');
            link.download = `circuit_export_${new Date().toISOString().slice(0,19).replace(/:/g, '-')}.png`;
            link.href = renderer.domElement.toDataURL();
            link.click();
            
            // Restore UI elements
            menuBar.style.display = 'block';
            wireAnalysis.style.display = 'block';
            menuToggle.style.display = 'flex';
            
            setStatus(' Circuit image exported!');
        }

        // Selection and clipboard functions
        function selectAll() {
            selectedComponents.clear();
            components.forEach(comp => selectedComponents.add(comp));
            junctions.forEach(junction => selectedComponents.add(junction));
            
            setStatus(` Selected ${selectedComponents.size} objects`);
        }

        function copySelected() {
            if (selectedComponents.size === 0) {
                setStatus(' No objects selected to copy');
                return;
            }
            
            clipboard = {
                components: [],
                junctions: [],
                wires: []
            };
            
            selectedComponents.forEach(obj => {
                if (obj.type) { // Component
                    clipboard.components.push({
                        type: obj.type,
                        position: obj.position.toArray(),
                        rotation: obj.rotation,
                        properties: obj.properties,
                        originalId: obj.id
                    });
                } else if (obj.id && obj.id.startsWith('junction')) { // Junction
                    clipboard.junctions.push({
                        position: obj.position.toArray(),
                        originalId: obj.id
                    });
                }
            });
            
            setStatus(` Copied ${selectedComponents.size} objects`);
        }

        function pasteSelected() {
            if (!clipboard || (clipboard.components.length === 0 && clipboard.junctions.length === 0)) {
                setStatus(' Nothing to paste');
                return;
            }
            
            selectedComponents.clear();
            const offset = new THREE.Vector3(2, 0, 2); // Offset for pasted objects
            
            // Paste components
            clipboard.components.forEach(compData => {
                const position = new THREE.Vector3().fromArray(compData.position).add(offset);
                const component = new Component(compData.type, position);
                component.rotation = compData.rotation;
                component.properties = { ...compData.properties };
                component.mesh.rotation.y = component.rotation;
                component.updateProperties(component.properties);
                components.push(component);
                selectedComponents.add(component);
            });
            
            // Paste junctions
            clipboard.junctions.forEach(junctionData => {
                const position = new THREE.Vector3().fromArray(junctionData.position).add(offset);
                const junction = new Junction(position);
                junctions.push(junction);
                selectedComponents.add(junction);
            });
            
            updateCircuitInfo();
            setStatus(` Pasted ${selectedComponents.size} objects`);
        }

        function deleteSelected() {
            if (selectedComponents.size === 0) {
                setStatus(' No objects selected to delete');
                return;
            }
            
            saveState(); // Save for undo
            
            selectedComponents.forEach(obj => {
                if (obj.remove) {
                    obj.remove();
                }
            });
            
            selectedComponents.clear();
            updateCircuitInfo();
            setStatus(' Selected objects deleted');
        }

        // View functions
        function resetCamera() {
            cameraDistance = 15;
            cameraAngleX = 0;
            cameraAngleY = 0.5;
            cameraTarget.set(0, 0, 0);
            updateCameraPosition();
            setStatus(' Camera view reset');
        }

        function fitToScreen() {
            if (components.length === 0 && junctions.length === 0) {
                resetCamera();
                return;
            }
            
            // Calculate bounding box of all objects
            const box = new THREE.Box3();
            components.forEach(comp => {
                if (comp.mesh) box.expandByObject(comp.mesh);
            });
            junctions.forEach(junction => {
                if (junction.mesh) box.expandByObject(junction.mesh);
            });
            
            const center = box.getCenter(new THREE.Vector3());
            const size = box.getSize(new THREE.Vector3());
            const maxDim = Math.max(size.x, size.y, size.z);
            
            cameraTarget.copy(center);
            cameraDistance = Math.max(10, maxDim * 2);
            updateCameraPosition();
            
            setStatus(' View fitted to circuit');
        }

        function toggleGrid() {
            if (gridHelper) {
                gridHelper.visible = !gridHelper.visible;
                showGrid = gridHelper.visible;
                
                // Also toggle the fine grid
                const fineGrid = scene.children.find(child => 
                    child.type === 'GridHelper' && child !== gridHelper
                );
                if (fineGrid) {
                    fineGrid.visible = gridHelper.visible;
                }
                
                setStatus(` Grid ${showGrid ? 'shown' : 'hidden'} - Components snap to grid points`);
            }
        }

        function toggleLabels() {
            showLabels = !showLabels;
            components.forEach(component => {
                if (component.labelDiv) {
                    component.labelDiv.style.display = showLabels ? 'block' : 'none';
                }
            });
            setStatus(` Component labels ${showLabels ? 'enabled' : 'disabled'}`);
        }

        // Help functions
        function showTutorial() {
            const tutorial = `
 W.I.R.E. CIRCUIT BUILDER TUTORIAL

 VISUAL W.I.R.E. LEARNING:
 Components auto-labeled: B1, R1, LED1, SW1
 Real-time values displayed with color coding:
   Blue = Power (Watts)
   Orange = Current (Amps)  
   Green = Resistance (Ohms)
   Red = Voltage (Volts)

 BUILDING CIRCUITS:
1.  COMPONENTS: Add batteries, resistors, LEDs, and switches
2.  GRID SNAPPING: All components automatically snap to grid points
3.  SMART WIRES: Wires route intelligently with right angles
4.  EDIT VALUES: Long press any component to edit its properties!
5.  ROTATE: Click components to rotate them 90
6.  JUNCTIONS: Add purple connection nodes for complex circuits

 EDUCATIONAL FEATURES:
 See electrical values in real-time on every component
 Watch current flow animation through the circuit
 Learn W.I.R.E. methodology visually
 Professional grid-based layout like real CAD tools

 Perfect for visual learners - see the math come alive!

 MOBILE CONTROLS:
 Touch to select and drag components
 Two-finger pinch to zoom
 Single finger drag to rotate view
 Long press to edit component values
            `;
            alert(tutorial);
        }

        function showWireGuide() {
            const guide = `
 W.I.R.E. METHOD GUIDE

 Educational Framework for Circuit Analysis:

W = WATTS (Power) -  BLUE
 P = V  I (Voltage  Current)
 Measures energy consumption
 Higher power = brighter LEDs, more heat

I = CURRENT (Amperes) -  ORANGE
 Flow of electrons through circuit
 I = V / R (Ohm's Law)
 Animated particles show current flow

R = RESISTANCE (Ohms) -  GREEN
 Opposition to current flow
 Total resistance affects current
 Add resistors to control current

E = EMF/VOLTAGE (Volts) -  RED
 Electrical pressure from battery
 Drives current through circuit
 Higher voltage = more current (if R constant)

 OHM'S LAW: V = I  R
 POWER LAW: P = V  I = IR = V/R

Practice building circuits to master these relationships!
            `;
            alert(guide);
        }

        function showShortcuts() {
            const shortcuts = `
 CONTROLS

 MOBILE:
 Touch = Select/Drag components
 Long Press = Edit component values  
 Pinch = Zoom in/out
 Single finger drag = Rotate view
 Touch terminals = Connect wires

 COMPONENTS:
 B = Add Battery
 R = Add Resistor  
 L = Add LED
 S = Add Switch
 J = Add Junction

 TOOLS:
 W = Toggle Wire Mode
 T = Toggle Rotate Mode
 C = Clear All
 Space = Toggle Menu

 EDIT:
 Ctrl+Z = Undo
 Ctrl+Y = Redo
 Ctrl+C = Copy
 Ctrl+V = Paste
 Delete = Delete Selected

 FILE:
 Ctrl+S = Save Circuit
 Ctrl+O = Load Circuit
 Ctrl+N = New Circuit

 VIEW:
 H = Reset Camera
 F = Fit to Screen
 G = Toggle Grid
            `;
            alert(shortcuts);
        }

        function showAbout() {
            const about = `
 W.I.R.E. CIRCUIT BUILDER v2.0 - ANDROID OPTIMIZED

 Educational 3D Circuit Simulator
Built with Three.js and W.I.R.E. methodology

 FEATURES:
 Interactive 3D environment with grid snapping
 Real-time electrical calculations with color coding
 Visual component labeling (B1, R1, LED1, etc.)
 Professional right-angled wire routing
 Visual current flow animation
 Long-press editing of component values
 Mobile-optimized touch controls
 Android-friendly interface and performance

 PURPOSE:
Learn electrical engineering fundamentals through hands-on experimentation with virtual circuits.

 W.I.R.E. METHOD:
  Watts (Power) - Blue
  Current (Amperes) - Orange
  Resistance (Ohms) - Green  
  EMF/Voltage (Volts) - Red

 ANDROID OPTIMIZATIONS:
 Larger touch targets for better usability
 Optimized rendering for mobile performance
 Touch-friendly menus and controls
 Reduced complexity for smooth operation

Perfect for students, educators, and hobbyists who learn visually!

 2025 W.I.R.E. Circuit Builder
            `;
            alert(about);
        }

        // UI Functions
        function addComponent(type) {
            saveState(); // Save for undo
            
            if (isDragging || selectedComponent) {
                isDragging = false;
                selectedComponent = null;
                hideSnapIndicator();
            }
            
            const position = snapToGrid(new THREE.Vector3(
                (Math.random() - 0.5) * 10,
                0,
                (Math.random() - 0.5) * 10
            ));
            
            const component = new Component(type, position);
            components.push(component);
            selectComponent(component);
            
            setStatus(` ${type} added - drag to grid position, tap to place, long press to edit values`);
            updateCircuitInfo();
            closeAllSubmenus();
        }

        function addJunction() {
            saveState(); // Save for undo
            
            if (isDragging || selectedComponent) {
                isDragging = false;
                selectedComponent = null;
                hideSnapIndicator();
            }
            
            const position = snapToGrid(new THREE.Vector3(
                (Math.random() - 0.5) * 10,
                0,
                (Math.random() - 0.5) * 10
            ));
            
            const junction = new Junction(position);
            junctions.push(junction);
            
            selectJunction(junction);
            
            setStatus(` Junction node added - drag to grid position and tap to place!`);
            updateCircuitInfo();
            closeAllSubmenus();
        }

        function toggleWireMode() {
            isWireMode = !isWireMode;
            isRotateMode = false;
            
            if (wireStart) {
                highlightConnectionPoint(wireStart, false);
                wireStart = null;
            }
            
            updateButtonStates();
            closeAllSubmenus();
            
            if (isWireMode) {
                setStatus(' WIRE MODE! Touch terminals to connect components');
            } else {
                setStatus(' Wire mode disabled');
            }
        }

        function toggleRotateMode() {
            isRotateMode = !isRotateMode;
            isWireMode = false;
            
            if (wireStart) {
                highlightConnectionPoint(wireStart, false);
                wireStart = null;
            }
            
            updateButtonStates();
            closeAllSubmenus();
            
            if (isRotateMode) {
                setStatus(' ROTATE MODE! Touch any component to rotate it 90');
            } else {
                setStatus(' Rotate mode disabled');
            }
        }

        function updateButtonStates() {
            try {
                const wireBtn = document.getElementById('wire-btn');
                const rotateBtn = document.getElementById('rotate-btn');
                
                if (wireBtn) wireBtn.classList.toggle('active', isWireMode);
                if (rotateBtn) rotateBtn.classList.toggle('active', isRotateMode);
                
                updateUndoRedoButtons();
            } catch (error) {
                console.warn('Button state update error:', error);
            }
        }



        // Circuit analysis
        function analyzeCircuit() {
            const batteries = components.filter(c => c.type === 'battery');
            
            if (batteries.length === 0) {
                updateCircuitDisplay(0, 0, Infinity, 0);
                animateCurrentFlow(false, 0);
                setStatus(' ADD A BATTERY to start W.I.R.E. analysis!');
                return;
            }
            
            if (wires.length === 0) {
                const totalVoltage = batteries.reduce((sum, bat) => sum + bat.properties.voltage, 0);
                updateCircuitDisplay(totalVoltage, 0, Infinity, 0);
                animateCurrentFlow(false, 0);
                setStatus(' ADD WIRES to complete the circuit for W.I.R.E. calculations!');
                return;
            }
            
            const result = performCircuitAnalysis();
            updateCircuitDisplay(result.voltage, result.current, result.resistance, result.power);
            
            const shouldAnimate = result.isComplete && result.current > 0;
            
            if (shouldAnimate) {
                animateCurrentFlow(true, result.current);
            } else {
                animateCurrentFlow(false, result.current);
            }
        }

        function performCircuitAnalysis() {
            const batteries = components.filter(c => c.type === 'battery');
            const resistors = components.filter(c => c.type === 'resistor' || c.type === 'led');
            const switches = components.filter(c => c.type === 'switch');
            
            const openSwitches = switches.filter(sw => !sw.properties.isOn);
            if (openSwitches.length > 0) {
                const totalVoltage = batteries.reduce((sum, bat) => sum + bat.properties.voltage, 0);
                return {
                    voltage: totalVoltage,
                    current: 0,
                    resistance: Infinity,
                    power: 0,
                    isComplete: false
                };
            }
            
            const connectedComponents = new Set();
            wires.forEach(wire => {
                connectedComponents.add(wire.startObj);
                connectedComponents.add(wire.endObj);
            });
            
            const connectedBatteries = batteries.filter(battery => connectedComponents.has(battery));
            if (connectedBatteries.length > 0 && connectedComponents.size >= 2) {
                let totalVoltage = 0;
                let totalResistance = 0.01;
                
                batteries.forEach(battery => totalVoltage += battery.properties.voltage);
                
                resistors.forEach(resistor => {
                    totalResistance += resistor.properties.resistance || 100;
                });
                
                switches.forEach(sw => {
                    if (sw.properties.isOn) {
                        totalResistance += sw.properties.resistance || 0.1;
                    }
                });
                
                const current = totalVoltage / totalResistance;
                const power = totalVoltage * current;
                
                return {
                    voltage: totalVoltage,
                    current: current,
                    resistance: totalResistance,
                    power: power,
                    isComplete: true
                };
            } else {
                const totalVoltage = batteries.reduce((sum, bat) => sum + bat.properties.voltage, 0);
                return {
                    voltage: totalVoltage,
                    current: 0,
                    resistance: Infinity,
                    power: 0,
                    isComplete: false
                };
            }
        }

        function updateCircuitDisplay(voltage, current, resistance, power) {
            // Store values for educational modes
            lastKnownValues = { voltage, current, resistance, power };
            
            // Update W.I.R.E. analysis display
            const voltageEl = document.getElementById('voltage');
            const currentEl = document.getElementById('current');
            const resistanceEl = document.getElementById('resistance');
            const powerEl = document.getElementById('power');
            
            if (voltageEl) voltageEl.textContent = voltage.toFixed(1) + 'V';
            if (currentEl) currentEl.textContent = current.toFixed(3) + 'A';
            if (resistanceEl) resistanceEl.textContent = 
                resistance === Infinity ? '' : resistance.toFixed(1) + '';
            if (powerEl) powerEl.textContent = power.toFixed(2) + 'W';
            
            const countEl = document.getElementById('count');
            const wireCountEl = document.getElementById('wire-count');
            const junctionCountEl = document.getElementById('junction-count');
            
            if (countEl) countEl.textContent = components.length;
            if (wireCountEl) wireCountEl.textContent = wires.length;
            if (junctionCountEl) junctionCountEl.textContent = junctions.length;
            
            // Update worksheet mode if active
            if (currentAnalysisTab === 'worksheet') {
                updateCalculationFormulas();
            }
            
            // Update practice status if in practice mode
            if (currentAnalysisTab === 'practice' && currentPracticeCircuit) {
                updatePracticeStatus();
            }
            
            if (current > 0 && resistance !== Infinity) {
                setStatus(` W.I.R.E. COMPLETE! W=${power.toFixed(2)}W, I=${current.toFixed(3)}A, R=${resistance.toFixed(1)}, E=${voltage.toFixed(1)}V`);
            } else if (resistance === Infinity) {
                const switches = components.filter(c => c.type === 'switch');
                const openSwitch = switches.find(sw => !sw.properties.isOn);
                
                if (openSwitch) {
                    setStatus(` OPEN CIRCUIT: Switch is OFF - touch it to complete W.I.R.E. analysis!`);
                } else {
                    setStatus(` INCOMPLETE CIRCUIT: Connect components to enable W.I.R.E. calculations`);
                }
            } else {
                setStatus(' W.I.R.E. Circuit Builder - Learn with visual methodology!');
            }
        }

        function animateCurrentFlow(hasFlow, currentValue = 0) {
            currentFlowParticles.forEach(particle => {
                if (particle && scene) {
                    scene.remove(particle);
                }
            });
            currentFlowParticles = [];
            
            if (!hasFlow || currentValue <= 0) return;
            
            const wiresForAnimation = wires;
            if (wiresForAnimation.length === 0) return;
            
            const currentIntensity = Math.min(currentValue / 0.5, 1.0);
            const flowColor = calculateCurrentColor(currentValue);
            const flowSpeed = calculateFlowSpeed(currentValue);
            
            // Reduce particle count for mobile performance
            const baseParticleCount = isMobile ? 3 : 4;
            const maxParticles = isMobile ? 8 : 12;
            const particleCount = Math.max(baseParticleCount, Math.min(maxParticles, Math.floor(currentValue * (isMobile ? 15 : 20))));
            
            wiresForAnimation.forEach((wire, wireIndex) => {
                if (!wire || !wire.wireGroup) return;
                
                if (!wire.curve) {
                    wire.createCurve();
                }
                if (!wire.curve) return;
                
                for (let i = 0; i < particleCount; i++) {
                    try {
                        const particleSize = 0.08 + (currentIntensity * 0.06);
                        const particleGeometry = new THREE.SphereGeometry(particleSize, isMobile ? 8 : 10, isMobile ? 6 : 8);
                        const particleMaterial = new THREE.MeshPhongMaterial({ 
                            color: flowColor.hex,
                            emissive: flowColor.emissive,
                            shininess: 150,
                            transparent: true,
                            opacity: 0.85 + (currentIntensity * 0.15)
                        });
                        const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                        
                        const initialProgress = (i / particleCount) + (wireIndex * 0.1);
                        const clampedProgress = Math.max(0, Math.min(1, initialProgress % 1));
                        
                        const initialPosition = wire.curve.getPoint(clampedProgress);
                        particle.position.copy(initialPosition);
                        
                        particle.userData = { 
                            wire: wire,
                            progress: clampedProgress,
                            baseSpeed: flowSpeed,
                            currentValue: currentValue,
                            flowColor: flowColor,
                            isFlowing: true
                        };
                        
                        scene.add(particle);
                        currentFlowParticles.push(particle);
                        
                    } catch (error) {
                        console.error(`Error creating particle ${i}:`, error);
                    }
                }
            });
        }

        function calculateCurrentColor(current) {
            if (current <= 0.02) {
                return { hex: 0xff3333, emissive: 0x330000 };
            } else if (current <= 0.05) {
                return { hex: 0xff8800, emissive: 0x331100 };
            } else if (current <= 0.1) {
                return { hex: 0xffff00, emissive: 0x333300 };
            } else if (current <= 0.2) {
                return { hex: 0xffffff, emissive: 0x444444 };
            } else {
                return { hex: 0xaaffff, emissive: 0x0044aa };
            }
        }

        function calculateFlowSpeed(current) {
            const baseSpeed = isMobile ? 0.008 : 0.01;
            const speedMultiplier = 1 + (current * 8);
            return Math.min(baseSpeed * speedMultiplier, isMobile ? 0.06 : 0.08);
        }

        function updateCircuitInfo() {
            updateCircuitDisplay(0, 0, Infinity, 0);
            analyzeCircuit();
        }

        // Educational Analysis Functions
        function switchAnalysisTab(tabName) {
            // Update tab buttons
            document.querySelectorAll('.analysis-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            document.getElementById(`tab-${tabName}`).classList.add('active');
            
            // Show/hide content panels
            document.querySelectorAll('.analysis-content').forEach(content => {
                content.style.display = 'none';
            });
            document.getElementById(`content-${tabName}`).style.display = 'block';
            
            currentAnalysisTab = tabName;
            
            // Update content based on tab
            switch(tabName) {
                case 'worksheet':
                    updateWorksheetDisplay();
                    break;
                case 'eir':
                    updateCircuitSchematic();
                    break;
                case 'power':
                    // Power triangle is static, no need to update
                    break;
                case 'problem':
                    updateProblemMode();
                    break;
                case 'practice':
                    updatePracticeStatus();
                    break;
            }
            
            setStatus(` Switched to ${tabName.toUpperCase()} analysis mode`);
        }

        function explainOhmsLaw(variable) {
            const formulaEl = document.getElementById('eir-formula');
            
            switch(variable) {
                case 'E':
                    formulaEl.textContent = 'E = I  R (EMF/Voltage = Current  Resistance)';
                    formulaEl.style.color = '#ff4444';
                    setStatus(' EMF/VOLTAGE: E = I  R | Measured in Volts (V)');
                    break;
                case 'I':
                    formulaEl.textContent = 'I = E  R (Current = EMF/Voltage  Resistance)';
                    formulaEl.style.color = '#ff8844';
                    setStatus(' CURRENT: I = E  R | Measured in Amperes (A)');
                    break;
                case 'R':
                    formulaEl.textContent = 'R = E  I (Resistance = EMF/Voltage  Current)';
                    formulaEl.style.color = '#44ff88';
                    setStatus(' RESISTANCE: R = E  I | Measured in Ohms ()');
                    break;
            }
            
            // Add visual feedback
            const triangleEl = document.querySelector(`.triangle-${variable.toLowerCase()}`);
            if (triangleEl) {
                triangleEl.style.textShadow = '0 0 20px currentColor';
                setTimeout(() => {
                    triangleEl.style.textShadow = '0 0 10px currentColor';
                }, 1000);
            }
        }

        function explainPowerLaw(variable) {
            const formulaEl = document.getElementById('power-formula');
            
            switch(variable) {
                case 'W':
                    formulaEl.textContent = 'W = I  E (Power = Current  EMF/Voltage)';
                    formulaEl.style.color = '#4488ff';
                    setStatus(' POWER: W = I  E | Also W = IR or W = ER | Measured in Watts (W)');
                    break;
                case 'I':
                    formulaEl.textContent = 'I = W  E (Current = Power  EMF/Voltage)';
                    formulaEl.style.color = '#ff8844';
                    setStatus(' CURRENT: I = W  E | From power triangle | Measured in Amperes (A)');
                    break;
                case 'E':
                    formulaEl.textContent = 'E = W  I (EMF/Voltage = Power  Current)';
                    formulaEl.style.color = '#ff4444';
                    setStatus(' EMF/VOLTAGE: E = W  I | From power triangle | Measured in Volts (V)');
                    break;
            }
            
            // Add visual feedback
            let triangleSelector;
            if (variable === 'W') triangleSelector = '.triangle-v'; // W is in top position
            else if (variable === 'I') triangleSelector = '.triangle-i'; // I is in bottom left
            else if (variable === 'E') triangleSelector = '.triangle-r'; // E is in bottom right position
            
            const triangleEl = document.querySelector(`#content-power ${triangleSelector}`);
            if (triangleEl) {
                triangleEl.style.textShadow = '0 0 20px currentColor';
                setTimeout(() => {
                    triangleEl.style.textShadow = '0 0 10px currentColor';
                }, 1000);
            }
        }

        function updateWorksheetDisplay() {
            const componentList = document.getElementById('component-list');
            if (!componentList) return;
            
            // Clear existing list
            componentList.innerHTML = '';
            
            // Add batteries
            components.filter(c => c.type === 'battery').forEach(battery => {
                const item = document.createElement('div');
                item.className = 'component-item';
                item.style.borderColor = '#ff4444';
                item.innerHTML = `
                    <div class="component-label">Battery ${battery.componentNumber}</div>
                    <div class="component-value" style="color: #ff4444;">${battery.properties.voltage}V</div>
                `;
                componentList.appendChild(item);
            });
            
            // Add resistors
            components.filter(c => c.type === 'resistor').forEach(resistor => {
                const item = document.createElement('div');
                item.className = 'component-item';
                item.style.borderColor = '#44ff88';
                item.innerHTML = `
                    <div class="component-label">R${resistor.componentNumber}</div>
                    <div class="component-value" style="color: #44ff88;">${resistor.properties.resistance}</div>
                `;
                componentList.appendChild(item);
            });
            
            // Add LEDs
            components.filter(c => c.type === 'led').forEach(led => {
                const item = document.createElement('div');
                item.className = 'component-item';
                item.style.borderColor = '#44ff88';
                item.innerHTML = `
                    <div class="component-label">LED${led.componentNumber}</div>
                    <div class="component-value" style="color: #44ff88;">${led.properties.resistance}</div>
                `;
                componentList.appendChild(item);
            });
            
            // Add switches
            components.filter(c => c.type === 'switch').forEach(sw => {
                const item = document.createElement('div');
                item.className = 'component-item';
                item.style.borderColor = sw.properties.isOn ? '#44ff88' : '#ff4444';
                item.innerHTML = `
                    <div class="component-label">SW${sw.componentNumber}</div>
                    <div class="component-value" style="color: ${sw.properties.isOn ? '#44ff88' : '#ff4444'};">
                        ${sw.properties.isOn ? sw.properties.resistance + '' : 'OPEN'}
                    </div>
                `;
                componentList.appendChild(item);
            });
            
            // Update calculation formulas
            updateCalculationFormulas();
        }

        function updateCalculationFormulas() {
            const resistors = components.filter(c => c.type === 'resistor' || c.type === 'led');
            const batteries = components.filter(c => c.type === 'battery');
            const switches = components.filter(c => c.type === 'switch' && c.properties.isOn);
            
            // Update resistance formula
            const resistanceFormula = document.getElementById('resistance-formula');
            if (resistanceFormula) {
                let formula = 'R_total = ';
                const allResistors = [...resistors, ...switches];
                if (allResistors.length > 0) {
                    formula += allResistors.map(r => {
                        if (r.type === 'resistor') return `R${r.componentNumber}`;
                        if (r.type === 'led') return `LED${r.componentNumber}`;
                        if (r.type === 'switch') return `SW${r.componentNumber}`;
                        return 'X';
                    }).join(' + ');
                } else {
                    formula += ' (no resistors)';
                }
                resistanceFormula.textContent = formula;
            }
            
            // Update voltage formula
            const voltageFormula = document.getElementById('voltage-formula');
            if (voltageFormula) {
                let formula = 'V_total = ';
                if (batteries.length > 0) {
                    formula += batteries.map(b => `B${b.componentNumber}`).join(' + ');
                } else {
                    formula += '0 (no batteries)';
                }
                voltageFormula.textContent = formula;
            }

            // Update calculated values in worksheet
            const calcElements = {
                'calc-resistance': lastKnownValues.resistance === Infinity ? '' : lastKnownValues.resistance.toFixed(1) + '',
                'calc-current': lastKnownValues.current.toFixed(3) + 'A',
                'calc-voltage': lastKnownValues.voltage.toFixed(1) + 'V',
                'calc-power': lastKnownValues.power.toFixed(2) + 'W'
            };

            Object.entries(calcElements).forEach(([id, value]) => {
                const el = document.getElementById(id);
                if (el) el.textContent = value;
            });
        }

        function updateCircuitSchematic() {
            const schematicEl = document.getElementById('circuit-schematic');
            if (!schematicEl) return;
            
            const batteries = components.filter(c => c.type === 'battery');
            const resistors = components.filter(c => c.type === 'resistor' || c.type === 'led');
            
            if (batteries.length === 0 && resistors.length === 0) {
                schematicEl.innerHTML = `
                    <div class="schematic-line">No components added yet</div>
                    <div class="schematic-line">Add battery and resistors</div>
                    <div class="schematic-line">to see circuit diagram</div>
                `;
                return;
            }
            
            // Generate ASCII circuit based on components
            let schematic = '';
            if (batteries.length > 0 && resistors.length > 0) {
                schematic = `
                    <div class="schematic-line">     +[R]+</div>
                    <div class="schematic-line">                   </div>
                    <div class="schematic-line">   [BAT]          [R]</div>
                    <div class="schematic-line">                   </div>
                    <div class="schematic-line">     ++</div>
                `;
            } else if (batteries.length > 0) {
                schematic = `
                    <div class="schematic-line">     ++</div>
                    <div class="schematic-line">                   </div>
                    <div class="schematic-line">   [BAT]         (no load)</div>
                    <div class="schematic-line">                   </div>
                    <div class="schematic-line">     ++</div>
                `;
            }
            
            schematicEl.innerHTML = schematic;
        }

        function updateProblemMode() {
            // Clear any previous answers
            document.getElementById('student-voltage').value = '';
            document.getElementById('student-current').value = '';
            document.getElementById('student-resistance').value = '';
            document.getElementById('student-power').value = '';
            
            const feedbackEl = document.getElementById('answer-feedback');
            if (feedbackEl) {
                feedbackEl.innerHTML = '';
            }
        }

        function checkStudentAnswers() {
            const studentVoltage = parseFloat(document.getElementById('student-voltage').value);
            const studentCurrent = parseFloat(document.getElementById('student-current').value);
            const studentResistance = parseFloat(document.getElementById('student-resistance').value);
            const studentPower = parseFloat(document.getElementById('student-power').value);
            
            const tolerance = 0.05; // 5% tolerance for answers
            const feedbackEl = document.getElementById('answer-feedback');
            
            let results = [];
            let allCorrect = true;
            
            // Check voltage
            if (!isNaN(studentVoltage)) {
                const voltageCorrect = Math.abs(studentVoltage - lastKnownValues.voltage) / lastKnownValues.voltage < tolerance;
                results.push({
                    label: 'Voltage',
                    student: studentVoltage.toFixed(1) + 'V',
                    correct: lastKnownValues.voltage.toFixed(1) + 'V',
                    isCorrect: voltageCorrect,
                    color: '#ff4444'
                });
                if (!voltageCorrect) allCorrect = false;
            }
            
            // Check current
            if (!isNaN(studentCurrent)) {
                const currentCorrect = Math.abs(studentCurrent - lastKnownValues.current) / Math.max(lastKnownValues.current, 0.001) < tolerance;
                results.push({
                    label: 'Current',
                    student: studentCurrent.toFixed(3) + 'A',
                    correct: lastKnownValues.current.toFixed(3) + 'A',
                    isCorrect: currentCorrect,
                    color: '#ff8844'
                });
                if (!currentCorrect) allCorrect = false;
            }
            
            // Check resistance
            if (!isNaN(studentResistance)) {
                const resistanceCorrect = lastKnownValues.resistance === Infinity ? 
                    studentResistance > 10000 : 
                    Math.abs(studentResistance - lastKnownValues.resistance) / lastKnownValues.resistance < tolerance;
                results.push({
                    label: 'Resistance',
                    student: studentResistance.toFixed(1) + '',
                    correct: lastKnownValues.resistance === Infinity ? '' : lastKnownValues.resistance.toFixed(1) + '',
                    isCorrect: resistanceCorrect,
                    color: '#44ff88'
                });
                if (!resistanceCorrect) allCorrect = false;
            }
            
            // Check power
            if (!isNaN(studentPower)) {
                const powerCorrect = Math.abs(studentPower - lastKnownValues.power) / Math.max(lastKnownValues.power, 0.001) < tolerance;
                results.push({
                    label: 'Power',
                    student: studentPower.toFixed(2) + 'W',
                    correct: lastKnownValues.power.toFixed(2) + 'W',
                    isCorrect: powerCorrect,
                    color: '#4488ff'
                });
                if (!powerCorrect) allCorrect = false;
            }
            
            // Display results
            let feedback = `<div class="result-feedback ${allCorrect ? 'feedback-correct' : 'feedback-incorrect'}">`;
            
            if (allCorrect && results.length > 0) {
                feedback += ' Excellent! All answers are correct!';
            } else if (results.length === 0) {
                feedback += ' Please enter at least one answer to check.';
            } else {
                feedback += ' Results:<br>';
                results.forEach(result => {
                    const icon = result.isCorrect ? '' : '';
                    feedback += `${icon} ${result.label}: ${result.student} ${result.isCorrect ? '(Correct!)' : '(Expected: ' + result.correct + ')'}<br>`;
                });
            }
            
            feedback += '</div>';
            feedbackEl.innerHTML = feedback;
        }

        // Preset Circuit Library
        const PRESET_CIRCUITS = {
            series_basic: {
                name: "Basic Series Circuit",
                description: "Simple series circuit with battery and two resistors",
                objectives: [
                    "Calculate total resistance in series (R_total = R + R)",
                    "Apply Ohm's law to find current (I = V  R_total)",
                    "Calculate power consumption (P = V  I)"
                ],
                components: [
                    { type: 'battery', position: [-4, 0, 0], properties: { voltage: 12 } },
                    { type: 'resistor', position: [0, 0, 0], properties: { resistance: 100 } },
                    { type: 'resistor', position: [4, 0, 0], properties: { resistance: 200 } }
                ],
                connections: [
                    { from: 'battery_1_positive', to: 'resistor_1_left' },
                    { from: 'resistor_1_right', to: 'resistor_2_left' },
                    { from: 'resistor_2_right', to: 'battery_1_negative' }
                ]
            },
            parallel_basic: {
                name: "Basic Parallel Circuit",
                description: "Two resistors in parallel with a battery",
                objectives: [
                    "Calculate total resistance in parallel (1/R_total = 1/R + 1/R)",
                    "Understand current division in parallel circuits",
                    "Compare parallel vs series power consumption"
                ],
                components: [
                    { type: 'battery', position: [-4, 0, 0], properties: { voltage: 9 } },
                    { type: 'resistor', position: [2, 0, 2], properties: { resistance: 150 } },
                    { type: 'resistor', position: [2, 0, -2], properties: { resistance: 300 } }
                ]
            },
            mixed_circuit: {
                name: "Mixed Series-Parallel Circuit",
                description: "Combination of series and parallel resistors",
                objectives: [
                    "Analyze complex circuits with mixed connections",
                    "Break down circuit into series and parallel sections",
                    "Apply equivalent resistance concepts"
                ],
                components: [
                    { type: 'battery', position: [-6, 0, 0], properties: { voltage: 15 } },
                    { type: 'resistor', position: [-2, 0, 0], properties: { resistance: 50 } },
                    { type: 'resistor', position: [2, 0, 2], properties: { resistance: 100 } },
                    { type: 'resistor', position: [2, 0, -2], properties: { resistance: 200 } },
                    { type: 'led', position: [6, 0, 0], properties: { resistance: 25 } }
                ]
            },
            switch_control: {
                name: "Switch-Controlled Circuit",
                description: "Circuit with switch to control current flow",
                objectives: [
                    "Understand open vs closed circuit behavior",
                    "Analyze the effect of switches on circuit operation",
                    "Calculate power consumption when switch is ON vs OFF",
                    "Practice with switch resistance calculations"
                ],
                components: [
                    { type: 'battery', position: [-4, 0, 0], properties: { voltage: 6 } },
                    { type: 'switch', position: [0, 0, 0], properties: { resistance: 0.1, isOn: false } },
                    { type: 'led', position: [4, 0, 0], properties: { resistance: 20 } }
                ]
            }
        };

        function updatePracticeStatus() {
            if (!currentPracticeCircuit) return;
            
            const circuitStatusEl = document.getElementById('circuit-status');
            const circuitStatusTextEl = document.getElementById('circuit-status-text');
            const wireInstructionsEl = document.getElementById('wire-instructions');
            
            // Check if circuit is complete (has wires connecting components)
            const isComplete = wires.length > 0 && components.length > 1;
            const hasFlow = lastKnownValues.current > 0 && lastKnownValues.resistance !== Infinity;
            
            if (circuitStatusEl && circuitStatusTextEl) {
                if (hasFlow) {
                    circuitStatusEl.className = 'circuit-status status-complete';
                    circuitStatusTextEl.textContent = ' Circuit complete - Current flowing! Switch to Solve tab.';
                    if (wireInstructionsEl) wireInstructionsEl.style.display = 'none';
                } else if (isComplete) {
                    circuitStatusEl.className = 'circuit-status status-incomplete';
                    circuitStatusTextEl.textContent = ' Circuit wired but not complete - Check connections';
                    if (wireInstructionsEl) wireInstructionsEl.style.display = 'block';
                } else {
                    circuitStatusEl.className = 'circuit-status status-incomplete';
                    circuitStatusTextEl.textContent = ' Circuit incomplete - Add wires to connect components';
                    if (wireInstructionsEl) wireInstructionsEl.style.display = 'block';
                }
            }
        }

        function loadPresetCircuit(presetName) {
            const preset = PRESET_CIRCUITS[presetName];
            if (!preset) {
                setStatus(' Preset circuit not found!');
                return;
            }
            
            // Clear current circuit
            clearAll(false);
            
            // Set current practice circuit
            currentPracticeCircuit = presetName;
            
            // If loading individual circuit (not from sequence), update index
            if (!practiceProblems.includes(presetName)) {
                // This is for individual button clicks
                currentProblemIndex = practiceProblems.indexOf(presetName);
                if (currentProblemIndex === -1) currentProblemIndex = 0;
            }
            
            // Load preset components
            preset.components.forEach((compData, index) => {
                const position = new THREE.Vector3(compData.position[0], compData.position[1], compData.position[2]);
                const component = new Component(compData.type, position);
                component.updateProperties(compData.properties);
                components.push(component);
            });
            
            // Update practice mode displays
            const questionEl = document.getElementById('practice-question');
            const descriptionEl = document.getElementById('practice-description');
            const practiceCardEl = document.getElementById('practice-problem-card');
            const helpTextEl = document.getElementById('practice-help-text');
            const objList = document.getElementById('objectives-list');
            
            const practiceInfo = practiceQuestions[presetName];
            
            if (questionEl && practiceInfo) {
                questionEl.textContent = ` Problem: ${practiceInfo.question}`;
            }
            
            if (descriptionEl && practiceInfo) {
                descriptionEl.textContent = practiceInfo.description;
            }
            
            if (practiceCardEl) {
                practiceCardEl.style.display = 'block';
            }
            
            if (helpTextEl) {
                helpTextEl.style.display = 'none';
            }
            
            if (objList && preset.objectives) {
                objList.innerHTML = preset.objectives.map(obj => `<li>${obj}</li>`).join('');
            }
            
            // Highlight the selected button (only for individual clicks)
            document.querySelectorAll('.practice-btn').forEach(btn => btn.classList.remove('active'));
            const buttonIds = {
                'series_basic': 'btn-series',
                'parallel_basic': 'btn-parallel', 
                'mixed_circuit': 'btn-mixed'
            };
            const buttonId = buttonIds[presetName];
            if (buttonId) {
                const button = document.getElementById(buttonId);
                if (button) button.classList.add('active');
            }
            
            // Update counter and navigation
            updatePracticeCounter();
            updateNavigationButtons();
            
            // Switch to practice tab if not already there
            if (currentAnalysisTab !== 'practice') {
                switchAnalysisTab('practice');
            }
            
            updateCircuitInfo();
            updatePracticeStatus();
            setStatus(` Loaded practice problem: ${preset.name} - Wire the components!`);
        }

        function autoConnectSeries() {
            // Auto-connect components in series for educational purposes
            // Note: This is mainly used for demonstration, practice mode requires manual wiring
            if (components.length < 2) return;
            
            try {
                for (let i = 0; i < components.length - 1; i++) {
                    const comp1 = components[i];
                    const comp2 = components[i + 1];
                    
                    let startSide, endSide;
                    
                    // Determine connection sides based on component types
                    if (comp1.type === 'battery') {
                        startSide = 'positive';
                    } else {
                        startSide = 'right';
                    }
                    
                    endSide = 'left';
                    
                    const wire = new Wire(comp1, startSide, comp2, endSide);
                    wires.push(wire);
                }
                
                // Close the circuit - connect last component back to battery
                if (components.length > 1) {
                    const lastComp = components[components.length - 1];
                    const battery = components.find(c => c.type === 'battery');
                    
                    if (lastComp && battery && lastComp !== battery) {
                        const wire = new Wire(lastComp, 'right', battery, 'negative');
                        wires.push(wire);
                    }
                }
                
                analyzeCircuit();
                setStatus(' Circuit auto-wired for demonstration');
            } catch (error) {
                console.log('Auto-connect failed, students can wire manually');
            }
        }

        function generateRandomProblem() {
            // Generate a random circuit problem
            const problemTypes = ['series_basic', 'parallel_basic', 'mixed_circuit'];
            const randomType = problemTypes[Math.floor(Math.random() * problemTypes.length)];
            
            loadPresetCircuit(randomType);
            
            // Randomize component values
            components.forEach(comp => {
                if (comp.type === 'battery') {
                    comp.updateProperties({ voltage: Math.floor(Math.random() * 15) + 3 }); // 3-18V
                } else if (comp.type === 'resistor') {
                    comp.updateProperties({ resistance: Math.floor(Math.random() * 500) + 50 }); // 50-550
                } else if (comp.type === 'led') {
                    comp.updateProperties({ resistance: Math.floor(Math.random() * 30) + 10 }); // 10-40
                }
            });
            
            // Highlight random button
            document.querySelectorAll('.practice-btn').forEach(btn => btn.classList.remove('active'));
            const randomBtn = document.getElementById('btn-random');
            if (randomBtn) randomBtn.classList.add('active');
            
            // Reset practice sequence tracking
            currentPracticeCircuit = 'random';
            updatePracticeCounter();
            
            updateCircuitInfo();
            updatePracticeStatus();
            setStatus(' Generated random practice problem with randomized values!');
        }

        // Practice sequence navigation functions
        function startPracticeSequence() {
            currentProblemIndex = 0;
            loadPracticeSequenceProblem();
            setStatus(' Started practice sequence - Problem 1 of 4');
        }

        function nextProblem() {
            if (currentProblemIndex < practiceProblems.length - 1) {
                currentProblemIndex++;
                loadPracticeSequenceProblem();
                setStatus(` Advanced to problem ${currentProblemIndex + 1} of ${practiceProblems.length}`);
            } else {
                setStatus(' Congratulations! You completed all practice problems!');
                alert(' Great job! You\'ve completed all practice problems.\n\nYou can:\n Start over with "Start Practice Sequence"\n Try "Random" for extra practice\n Use individual problem buttons for review');
            }
        }

        function previousProblem() {
            if (currentProblemIndex > 0) {
                currentProblemIndex--;
                loadPracticeSequenceProblem();
                setStatus(` Returned to problem ${currentProblemIndex + 1} of ${practiceProblems.length}`);
            } else {
                setStatus(' Already at the first problem');
            }
        }

        function loadPracticeSequenceProblem() {
            const problemType = practiceProblems[currentProblemIndex];
            loadPresetCircuit(problemType);
            updatePracticeCounter();
            updateNavigationButtons();
        }

        function updatePracticeCounter() {
            const counterEl = document.getElementById('problem-counter');
            const totalEl = document.getElementById('total-problems');
            
            if (counterEl && totalEl) {
                if (currentPracticeCircuit === 'random') {
                    counterEl.textContent = '?';
                    totalEl.textContent = '';
                } else {
                    counterEl.textContent = currentProblemIndex + 1;
                    totalEl.textContent = practiceProblems.length;
                }
            }
        }

        function updateNavigationButtons() {
            const prevBtn = document.getElementById('prev-btn');
            const nextBtn = document.getElementById('next-btn');
            
            if (prevBtn && nextBtn) {
                // Show/hide buttons based on position
                prevBtn.style.opacity = currentProblemIndex > 0 ? '1.0' : '0.5';
                prevBtn.disabled = currentProblemIndex === 0;
                
                if (currentProblemIndex >= practiceProblems.length - 1) {
                    nextBtn.textContent = 'Finish ';
                    nextBtn.style.background = 'linear-gradient(135deg, #ff6b6b, #ee5a52)';
                } else {
                    nextBtn.textContent = 'Next ';
                    nextBtn.style.background = 'linear-gradient(135deg, #333, #444)';
                }
            }
        }

        function clearAll(shouldSaveState = true) {
            if (shouldSaveState) {
                saveState(); // Save for undo
            }
            
            isWireMode = false;
            isRotateMode = false;
            wireStart = null;
            isDragging = false;
            selectedComponent = null;
            selectedComponents.clear();
            hideSnapIndicator();
            currentPracticeCircuit = null; // Reset practice circuit
            // Note: Don't reset currentProblemIndex to allow "Clear" during practice sequence
            
            // Reset component counters
            componentCounters = {
                battery: 0,
                resistor: 0,
                led: 0,
                switch: 0
            };
            
            currentFlowParticles.forEach(particle => {
                if (particle) scene.remove(particle);
            });
            currentFlowParticles = [];
            
            wires.forEach(wire => {
                if (wire?.wireGroup) scene.remove(wire.wireGroup);
            });
            wires = [];
            
            components.forEach(comp => {
                if (comp?.mesh) scene.remove(comp.mesh);
                if (comp?.labelDiv) document.body.removeChild(comp.labelDiv);
            });
            components = [];
            
            junctions.forEach(junction => {
                if (junction?.mesh) scene.remove(junction.mesh);
            });
            junctions = [];
            
            // Reset practice mode UI only if not in a practice sequence
            if (!currentPracticeCircuit) {
                const practiceCardEl = document.getElementById('practice-problem-card');
                const helpTextEl = document.getElementById('practice-help-text');
                if (practiceCardEl) practiceCardEl.style.display = 'none';
                if (helpTextEl) helpTextEl.style.display = 'block';
                
                // Remove active state from practice buttons
                document.querySelectorAll('.practice-btn').forEach(btn => btn.classList.remove('active'));
                
                // Reset practice sequence
                currentProblemIndex = 0;
            }
            
            updateButtonStates();
            updateCircuitInfo();
            closeAllSubmenus();
            setStatus(' ALL CLEARED! Circuit builder reset with fresh component numbering');
        }

        function showPracticeModeHelp() {
            const help = `
 PRACTICE MODE HELP

 HOW TO GET NEXT PROBLEMS:

 PRACTICE SEQUENCE (Recommended):
    Click "Start Practice Sequence" for guided progression
    Work through 4 problems in order: Series  Parallel  Mixed  Switch
    Use " Prev" and "Next " buttons to navigate
    See "Problem 1 of 4" counter to track progress
    Click "Finish " on the last problem

 INDIVIDUAL PROBLEMS:
    Click specific buttons: "Basic Series", "Basic Parallel", etc.
    Jump to any problem for review or extra practice
    Still shows problem counter and navigation

 RANDOM PROBLEMS:
    Click "Random" for randomized component values
    Same circuit types, but different numbers each time
    Perfect for extra practice and testing

 WIRING PROCESS:
   1. Problem loads with components placed automatically
   2. Read the question: "Find total resistance", etc.
   3. Click  Tools   Wire Mode
   4. Touch colored terminals to connect:
      - Red = Battery positive (+)
      - Gray = Battery negative (-)
      - White = Component terminals
   5. Status changes:  Incomplete   Complete

 SOLVING PROBLEMS:
    Switch to EIR  for Ohm's law (E=IR)
    Use Power  for power calculations (W=IE)
    Try Worksheet for step-by-step formulas
    Go to Solve tab to check your answers

Perfect sequence for learning circuit analysis!
            `;
            alert(help);
        }

        function setStatus(message) {
            const statusEl = document.getElementById('status');
            if (statusEl) {
                statusEl.textContent = message;
                statusEl.style.display = 'block';
                
                setTimeout(() => {
                    if (statusEl.style.display !== 'none') {
                        statusEl.style.display = 'none';
                    }
                }, isMobile ? 6000 : 5000); // Longer display time on mobile
            }
        }

        // Start the application
        init();
    </script>
</body>
</html>